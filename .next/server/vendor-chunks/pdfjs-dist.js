/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ (function webpackUniversalModuleDefinition1(root1, factory1) {\n    if (true) module.exports = root1.pdfjsLib = factory1();\n    else {}\n})(globalThis, ()=>{\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            /* 1 */ /***/ (__unused_webpack_module1, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.VerbosityLevel = exports1.Util = exports1.UnknownErrorException = exports1.UnexpectedResponseException = exports1.TextRenderingMode = exports1.RenderingIntentFlag = exports1.PromiseCapability = exports1.PermissionFlag = exports1.PasswordResponses = exports1.PasswordException = exports1.PageActionEventType = exports1.OPS = exports1.MissingPDFException = exports1.MAX_IMAGE_SIZE_TO_CACHE = exports1.LINE_FACTOR = exports1.LINE_DESCENT_FACTOR = exports1.InvalidPDFException = exports1.ImageKind = exports1.IDENTITY_MATRIX = exports1.FormatError = exports1.FeatureTest = exports1.FONT_IDENTITY_MATRIX = exports1.DocumentActionEventType = exports1.CMapCompressionType = exports1.BaseException = exports1.BASELINE_FACTOR = exports1.AnnotationType = exports1.AnnotationReplyType = exports1.AnnotationPrefix = exports1.AnnotationMode = exports1.AnnotationFlag = exports1.AnnotationFieldFlag = exports1.AnnotationEditorType = exports1.AnnotationEditorPrefix = exports1.AnnotationEditorParamsType = exports1.AnnotationBorderStyleType = exports1.AnnotationActionEventType = exports1.AbortException = void 0;\n                exports1.assert = assert1;\n                exports1.bytesToString = bytesToString1;\n                exports1.createValidAbsoluteUrl = createValidAbsoluteUrl1;\n                exports1.getModificationDate = getModificationDate1;\n                exports1.getUuid = getUuid1;\n                exports1.getVerbosityLevel = getVerbosityLevel1;\n                exports1.info = info1;\n                exports1.isArrayBuffer = isArrayBuffer1;\n                exports1.isArrayEqual = isArrayEqual1;\n                exports1.isNodeJS = void 0;\n                exports1.normalizeUnicode = normalizeUnicode1;\n                exports1.objectFromMap = objectFromMap1;\n                exports1.objectSize = objectSize1;\n                exports1.setVerbosityLevel = setVerbosityLevel1;\n                exports1.shadow = shadow1;\n                exports1.string32 = string321;\n                exports1.stringToBytes = stringToBytes1;\n                exports1.stringToPDFString = stringToPDFString1;\n                exports1.stringToUTF8String = stringToUTF8String1;\n                exports1.unreachable = unreachable1;\n                exports1.utf8StringToString = utf8StringToString1;\n                exports1.warn = warn1;\n                const isNodeJS1 = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\n                exports1.isNodeJS = isNodeJS1;\n                const IDENTITY_MATRIX1 = [\n                    1,\n                    0,\n                    0,\n                    1,\n                    0,\n                    0\n                ];\n                exports1.IDENTITY_MATRIX = IDENTITY_MATRIX1;\n                const FONT_IDENTITY_MATRIX1 = [\n                    0.001,\n                    0,\n                    0,\n                    0.001,\n                    0,\n                    0\n                ];\n                exports1.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX1;\n                const MAX_IMAGE_SIZE_TO_CACHE1 = 10e6;\n                exports1.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE1;\n                const LINE_FACTOR1 = 1.35;\n                exports1.LINE_FACTOR = LINE_FACTOR1;\n                const LINE_DESCENT_FACTOR1 = 0.35;\n                exports1.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR1;\n                const BASELINE_FACTOR1 = LINE_DESCENT_FACTOR1 / LINE_FACTOR1;\n                exports1.BASELINE_FACTOR = BASELINE_FACTOR1;\n                const RenderingIntentFlag1 = {\n                    ANY: 0x01,\n                    DISPLAY: 0x02,\n                    PRINT: 0x04,\n                    SAVE: 0x08,\n                    ANNOTATIONS_FORMS: 0x10,\n                    ANNOTATIONS_STORAGE: 0x20,\n                    ANNOTATIONS_DISABLE: 0x40,\n                    OPLIST: 0x100\n                };\n                exports1.RenderingIntentFlag = RenderingIntentFlag1;\n                const AnnotationMode1 = {\n                    DISABLE: 0,\n                    ENABLE: 1,\n                    ENABLE_FORMS: 2,\n                    ENABLE_STORAGE: 3\n                };\n                exports1.AnnotationMode = AnnotationMode1;\n                const AnnotationEditorPrefix1 = \"pdfjs_internal_editor_\";\n                exports1.AnnotationEditorPrefix = AnnotationEditorPrefix1;\n                const AnnotationEditorType1 = {\n                    DISABLE: -1,\n                    NONE: 0,\n                    FREETEXT: 3,\n                    STAMP: 13,\n                    INK: 15\n                };\n                exports1.AnnotationEditorType = AnnotationEditorType1;\n                const AnnotationEditorParamsType1 = {\n                    RESIZE: 1,\n                    CREATE: 2,\n                    FREETEXT_SIZE: 11,\n                    FREETEXT_COLOR: 12,\n                    FREETEXT_OPACITY: 13,\n                    INK_COLOR: 21,\n                    INK_THICKNESS: 22,\n                    INK_OPACITY: 23\n                };\n                exports1.AnnotationEditorParamsType = AnnotationEditorParamsType1;\n                const PermissionFlag1 = {\n                    PRINT: 0x04,\n                    MODIFY_CONTENTS: 0x08,\n                    COPY: 0x10,\n                    MODIFY_ANNOTATIONS: 0x20,\n                    FILL_INTERACTIVE_FORMS: 0x100,\n                    COPY_FOR_ACCESSIBILITY: 0x200,\n                    ASSEMBLE: 0x400,\n                    PRINT_HIGH_QUALITY: 0x800\n                };\n                exports1.PermissionFlag = PermissionFlag1;\n                const TextRenderingMode1 = {\n                    FILL: 0,\n                    STROKE: 1,\n                    FILL_STROKE: 2,\n                    INVISIBLE: 3,\n                    FILL_ADD_TO_PATH: 4,\n                    STROKE_ADD_TO_PATH: 5,\n                    FILL_STROKE_ADD_TO_PATH: 6,\n                    ADD_TO_PATH: 7,\n                    FILL_STROKE_MASK: 3,\n                    ADD_TO_PATH_FLAG: 4\n                };\n                exports1.TextRenderingMode = TextRenderingMode1;\n                const ImageKind1 = {\n                    GRAYSCALE_1BPP: 1,\n                    RGB_24BPP: 2,\n                    RGBA_32BPP: 3\n                };\n                exports1.ImageKind = ImageKind1;\n                const AnnotationType1 = {\n                    TEXT: 1,\n                    LINK: 2,\n                    FREETEXT: 3,\n                    LINE: 4,\n                    SQUARE: 5,\n                    CIRCLE: 6,\n                    POLYGON: 7,\n                    POLYLINE: 8,\n                    HIGHLIGHT: 9,\n                    UNDERLINE: 10,\n                    SQUIGGLY: 11,\n                    STRIKEOUT: 12,\n                    STAMP: 13,\n                    CARET: 14,\n                    INK: 15,\n                    POPUP: 16,\n                    FILEATTACHMENT: 17,\n                    SOUND: 18,\n                    MOVIE: 19,\n                    WIDGET: 20,\n                    SCREEN: 21,\n                    PRINTERMARK: 22,\n                    TRAPNET: 23,\n                    WATERMARK: 24,\n                    THREED: 25,\n                    REDACT: 26\n                };\n                exports1.AnnotationType = AnnotationType1;\n                const AnnotationReplyType1 = {\n                    GROUP: \"Group\",\n                    REPLY: \"R\"\n                };\n                exports1.AnnotationReplyType = AnnotationReplyType1;\n                const AnnotationFlag1 = {\n                    INVISIBLE: 0x01,\n                    HIDDEN: 0x02,\n                    PRINT: 0x04,\n                    NOZOOM: 0x08,\n                    NOROTATE: 0x10,\n                    NOVIEW: 0x20,\n                    READONLY: 0x40,\n                    LOCKED: 0x80,\n                    TOGGLENOVIEW: 0x100,\n                    LOCKEDCONTENTS: 0x200\n                };\n                exports1.AnnotationFlag = AnnotationFlag1;\n                const AnnotationFieldFlag1 = {\n                    READONLY: 0x0000001,\n                    REQUIRED: 0x0000002,\n                    NOEXPORT: 0x0000004,\n                    MULTILINE: 0x0001000,\n                    PASSWORD: 0x0002000,\n                    NOTOGGLETOOFF: 0x0004000,\n                    RADIO: 0x0008000,\n                    PUSHBUTTON: 0x0010000,\n                    COMBO: 0x0020000,\n                    EDIT: 0x0040000,\n                    SORT: 0x0080000,\n                    FILESELECT: 0x0100000,\n                    MULTISELECT: 0x0200000,\n                    DONOTSPELLCHECK: 0x0400000,\n                    DONOTSCROLL: 0x0800000,\n                    COMB: 0x1000000,\n                    RICHTEXT: 0x2000000,\n                    RADIOSINUNISON: 0x2000000,\n                    COMMITONSELCHANGE: 0x4000000\n                };\n                exports1.AnnotationFieldFlag = AnnotationFieldFlag1;\n                const AnnotationBorderStyleType1 = {\n                    SOLID: 1,\n                    DASHED: 2,\n                    BEVELED: 3,\n                    INSET: 4,\n                    UNDERLINE: 5\n                };\n                exports1.AnnotationBorderStyleType = AnnotationBorderStyleType1;\n                const AnnotationActionEventType1 = {\n                    E: \"Mouse Enter\",\n                    X: \"Mouse Exit\",\n                    D: \"Mouse Down\",\n                    U: \"Mouse Up\",\n                    Fo: \"Focus\",\n                    Bl: \"Blur\",\n                    PO: \"PageOpen\",\n                    PC: \"PageClose\",\n                    PV: \"PageVisible\",\n                    PI: \"PageInvisible\",\n                    K: \"Keystroke\",\n                    F: \"Format\",\n                    V: \"Validate\",\n                    C: \"Calculate\"\n                };\n                exports1.AnnotationActionEventType = AnnotationActionEventType1;\n                const DocumentActionEventType1 = {\n                    WC: \"WillClose\",\n                    WS: \"WillSave\",\n                    DS: \"DidSave\",\n                    WP: \"WillPrint\",\n                    DP: \"DidPrint\"\n                };\n                exports1.DocumentActionEventType = DocumentActionEventType1;\n                const PageActionEventType1 = {\n                    O: \"PageOpen\",\n                    C: \"PageClose\"\n                };\n                exports1.PageActionEventType = PageActionEventType1;\n                const VerbosityLevel1 = {\n                    ERRORS: 0,\n                    WARNINGS: 1,\n                    INFOS: 5\n                };\n                exports1.VerbosityLevel = VerbosityLevel1;\n                const CMapCompressionType1 = {\n                    NONE: 0,\n                    BINARY: 1\n                };\n                exports1.CMapCompressionType = CMapCompressionType1;\n                const OPS1 = {\n                    dependency: 1,\n                    setLineWidth: 2,\n                    setLineCap: 3,\n                    setLineJoin: 4,\n                    setMiterLimit: 5,\n                    setDash: 6,\n                    setRenderingIntent: 7,\n                    setFlatness: 8,\n                    setGState: 9,\n                    save: 10,\n                    restore: 11,\n                    transform: 12,\n                    moveTo: 13,\n                    lineTo: 14,\n                    curveTo: 15,\n                    curveTo2: 16,\n                    curveTo3: 17,\n                    closePath: 18,\n                    rectangle: 19,\n                    stroke: 20,\n                    closeStroke: 21,\n                    fill: 22,\n                    eoFill: 23,\n                    fillStroke: 24,\n                    eoFillStroke: 25,\n                    closeFillStroke: 26,\n                    closeEOFillStroke: 27,\n                    endPath: 28,\n                    clip: 29,\n                    eoClip: 30,\n                    beginText: 31,\n                    endText: 32,\n                    setCharSpacing: 33,\n                    setWordSpacing: 34,\n                    setHScale: 35,\n                    setLeading: 36,\n                    setFont: 37,\n                    setTextRenderingMode: 38,\n                    setTextRise: 39,\n                    moveText: 40,\n                    setLeadingMoveText: 41,\n                    setTextMatrix: 42,\n                    nextLine: 43,\n                    showText: 44,\n                    showSpacedText: 45,\n                    nextLineShowText: 46,\n                    nextLineSetSpacingShowText: 47,\n                    setCharWidth: 48,\n                    setCharWidthAndBounds: 49,\n                    setStrokeColorSpace: 50,\n                    setFillColorSpace: 51,\n                    setStrokeColor: 52,\n                    setStrokeColorN: 53,\n                    setFillColor: 54,\n                    setFillColorN: 55,\n                    setStrokeGray: 56,\n                    setFillGray: 57,\n                    setStrokeRGBColor: 58,\n                    setFillRGBColor: 59,\n                    setStrokeCMYKColor: 60,\n                    setFillCMYKColor: 61,\n                    shadingFill: 62,\n                    beginInlineImage: 63,\n                    beginImageData: 64,\n                    endInlineImage: 65,\n                    paintXObject: 66,\n                    markPoint: 67,\n                    markPointProps: 68,\n                    beginMarkedContent: 69,\n                    beginMarkedContentProps: 70,\n                    endMarkedContent: 71,\n                    beginCompat: 72,\n                    endCompat: 73,\n                    paintFormXObjectBegin: 74,\n                    paintFormXObjectEnd: 75,\n                    beginGroup: 76,\n                    endGroup: 77,\n                    beginAnnotation: 80,\n                    endAnnotation: 81,\n                    paintImageMaskXObject: 83,\n                    paintImageMaskXObjectGroup: 84,\n                    paintImageXObject: 85,\n                    paintInlineImageXObject: 86,\n                    paintInlineImageXObjectGroup: 87,\n                    paintImageXObjectRepeat: 88,\n                    paintImageMaskXObjectRepeat: 89,\n                    paintSolidColorImageMask: 90,\n                    constructPath: 91\n                };\n                exports1.OPS = OPS1;\n                const PasswordResponses1 = {\n                    NEED_PASSWORD: 1,\n                    INCORRECT_PASSWORD: 2\n                };\n                exports1.PasswordResponses = PasswordResponses1;\n                let verbosity1 = VerbosityLevel1.WARNINGS;\n                function setVerbosityLevel1(level1) {\n                    if (Number.isInteger(level1)) {\n                        verbosity1 = level1;\n                    }\n                }\n                function getVerbosityLevel1() {\n                    return verbosity1;\n                }\n                function info1(msg1) {\n                    if (verbosity1 >= VerbosityLevel1.INFOS) {\n                        console.log(`Info: ${msg1}`);\n                    }\n                }\n                function warn1(msg1) {\n                    if (verbosity1 >= VerbosityLevel1.WARNINGS) {\n                        console.log(`Warning: ${msg1}`);\n                    }\n                }\n                function unreachable1(msg1) {\n                    throw new Error(msg1);\n                }\n                function assert1(cond1, msg1) {\n                    if (!cond1) {\n                        unreachable1(msg1);\n                    }\n                }\n                function _isValidProtocol1(url1) {\n                    switch(url1?.protocol){\n                        case \"http:\":\n                        case \"https:\":\n                        case \"ftp:\":\n                        case \"mailto:\":\n                        case \"tel:\":\n                            return true;\n                        default:\n                            return false;\n                    }\n                }\n                function createValidAbsoluteUrl1(url1, baseUrl1 = null, options1 = null) {\n                    if (!url1) {\n                        return null;\n                    }\n                    try {\n                        if (options1 && typeof url1 === \"string\") {\n                            if (options1.addDefaultProtocol && url1.startsWith(\"www.\")) {\n                                const dots1 = url1.match(/\\./g);\n                                if (dots1?.length >= 2) {\n                                    url1 = `http://${url1}`;\n                                }\n                            }\n                            if (options1.tryConvertEncoding) {\n                                try {\n                                    url1 = stringToUTF8String1(url1);\n                                } catch  {}\n                            }\n                        }\n                        const absoluteUrl1 = baseUrl1 ? new URL(url1, baseUrl1) : new URL(url1);\n                        if (_isValidProtocol1(absoluteUrl1)) {\n                            return absoluteUrl1;\n                        }\n                    } catch  {}\n                    return null;\n                }\n                function shadow1(obj1, prop1, value1, nonSerializable1 = false) {\n                    Object.defineProperty(obj1, prop1, {\n                        value: value1,\n                        enumerable: !nonSerializable1,\n                        configurable: true,\n                        writable: false\n                    });\n                    return value1;\n                }\n                const BaseException1 = function BaseExceptionClosure1() {\n                    function BaseException1(message1, name1) {\n                        if (this.constructor === BaseException1) {\n                            unreachable1(\"Cannot initialize BaseException.\");\n                        }\n                        this.message = message1;\n                        this.name = name1;\n                    }\n                    BaseException1.prototype = new Error();\n                    BaseException1.constructor = BaseException1;\n                    return BaseException1;\n                }();\n                exports1.BaseException = BaseException1;\n                class PasswordException1 extends BaseException1 {\n                    constructor(msg1, code1){\n                        super(msg1, \"PasswordException\");\n                        this.code = code1;\n                    }\n                }\n                exports1.PasswordException = PasswordException1;\n                class UnknownErrorException1 extends BaseException1 {\n                    constructor(msg1, details1){\n                        super(msg1, \"UnknownErrorException\");\n                        this.details = details1;\n                    }\n                }\n                exports1.UnknownErrorException = UnknownErrorException1;\n                class InvalidPDFException1 extends BaseException1 {\n                    constructor(msg1){\n                        super(msg1, \"InvalidPDFException\");\n                    }\n                }\n                exports1.InvalidPDFException = InvalidPDFException1;\n                class MissingPDFException1 extends BaseException1 {\n                    constructor(msg1){\n                        super(msg1, \"MissingPDFException\");\n                    }\n                }\n                exports1.MissingPDFException = MissingPDFException1;\n                class UnexpectedResponseException1 extends BaseException1 {\n                    constructor(msg1, status1){\n                        super(msg1, \"UnexpectedResponseException\");\n                        this.status = status1;\n                    }\n                }\n                exports1.UnexpectedResponseException = UnexpectedResponseException1;\n                class FormatError1 extends BaseException1 {\n                    constructor(msg1){\n                        super(msg1, \"FormatError\");\n                    }\n                }\n                exports1.FormatError = FormatError1;\n                class AbortException1 extends BaseException1 {\n                    constructor(msg1){\n                        super(msg1, \"AbortException\");\n                    }\n                }\n                exports1.AbortException = AbortException1;\n                function bytesToString1(bytes1) {\n                    if (typeof bytes1 !== \"object\" || bytes1?.length === undefined) {\n                        unreachable1(\"Invalid argument for bytesToString\");\n                    }\n                    const length1 = bytes1.length;\n                    const MAX_ARGUMENT_COUNT1 = 8192;\n                    if (length1 < MAX_ARGUMENT_COUNT1) {\n                        return String.fromCharCode.apply(null, bytes1);\n                    }\n                    const strBuf1 = [];\n                    for(let i1 = 0; i1 < length1; i1 += MAX_ARGUMENT_COUNT1){\n                        const chunkEnd1 = Math.min(i1 + MAX_ARGUMENT_COUNT1, length1);\n                        const chunk3 = bytes1.subarray(i1, chunkEnd1);\n                        strBuf1.push(String.fromCharCode.apply(null, chunk3));\n                    }\n                    return strBuf1.join(\"\");\n                }\n                function stringToBytes1(str1) {\n                    if (typeof str1 !== \"string\") {\n                        unreachable1(\"Invalid argument for stringToBytes\");\n                    }\n                    const length1 = str1.length;\n                    const bytes1 = new Uint8Array(length1);\n                    for(let i1 = 0; i1 < length1; ++i1){\n                        bytes1[i1] = str1.charCodeAt(i1) & 0xff;\n                    }\n                    return bytes1;\n                }\n                function string321(value1) {\n                    return String.fromCharCode(value1 >> 24 & 0xff, value1 >> 16 & 0xff, value1 >> 8 & 0xff, value1 & 0xff);\n                }\n                function objectSize1(obj1) {\n                    return Object.keys(obj1).length;\n                }\n                function objectFromMap1(map1) {\n                    const obj1 = Object.create(null);\n                    for (const [key1, value1] of map1){\n                        obj1[key1] = value1;\n                    }\n                    return obj1;\n                }\n                function isLittleEndian1() {\n                    const buffer81 = new Uint8Array(4);\n                    buffer81[0] = 1;\n                    const view321 = new Uint32Array(buffer81.buffer, 0, 1);\n                    return view321[0] === 1;\n                }\n                function isEvalSupported1() {\n                    try {\n                        new Function(\"\");\n                        return true;\n                    } catch  {\n                        return false;\n                    }\n                }\n                class FeatureTest1 {\n                    static get isLittleEndian() {\n                        return shadow1(this, \"isLittleEndian\", isLittleEndian1());\n                    }\n                    static get isEvalSupported() {\n                        return shadow1(this, \"isEvalSupported\", isEvalSupported1());\n                    }\n                    static get isOffscreenCanvasSupported() {\n                        return shadow1(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n                    }\n                    static get platform() {\n                        if (typeof navigator === \"undefined\") {\n                            return shadow1(this, \"platform\", {\n                                isWin: false,\n                                isMac: false\n                            });\n                        }\n                        return shadow1(this, \"platform\", {\n                            isWin: navigator.platform.includes(\"Win\"),\n                            isMac: navigator.platform.includes(\"Mac\")\n                        });\n                    }\n                    static get isCSSRoundSupported() {\n                        return shadow1(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n                    }\n                }\n                exports1.FeatureTest = FeatureTest1;\n                const hexNumbers1 = [\n                    ...Array(256).keys()\n                ].map((n1)=>n1.toString(16).padStart(2, \"0\"));\n                class Util1 {\n                    static makeHexColor(r1, g1, b4) {\n                        return `#${hexNumbers1[r1]}${hexNumbers1[g1]}${hexNumbers1[b4]}`;\n                    }\n                    static scaleMinMax(transform1, minMax1) {\n                        let temp1;\n                        if (transform1[0]) {\n                            if (transform1[0] < 0) {\n                                temp1 = minMax1[0];\n                                minMax1[0] = minMax1[1];\n                                minMax1[1] = temp1;\n                            }\n                            minMax1[0] *= transform1[0];\n                            minMax1[1] *= transform1[0];\n                            if (transform1[3] < 0) {\n                                temp1 = minMax1[2];\n                                minMax1[2] = minMax1[3];\n                                minMax1[3] = temp1;\n                            }\n                            minMax1[2] *= transform1[3];\n                            minMax1[3] *= transform1[3];\n                        } else {\n                            temp1 = minMax1[0];\n                            minMax1[0] = minMax1[2];\n                            minMax1[2] = temp1;\n                            temp1 = minMax1[1];\n                            minMax1[1] = minMax1[3];\n                            minMax1[3] = temp1;\n                            if (transform1[1] < 0) {\n                                temp1 = minMax1[2];\n                                minMax1[2] = minMax1[3];\n                                minMax1[3] = temp1;\n                            }\n                            minMax1[2] *= transform1[1];\n                            minMax1[3] *= transform1[1];\n                            if (transform1[2] < 0) {\n                                temp1 = minMax1[0];\n                                minMax1[0] = minMax1[1];\n                                minMax1[1] = temp1;\n                            }\n                            minMax1[0] *= transform1[2];\n                            minMax1[1] *= transform1[2];\n                        }\n                        minMax1[0] += transform1[4];\n                        minMax1[1] += transform1[4];\n                        minMax1[2] += transform1[5];\n                        minMax1[3] += transform1[5];\n                    }\n                    static transform(m11, m21) {\n                        return [\n                            m11[0] * m21[0] + m11[2] * m21[1],\n                            m11[1] * m21[0] + m11[3] * m21[1],\n                            m11[0] * m21[2] + m11[2] * m21[3],\n                            m11[1] * m21[2] + m11[3] * m21[3],\n                            m11[0] * m21[4] + m11[2] * m21[5] + m11[4],\n                            m11[1] * m21[4] + m11[3] * m21[5] + m11[5]\n                        ];\n                    }\n                    static applyTransform(p5, m3) {\n                        const xt1 = p5[0] * m3[0] + p5[1] * m3[2] + m3[4];\n                        const yt1 = p5[0] * m3[1] + p5[1] * m3[3] + m3[5];\n                        return [\n                            xt1,\n                            yt1\n                        ];\n                    }\n                    static applyInverseTransform(p5, m3) {\n                        const d5 = m3[0] * m3[3] - m3[1] * m3[2];\n                        const xt1 = (p5[0] * m3[3] - p5[1] * m3[2] + m3[2] * m3[5] - m3[4] * m3[3]) / d5;\n                        const yt1 = (-p5[0] * m3[1] + p5[1] * m3[0] + m3[4] * m3[1] - m3[5] * m3[0]) / d5;\n                        return [\n                            xt1,\n                            yt1\n                        ];\n                    }\n                    static getAxialAlignedBoundingBox(r1, m3) {\n                        const p12 = this.applyTransform(r1, m3);\n                        const p22 = this.applyTransform(r1.slice(2, 4), m3);\n                        const p32 = this.applyTransform([\n                            r1[0],\n                            r1[3]\n                        ], m3);\n                        const p42 = this.applyTransform([\n                            r1[2],\n                            r1[1]\n                        ], m3);\n                        return [\n                            Math.min(p12[0], p22[0], p32[0], p42[0]),\n                            Math.min(p12[1], p22[1], p32[1], p42[1]),\n                            Math.max(p12[0], p22[0], p32[0], p42[0]),\n                            Math.max(p12[1], p22[1], p32[1], p42[1])\n                        ];\n                    }\n                    static inverseTransform(m3) {\n                        const d5 = m3[0] * m3[3] - m3[1] * m3[2];\n                        return [\n                            m3[3] / d5,\n                            -m3[1] / d5,\n                            -m3[2] / d5,\n                            m3[0] / d5,\n                            (m3[2] * m3[5] - m3[4] * m3[3]) / d5,\n                            (m3[4] * m3[1] - m3[5] * m3[0]) / d5\n                        ];\n                    }\n                    static singularValueDecompose2dScale(m3) {\n                        const transpose1 = [\n                            m3[0],\n                            m3[2],\n                            m3[1],\n                            m3[3]\n                        ];\n                        const a1 = m3[0] * transpose1[0] + m3[1] * transpose1[2];\n                        const b4 = m3[0] * transpose1[1] + m3[1] * transpose1[3];\n                        const c4 = m3[2] * transpose1[0] + m3[3] * transpose1[2];\n                        const d5 = m3[2] * transpose1[1] + m3[3] * transpose1[3];\n                        const first1 = (a1 + d5) / 2;\n                        const second1 = Math.sqrt((a1 + d5) ** 2 - 4 * (a1 * d5 - c4 * b4)) / 2;\n                        const sx1 = first1 + second1 || 1;\n                        const sy1 = first1 - second1 || 1;\n                        return [\n                            Math.sqrt(sx1),\n                            Math.sqrt(sy1)\n                        ];\n                    }\n                    static normalizeRect(rect3) {\n                        const r1 = rect3.slice(0);\n                        if (rect3[0] > rect3[2]) {\n                            r1[0] = rect3[2];\n                            r1[2] = rect3[0];\n                        }\n                        if (rect3[1] > rect3[3]) {\n                            r1[1] = rect3[3];\n                            r1[3] = rect3[1];\n                        }\n                        return r1;\n                    }\n                    static intersect(rect11, rect21) {\n                        const xLow1 = Math.max(Math.min(rect11[0], rect11[2]), Math.min(rect21[0], rect21[2]));\n                        const xHigh1 = Math.min(Math.max(rect11[0], rect11[2]), Math.max(rect21[0], rect21[2]));\n                        if (xLow1 > xHigh1) {\n                            return null;\n                        }\n                        const yLow1 = Math.max(Math.min(rect11[1], rect11[3]), Math.min(rect21[1], rect21[3]));\n                        const yHigh1 = Math.min(Math.max(rect11[1], rect11[3]), Math.max(rect21[1], rect21[3]));\n                        if (yLow1 > yHigh1) {\n                            return null;\n                        }\n                        return [\n                            xLow1,\n                            yLow1,\n                            xHigh1,\n                            yHigh1\n                        ];\n                    }\n                    static bezierBoundingBox(x01, y01, x11, y11, x21, y21, x31, y31) {\n                        const tvalues1 = [], bounds1 = [\n                            [],\n                            []\n                        ];\n                        let a1, b4, c4, t3, t11, t21, b2ac1, sqrtb2ac1;\n                        for(let i1 = 0; i1 < 2; ++i1){\n                            if (i1 === 0) {\n                                b4 = 6 * x01 - 12 * x11 + 6 * x21;\n                                a1 = -3 * x01 + 9 * x11 - 9 * x21 + 3 * x31;\n                                c4 = 3 * x11 - 3 * x01;\n                            } else {\n                                b4 = 6 * y01 - 12 * y11 + 6 * y21;\n                                a1 = -3 * y01 + 9 * y11 - 9 * y21 + 3 * y31;\n                                c4 = 3 * y11 - 3 * y01;\n                            }\n                            if (Math.abs(a1) < 1e-12) {\n                                if (Math.abs(b4) < 1e-12) {\n                                    continue;\n                                }\n                                t3 = -c4 / b4;\n                                if (0 < t3 && t3 < 1) {\n                                    tvalues1.push(t3);\n                                }\n                                continue;\n                            }\n                            b2ac1 = b4 * b4 - 4 * c4 * a1;\n                            sqrtb2ac1 = Math.sqrt(b2ac1);\n                            if (b2ac1 < 0) {\n                                continue;\n                            }\n                            t11 = (-b4 + sqrtb2ac1) / (2 * a1);\n                            if (0 < t11 && t11 < 1) {\n                                tvalues1.push(t11);\n                            }\n                            t21 = (-b4 - sqrtb2ac1) / (2 * a1);\n                            if (0 < t21 && t21 < 1) {\n                                tvalues1.push(t21);\n                            }\n                        }\n                        let j1 = tvalues1.length, mt1;\n                        const jlen1 = j1;\n                        while(j1--){\n                            t3 = tvalues1[j1];\n                            mt1 = 1 - t3;\n                            bounds1[0][j1] = mt1 * mt1 * mt1 * x01 + 3 * mt1 * mt1 * t3 * x11 + 3 * mt1 * t3 * t3 * x21 + t3 * t3 * t3 * x31;\n                            bounds1[1][j1] = mt1 * mt1 * mt1 * y01 + 3 * mt1 * mt1 * t3 * y11 + 3 * mt1 * t3 * t3 * y21 + t3 * t3 * t3 * y31;\n                        }\n                        bounds1[0][jlen1] = x01;\n                        bounds1[1][jlen1] = y01;\n                        bounds1[0][jlen1 + 1] = x31;\n                        bounds1[1][jlen1 + 1] = y31;\n                        bounds1[0].length = bounds1[1].length = jlen1 + 2;\n                        return [\n                            Math.min(...bounds1[0]),\n                            Math.min(...bounds1[1]),\n                            Math.max(...bounds1[0]),\n                            Math.max(...bounds1[1])\n                        ];\n                    }\n                }\n                exports1.Util = Util1;\n                const PDFStringTranslateTable1 = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2d8,\n                    0x2c7,\n                    0x2c6,\n                    0x2d9,\n                    0x2dd,\n                    0x2db,\n                    0x2da,\n                    0x2dc,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0x2022,\n                    0x2020,\n                    0x2021,\n                    0x2026,\n                    0x2014,\n                    0x2013,\n                    0x192,\n                    0x2044,\n                    0x2039,\n                    0x203a,\n                    0x2212,\n                    0x2030,\n                    0x201e,\n                    0x201c,\n                    0x201d,\n                    0x2018,\n                    0x2019,\n                    0x201a,\n                    0x2122,\n                    0xfb01,\n                    0xfb02,\n                    0x141,\n                    0x152,\n                    0x160,\n                    0x178,\n                    0x17d,\n                    0x131,\n                    0x142,\n                    0x153,\n                    0x161,\n                    0x17e,\n                    0,\n                    0x20ac\n                ];\n                function stringToPDFString1(str1) {\n                    if (str1[0] >= \"\\xef\") {\n                        let encoding1;\n                        if (str1[0] === \"\\xfe\" && str1[1] === \"\\xff\") {\n                            encoding1 = \"utf-16be\";\n                        } else if (str1[0] === \"\\xff\" && str1[1] === \"\\xfe\") {\n                            encoding1 = \"utf-16le\";\n                        } else if (str1[0] === \"\\xef\" && str1[1] === \"\\xbb\" && str1[2] === \"\\xbf\") {\n                            encoding1 = \"utf-8\";\n                        }\n                        if (encoding1) {\n                            try {\n                                const decoder1 = new TextDecoder(encoding1, {\n                                    fatal: true\n                                });\n                                const buffer1 = stringToBytes1(str1);\n                                return decoder1.decode(buffer1);\n                            } catch (ex1) {\n                                warn1(`stringToPDFString: \"${ex1}\".`);\n                            }\n                        }\n                    }\n                    const strBuf1 = [];\n                    for(let i1 = 0, ii1 = str1.length; i1 < ii1; i1++){\n                        const code1 = PDFStringTranslateTable1[str1.charCodeAt(i1)];\n                        strBuf1.push(code1 ? String.fromCharCode(code1) : str1.charAt(i1));\n                    }\n                    return strBuf1.join(\"\");\n                }\n                function stringToUTF8String1(str1) {\n                    return decodeURIComponent(escape(str1));\n                }\n                function utf8StringToString1(str1) {\n                    return unescape(encodeURIComponent(str1));\n                }\n                function isArrayBuffer1(v1) {\n                    return typeof v1 === \"object\" && v1?.byteLength !== undefined;\n                }\n                function isArrayEqual1(arr11, arr21) {\n                    if (arr11.length !== arr21.length) {\n                        return false;\n                    }\n                    for(let i1 = 0, ii1 = arr11.length; i1 < ii1; i1++){\n                        if (arr11[i1] !== arr21[i1]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function getModificationDate1(date1 = new Date()) {\n                    const buffer1 = [\n                        date1.getUTCFullYear().toString(),\n                        (date1.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n                        date1.getUTCDate().toString().padStart(2, \"0\"),\n                        date1.getUTCHours().toString().padStart(2, \"0\"),\n                        date1.getUTCMinutes().toString().padStart(2, \"0\"),\n                        date1.getUTCSeconds().toString().padStart(2, \"0\")\n                    ];\n                    return buffer1.join(\"\");\n                }\n                class PromiseCapability1 {\n                    #settled;\n                    constructor(){\n                        this.#settled = false;\n                        this.promise = new Promise((resolve1, reject1)=>{\n                            this.resolve = (data1)=>{\n                                this.#settled = true;\n                                resolve1(data1);\n                            };\n                            this.reject = (reason1)=>{\n                                this.#settled = true;\n                                reject1(reason1);\n                            };\n                        });\n                    }\n                    get settled() {\n                        return this.#settled;\n                    }\n                }\n                exports1.PromiseCapability = PromiseCapability1;\n                let NormalizeRegex1 = null;\n                let NormalizationMap1 = null;\n                function normalizeUnicode1(str1) {\n                    if (!NormalizeRegex1) {\n                        NormalizeRegex1 = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n                        NormalizationMap1 = new Map([\n                            [\n                                \"ﬅ\",\n                                \"ſt\"\n                            ]\n                        ]);\n                    }\n                    return str1.replaceAll(NormalizeRegex1, (_1, p12, p22)=>{\n                        return p12 ? p12.normalize(\"NFKC\") : NormalizationMap1.get(p22);\n                    });\n                }\n                function getUuid1() {\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n                        return crypto.randomUUID();\n                    }\n                    const buf1 = new Uint8Array(32);\n                    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n                        crypto.getRandomValues(buf1);\n                    } else {\n                        for(let i1 = 0; i1 < 32; i1++){\n                            buf1[i1] = Math.floor(Math.random() * 255);\n                        }\n                    }\n                    return bytesToString1(buf1);\n                }\n                const AnnotationPrefix1 = \"pdfjs_internal_id_\";\n                exports1.AnnotationPrefix = AnnotationPrefix1;\n            /***/ },\n            /* 2 */ /***/ (__unused_webpack_module, exports, __w_pdfjs_require__)=>{\n                Object.defineProperty(exports, \"__esModule\", {\n                    value: true\n                });\n                exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\n                Object.defineProperty(exports, \"SVGGraphics\", {\n                    enumerable: true,\n                    get: function() {\n                        return _displaySvg.SVGGraphics;\n                    }\n                });\n                exports.build = void 0;\n                exports.getDocument = getDocument;\n                exports.version = void 0;\n                var _util = __w_pdfjs_require__(1);\n                var _annotation_storage = __w_pdfjs_require__(3);\n                var _display_utils = __w_pdfjs_require__(6);\n                var _font_loader = __w_pdfjs_require__(9);\n                var _displayNode_utils = __w_pdfjs_require__(10);\n                var _canvas = __w_pdfjs_require__(11);\n                var _worker_options = __w_pdfjs_require__(14);\n                var _message_handler = __w_pdfjs_require__(15);\n                var _metadata = __w_pdfjs_require__(16);\n                var _optional_content_config = __w_pdfjs_require__(17);\n                var _transport_stream = __w_pdfjs_require__(18);\n                var _displayFetch_stream = __w_pdfjs_require__(19);\n                var _displayNetwork = __w_pdfjs_require__(22);\n                var _displayNode_stream = __w_pdfjs_require__(23);\n                var _displaySvg = __w_pdfjs_require__(24);\n                var _xfa_text = __w_pdfjs_require__(25);\n                const DEFAULT_RANGE_CHUNK_SIZE = 65536;\n                const RENDERING_CANCELLED_TIMEOUT = 100;\n                const DELAYED_CLEANUP_TIMEOUT = 5000;\n                const DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\n                exports.DefaultCanvasFactory = DefaultCanvasFactory;\n                const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\n                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\n                const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;\n                exports.DefaultFilterFactory = DefaultFilterFactory;\n                const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\n                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\n                function getDocument(src1) {\n                    if (typeof src1 === \"string\" || src1 instanceof URL) {\n                        src1 = {\n                            url: src1\n                        };\n                    } else if ((0, _util.isArrayBuffer)(src1)) {\n                        src1 = {\n                            data: src1\n                        };\n                    }\n                    if (typeof src1 !== \"object\") {\n                        throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n                    }\n                    if (!src1.url && !src1.data && !src1.range) {\n                        throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n                    }\n                    const task1 = new PDFDocumentLoadingTask();\n                    const { docId: docId1 } = task1;\n                    const url1 = src1.url ? getUrlProp(src1.url) : null;\n                    const data1 = src1.data ? getDataProp(src1.data) : null;\n                    const httpHeaders1 = src1.httpHeaders || null;\n                    const withCredentials1 = src1.withCredentials === true;\n                    const password1 = src1.password ?? null;\n                    const rangeTransport1 = src1.range instanceof PDFDataRangeTransport ? src1.range : null;\n                    const rangeChunkSize1 = Number.isInteger(src1.rangeChunkSize) && src1.rangeChunkSize > 0 ? src1.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n                    let worker1 = src1.worker instanceof PDFWorker ? src1.worker : null;\n                    const verbosity1 = src1.verbosity;\n                    const docBaseUrl1 = typeof src1.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src1.docBaseUrl) ? src1.docBaseUrl : null;\n                    const cMapUrl1 = typeof src1.cMapUrl === \"string\" ? src1.cMapUrl : null;\n                    const cMapPacked1 = src1.cMapPacked !== false;\n                    const CMapReaderFactory1 = src1.CMapReaderFactory || DefaultCMapReaderFactory;\n                    const standardFontDataUrl1 = typeof src1.standardFontDataUrl === \"string\" ? src1.standardFontDataUrl : null;\n                    const StandardFontDataFactory1 = src1.StandardFontDataFactory || DefaultStandardFontDataFactory;\n                    const ignoreErrors1 = src1.stopAtErrors !== true;\n                    const maxImageSize1 = Number.isInteger(src1.maxImageSize) && src1.maxImageSize > -1 ? src1.maxImageSize : -1;\n                    const isEvalSupported1 = src1.isEvalSupported !== false;\n                    const isOffscreenCanvasSupported1 = typeof src1.isOffscreenCanvasSupported === \"boolean\" ? src1.isOffscreenCanvasSupported : !_util.isNodeJS;\n                    const canvasMaxAreaInBytes1 = Number.isInteger(src1.canvasMaxAreaInBytes) ? src1.canvasMaxAreaInBytes : -1;\n                    const disableFontFace1 = typeof src1.disableFontFace === \"boolean\" ? src1.disableFontFace : _util.isNodeJS;\n                    const fontExtraProperties1 = src1.fontExtraProperties === true;\n                    const enableXfa1 = src1.enableXfa === true;\n                    const ownerDocument1 = src1.ownerDocument || globalThis.document;\n                    const disableRange1 = src1.disableRange === true;\n                    const disableStream1 = src1.disableStream === true;\n                    const disableAutoFetch1 = src1.disableAutoFetch === true;\n                    const pdfBug1 = src1.pdfBug === true;\n                    const length1 = rangeTransport1 ? rangeTransport1.length : src1.length ?? NaN;\n                    const useSystemFonts1 = typeof src1.useSystemFonts === \"boolean\" ? src1.useSystemFonts : !_util.isNodeJS && !disableFontFace1;\n                    const useWorkerFetch1 = typeof src1.useWorkerFetch === \"boolean\" ? src1.useWorkerFetch : CMapReaderFactory1 === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory1 === _display_utils.DOMStandardFontDataFactory && cMapUrl1 && standardFontDataUrl1 && (0, _display_utils.isValidFetchUrl)(cMapUrl1, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl1, document.baseURI);\n                    const canvasFactory1 = src1.canvasFactory || new DefaultCanvasFactory({\n                        ownerDocument: ownerDocument1\n                    });\n                    const filterFactory1 = src1.filterFactory || new DefaultFilterFactory({\n                        docId: docId1,\n                        ownerDocument: ownerDocument1\n                    });\n                    const styleElement1 = null;\n                    (0, _util.setVerbosityLevel)(verbosity1);\n                    const transportFactory1 = {\n                        canvasFactory: canvasFactory1,\n                        filterFactory: filterFactory1\n                    };\n                    if (!useWorkerFetch1) {\n                        transportFactory1.cMapReaderFactory = new CMapReaderFactory1({\n                            baseUrl: cMapUrl1,\n                            isCompressed: cMapPacked1\n                        });\n                        transportFactory1.standardFontDataFactory = new StandardFontDataFactory1({\n                            baseUrl: standardFontDataUrl1\n                        });\n                    }\n                    if (!worker1) {\n                        const workerParams1 = {\n                            verbosity: verbosity1,\n                            port: _worker_options.GlobalWorkerOptions.workerPort\n                        };\n                        worker1 = workerParams1.port ? PDFWorker.fromPort(workerParams1) : new PDFWorker(workerParams1);\n                        task1._worker = worker1;\n                    }\n                    const fetchDocParams1 = {\n                        docId: docId1,\n                        apiVersion: \"3.11.174\",\n                        data: data1,\n                        password: password1,\n                        disableAutoFetch: disableAutoFetch1,\n                        rangeChunkSize: rangeChunkSize1,\n                        length: length1,\n                        docBaseUrl: docBaseUrl1,\n                        enableXfa: enableXfa1,\n                        evaluatorOptions: {\n                            maxImageSize: maxImageSize1,\n                            disableFontFace: disableFontFace1,\n                            ignoreErrors: ignoreErrors1,\n                            isEvalSupported: isEvalSupported1,\n                            isOffscreenCanvasSupported: isOffscreenCanvasSupported1,\n                            canvasMaxAreaInBytes: canvasMaxAreaInBytes1,\n                            fontExtraProperties: fontExtraProperties1,\n                            useSystemFonts: useSystemFonts1,\n                            cMapUrl: useWorkerFetch1 ? cMapUrl1 : null,\n                            standardFontDataUrl: useWorkerFetch1 ? standardFontDataUrl1 : null\n                        }\n                    };\n                    const transportParams1 = {\n                        ignoreErrors: ignoreErrors1,\n                        isEvalSupported: isEvalSupported1,\n                        disableFontFace: disableFontFace1,\n                        fontExtraProperties: fontExtraProperties1,\n                        enableXfa: enableXfa1,\n                        ownerDocument: ownerDocument1,\n                        disableAutoFetch: disableAutoFetch1,\n                        pdfBug: pdfBug1,\n                        styleElement: styleElement1\n                    };\n                    worker1.promise.then(function() {\n                        if (task1.destroyed) {\n                            throw new Error(\"Loading aborted\");\n                        }\n                        const workerIdPromise1 = _fetchDocument(worker1, fetchDocParams1);\n                        const networkStreamPromise1 = new Promise(function(resolve1) {\n                            let networkStream1;\n                            if (rangeTransport1) {\n                                networkStream1 = new _transport_stream.PDFDataTransportStream({\n                                    length: length1,\n                                    initialData: rangeTransport1.initialData,\n                                    progressiveDone: rangeTransport1.progressiveDone,\n                                    contentDispositionFilename: rangeTransport1.contentDispositionFilename,\n                                    disableRange: disableRange1,\n                                    disableStream: disableStream1\n                                }, rangeTransport1);\n                            } else if (!data1) {\n                                const createPDFNetworkStream1 = (params1)=>{\n                                    if (_util.isNodeJS) {\n                                        return new _displayNode_stream.PDFNodeStream(params1);\n                                    }\n                                    return (0, _display_utils.isValidFetchUrl)(params1.url) ? new _displayFetch_stream.PDFFetchStream(params1) : new _displayNetwork.PDFNetworkStream(params1);\n                                };\n                                networkStream1 = createPDFNetworkStream1({\n                                    url: url1,\n                                    length: length1,\n                                    httpHeaders: httpHeaders1,\n                                    withCredentials: withCredentials1,\n                                    rangeChunkSize: rangeChunkSize1,\n                                    disableRange: disableRange1,\n                                    disableStream: disableStream1\n                                });\n                            }\n                            resolve1(networkStream1);\n                        });\n                        return Promise.all([\n                            workerIdPromise1,\n                            networkStreamPromise1\n                        ]).then(function([workerId1, networkStream1]) {\n                            if (task1.destroyed) {\n                                throw new Error(\"Loading aborted\");\n                            }\n                            const messageHandler1 = new _message_handler.MessageHandler(docId1, workerId1, worker1.port);\n                            const transport1 = new WorkerTransport(messageHandler1, task1, networkStream1, transportParams1, transportFactory1);\n                            task1._transport = transport1;\n                            messageHandler1.send(\"Ready\", null);\n                        });\n                    }).catch(task1._capability.reject);\n                    return task1;\n                }\n                async function _fetchDocument(worker1, source1) {\n                    if (worker1.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    const workerId1 = await worker1.messageHandler.sendWithPromise(\"GetDocRequest\", source1, source1.data ? [\n                        source1.data.buffer\n                    ] : null);\n                    if (worker1.destroyed) {\n                        throw new Error(\"Worker was destroyed\");\n                    }\n                    return workerId1;\n                }\n                function getUrlProp(val1) {\n                    if (val1 instanceof URL) {\n                        return val1.href;\n                    }\n                    try {\n                        return new URL(val1, window.location).href;\n                    } catch  {\n                        if (_util.isNodeJS && typeof val1 === \"string\") {\n                            return val1;\n                        }\n                    }\n                    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n                }\n                function getDataProp(val1) {\n                    if (_util.isNodeJS && typeof Buffer !== \"undefined\" && val1 instanceof Buffer) {\n                        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n                    }\n                    if (val1 instanceof Uint8Array && val1.byteLength === val1.buffer.byteLength) {\n                        return val1;\n                    }\n                    if (typeof val1 === \"string\") {\n                        return (0, _util.stringToBytes)(val1);\n                    }\n                    if (typeof val1 === \"object\" && !isNaN(val1?.length) || (0, _util.isArrayBuffer)(val1)) {\n                        return new Uint8Array(val1);\n                    }\n                    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n                }\n                class PDFDocumentLoadingTask {\n                    static #docId = 0;\n                    constructor(){\n                        this._capability = new _util.PromiseCapability();\n                        this._transport = null;\n                        this._worker = null;\n                        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n                        this.destroyed = false;\n                        this.onPassword = null;\n                        this.onProgress = null;\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    async destroy() {\n                        this.destroyed = true;\n                        try {\n                            if (this._worker?.port) {\n                                this._worker._pendingDestroy = true;\n                            }\n                            await this._transport?.destroy();\n                        } catch (ex1) {\n                            if (this._worker?.port) {\n                                delete this._worker._pendingDestroy;\n                            }\n                            throw ex1;\n                        }\n                        this._transport = null;\n                        if (this._worker) {\n                            this._worker.destroy();\n                            this._worker = null;\n                        }\n                    }\n                }\n                exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\n                class PDFDataRangeTransport {\n                    constructor(length1, initialData1, progressiveDone1 = false, contentDispositionFilename1 = null){\n                        this.length = length1;\n                        this.initialData = initialData1;\n                        this.progressiveDone = progressiveDone1;\n                        this.contentDispositionFilename = contentDispositionFilename1;\n                        this._rangeListeners = [];\n                        this._progressListeners = [];\n                        this._progressiveReadListeners = [];\n                        this._progressiveDoneListeners = [];\n                        this._readyCapability = new _util.PromiseCapability();\n                    }\n                    addRangeListener(listener1) {\n                        this._rangeListeners.push(listener1);\n                    }\n                    addProgressListener(listener1) {\n                        this._progressListeners.push(listener1);\n                    }\n                    addProgressiveReadListener(listener1) {\n                        this._progressiveReadListeners.push(listener1);\n                    }\n                    addProgressiveDoneListener(listener1) {\n                        this._progressiveDoneListeners.push(listener1);\n                    }\n                    onDataRange(begin1, chunk3) {\n                        for (const listener1 of this._rangeListeners){\n                            listener1(begin1, chunk3);\n                        }\n                    }\n                    onDataProgress(loaded1, total1) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener1 of this._progressListeners){\n                                listener1(loaded1, total1);\n                            }\n                        });\n                    }\n                    onDataProgressiveRead(chunk3) {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener1 of this._progressiveReadListeners){\n                                listener1(chunk3);\n                            }\n                        });\n                    }\n                    onDataProgressiveDone() {\n                        this._readyCapability.promise.then(()=>{\n                            for (const listener1 of this._progressiveDoneListeners){\n                                listener1();\n                            }\n                        });\n                    }\n                    transportReady() {\n                        this._readyCapability.resolve();\n                    }\n                    requestDataRange(begin1, end1) {\n                        (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n                    }\n                    abort() {}\n                }\n                exports.PDFDataRangeTransport = PDFDataRangeTransport;\n                class PDFDocumentProxy {\n                    constructor(pdfInfo1, transport1){\n                        this._pdfInfo = pdfInfo1;\n                        this._transport = transport1;\n                        Object.defineProperty(this, \"getJavaScript\", {\n                            value: ()=>{\n                                (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getJavaScript`, \" + \"please use `PDFDocumentProxy.getJSActions` instead.\");\n                                return this.getJSActions().then((js1)=>{\n                                    if (!js1) {\n                                        return js1;\n                                    }\n                                    const jsArr1 = [];\n                                    for(const name1 in js1){\n                                        jsArr1.push(...js1[name1]);\n                                    }\n                                    return jsArr1;\n                                });\n                            }\n                        });\n                    }\n                    get annotationStorage() {\n                        return this._transport.annotationStorage;\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get numPages() {\n                        return this._pdfInfo.numPages;\n                    }\n                    get fingerprints() {\n                        return this._pdfInfo.fingerprints;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    get allXfaHtml() {\n                        return this._transport._htmlForXfa;\n                    }\n                    getPage(pageNumber1) {\n                        return this._transport.getPage(pageNumber1);\n                    }\n                    getPageIndex(ref1) {\n                        return this._transport.getPageIndex(ref1);\n                    }\n                    getDestinations() {\n                        return this._transport.getDestinations();\n                    }\n                    getDestination(id1) {\n                        return this._transport.getDestination(id1);\n                    }\n                    getPageLabels() {\n                        return this._transport.getPageLabels();\n                    }\n                    getPageLayout() {\n                        return this._transport.getPageLayout();\n                    }\n                    getPageMode() {\n                        return this._transport.getPageMode();\n                    }\n                    getViewerPreferences() {\n                        return this._transport.getViewerPreferences();\n                    }\n                    getOpenAction() {\n                        return this._transport.getOpenAction();\n                    }\n                    getAttachments() {\n                        return this._transport.getAttachments();\n                    }\n                    getJSActions() {\n                        return this._transport.getDocJSActions();\n                    }\n                    getOutline() {\n                        return this._transport.getOutline();\n                    }\n                    getOptionalContentConfig() {\n                        return this._transport.getOptionalContentConfig();\n                    }\n                    getPermissions() {\n                        return this._transport.getPermissions();\n                    }\n                    getMetadata() {\n                        return this._transport.getMetadata();\n                    }\n                    getMarkInfo() {\n                        return this._transport.getMarkInfo();\n                    }\n                    getData() {\n                        return this._transport.getData();\n                    }\n                    saveDocument() {\n                        return this._transport.saveDocument();\n                    }\n                    getDownloadInfo() {\n                        return this._transport.downloadInfoCapability.promise;\n                    }\n                    cleanup(keepLoadedFonts1 = false) {\n                        return this._transport.startCleanup(keepLoadedFonts1 || this.isPureXfa);\n                    }\n                    destroy() {\n                        return this.loadingTask.destroy();\n                    }\n                    get loadingParams() {\n                        return this._transport.loadingParams;\n                    }\n                    get loadingTask() {\n                        return this._transport.loadingTask;\n                    }\n                    getFieldObjects() {\n                        return this._transport.getFieldObjects();\n                    }\n                    hasJSActions() {\n                        return this._transport.hasJSActions();\n                    }\n                    getCalculationOrderIds() {\n                        return this._transport.getCalculationOrderIds();\n                    }\n                }\n                exports.PDFDocumentProxy = PDFDocumentProxy;\n                class PDFPageProxy {\n                    #delayedCleanupTimeout;\n                    #pendingCleanup;\n                    constructor(pageIndex1, pageInfo1, transport1, pdfBug1 = false){\n                        this.#delayedCleanupTimeout = null;\n                        this.#pendingCleanup = false;\n                        this._pageIndex = pageIndex1;\n                        this._pageInfo = pageInfo1;\n                        this._transport = transport1;\n                        this._stats = pdfBug1 ? new _display_utils.StatTimer() : null;\n                        this._pdfBug = pdfBug1;\n                        this.commonObjs = transport1.commonObjs;\n                        this.objs = new PDFObjects();\n                        this._maybeCleanupAfterRender = false;\n                        this._intentStates = new Map();\n                        this.destroyed = false;\n                    }\n                    get pageNumber() {\n                        return this._pageIndex + 1;\n                    }\n                    get rotate() {\n                        return this._pageInfo.rotate;\n                    }\n                    get ref() {\n                        return this._pageInfo.ref;\n                    }\n                    get userUnit() {\n                        return this._pageInfo.userUnit;\n                    }\n                    get view() {\n                        return this._pageInfo.view;\n                    }\n                    getViewport({ scale: scale1, rotation: rotation1 = this.rotate, offsetX: offsetX1 = 0, offsetY: offsetY1 = 0, dontFlip: dontFlip1 = false } = {}) {\n                        return new _display_utils.PageViewport({\n                            viewBox: this.view,\n                            scale: scale1,\n                            rotation: rotation1,\n                            offsetX: offsetX1,\n                            offsetY: offsetY1,\n                            dontFlip: dontFlip1\n                        });\n                    }\n                    getAnnotations({ intent: intent1 = \"display\" } = {}) {\n                        const intentArgs1 = this._transport.getRenderingIntent(intent1);\n                        return this._transport.getAnnotations(this._pageIndex, intentArgs1.renderingIntent);\n                    }\n                    getJSActions() {\n                        return this._transport.getPageJSActions(this._pageIndex);\n                    }\n                    get filterFactory() {\n                        return this._transport.filterFactory;\n                    }\n                    get isPureXfa() {\n                        return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n                    }\n                    async getXfa() {\n                        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n                    }\n                    render({ canvasContext: canvasContext1, viewport: viewport1, intent: intent1 = \"display\", annotationMode: annotationMode1 = _util.AnnotationMode.ENABLE, transform: transform1 = null, background: background1 = null, optionalContentConfigPromise: optionalContentConfigPromise1 = null, annotationCanvasMap: annotationCanvasMap1 = null, pageColors: pageColors1 = null, printAnnotationStorage: printAnnotationStorage1 = null }) {\n                        this._stats?.time(\"Overall\");\n                        const intentArgs1 = this._transport.getRenderingIntent(intent1, annotationMode1, printAnnotationStorage1);\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        if (!optionalContentConfigPromise1) {\n                            optionalContentConfigPromise1 = this._transport.getOptionalContentConfig();\n                        }\n                        let intentState1 = this._intentStates.get(intentArgs1.cacheKey);\n                        if (!intentState1) {\n                            intentState1 = Object.create(null);\n                            this._intentStates.set(intentArgs1.cacheKey, intentState1);\n                        }\n                        if (intentState1.streamReaderCancelTimeout) {\n                            clearTimeout(intentState1.streamReaderCancelTimeout);\n                            intentState1.streamReaderCancelTimeout = null;\n                        }\n                        const intentPrint1 = !!(intentArgs1.renderingIntent & _util.RenderingIntentFlag.PRINT);\n                        if (!intentState1.displayReadyCapability) {\n                            intentState1.displayReadyCapability = new _util.PromiseCapability();\n                            intentState1.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs1);\n                        }\n                        const complete1 = (error1)=>{\n                            intentState1.renderTasks.delete(internalRenderTask1);\n                            if (this._maybeCleanupAfterRender || intentPrint1) {\n                                this.#pendingCleanup = true;\n                            }\n                            this.#tryCleanup(!intentPrint1);\n                            if (error1) {\n                                internalRenderTask1.capability.reject(error1);\n                                this._abortOperatorList({\n                                    intentState: intentState1,\n                                    reason: error1 instanceof Error ? error1 : new Error(error1)\n                                });\n                            } else {\n                                internalRenderTask1.capability.resolve();\n                            }\n                            this._stats?.timeEnd(\"Rendering\");\n                            this._stats?.timeEnd(\"Overall\");\n                        };\n                        const internalRenderTask1 = new InternalRenderTask({\n                            callback: complete1,\n                            params: {\n                                canvasContext: canvasContext1,\n                                viewport: viewport1,\n                                transform: transform1,\n                                background: background1\n                            },\n                            objs: this.objs,\n                            commonObjs: this.commonObjs,\n                            annotationCanvasMap: annotationCanvasMap1,\n                            operatorList: intentState1.operatorList,\n                            pageIndex: this._pageIndex,\n                            canvasFactory: this._transport.canvasFactory,\n                            filterFactory: this._transport.filterFactory,\n                            useRequestAnimationFrame: !intentPrint1,\n                            pdfBug: this._pdfBug,\n                            pageColors: pageColors1\n                        });\n                        (intentState1.renderTasks ||= new Set()).add(internalRenderTask1);\n                        const renderTask1 = internalRenderTask1.task;\n                        Promise.all([\n                            intentState1.displayReadyCapability.promise,\n                            optionalContentConfigPromise1\n                        ]).then(([transparency1, optionalContentConfig1])=>{\n                            if (this.destroyed) {\n                                complete1();\n                                return;\n                            }\n                            this._stats?.time(\"Rendering\");\n                            internalRenderTask1.initializeGraphics({\n                                transparency: transparency1,\n                                optionalContentConfig: optionalContentConfig1\n                            });\n                            internalRenderTask1.operatorListChanged();\n                        }).catch(complete1);\n                        return renderTask1;\n                    }\n                    getOperatorList({ intent: intent1 = \"display\", annotationMode: annotationMode1 = _util.AnnotationMode.ENABLE, printAnnotationStorage: printAnnotationStorage1 = null } = {}) {\n                        function operatorListChanged1() {\n                            if (intentState1.operatorList.lastChunk) {\n                                intentState1.opListReadCapability.resolve(intentState1.operatorList);\n                                intentState1.renderTasks.delete(opListTask1);\n                            }\n                        }\n                        const intentArgs1 = this._transport.getRenderingIntent(intent1, annotationMode1, printAnnotationStorage1, true);\n                        let intentState1 = this._intentStates.get(intentArgs1.cacheKey);\n                        if (!intentState1) {\n                            intentState1 = Object.create(null);\n                            this._intentStates.set(intentArgs1.cacheKey, intentState1);\n                        }\n                        let opListTask1;\n                        if (!intentState1.opListReadCapability) {\n                            opListTask1 = Object.create(null);\n                            opListTask1.operatorListChanged = operatorListChanged1;\n                            intentState1.opListReadCapability = new _util.PromiseCapability();\n                            (intentState1.renderTasks ||= new Set()).add(opListTask1);\n                            intentState1.operatorList = {\n                                fnArray: [],\n                                argsArray: [],\n                                lastChunk: false,\n                                separateAnnots: null\n                            };\n                            this._stats?.time(\"Page Request\");\n                            this._pumpOperatorList(intentArgs1);\n                        }\n                        return intentState1.opListReadCapability.promise;\n                    }\n                    streamTextContent({ includeMarkedContent: includeMarkedContent1 = false, disableNormalization: disableNormalization1 = false } = {}) {\n                        const TEXT_CONTENT_CHUNK_SIZE1 = 100;\n                        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n                            pageIndex: this._pageIndex,\n                            includeMarkedContent: includeMarkedContent1 === true,\n                            disableNormalization: disableNormalization1 === true\n                        }, {\n                            highWaterMark: TEXT_CONTENT_CHUNK_SIZE1,\n                            size (textContent1) {\n                                return textContent1.items.length;\n                            }\n                        });\n                    }\n                    getTextContent(params1 = {}) {\n                        if (this._transport._htmlForXfa) {\n                            return this.getXfa().then((xfa1)=>{\n                                return _xfa_text.XfaText.textContent(xfa1);\n                            });\n                        }\n                        const readableStream1 = this.streamTextContent(params1);\n                        return new Promise(function(resolve1, reject1) {\n                            function pump1() {\n                                reader1.read().then(function({ value: value1, done: done1 }) {\n                                    if (done1) {\n                                        resolve1(textContent1);\n                                        return;\n                                    }\n                                    Object.assign(textContent1.styles, value1.styles);\n                                    textContent1.items.push(...value1.items);\n                                    pump1();\n                                }, reject1);\n                            }\n                            const reader1 = readableStream1.getReader();\n                            const textContent1 = {\n                                items: [],\n                                styles: Object.create(null)\n                            };\n                            pump1();\n                        });\n                    }\n                    getStructTree() {\n                        return this._transport.getStructTree(this._pageIndex);\n                    }\n                    _destroy() {\n                        this.destroyed = true;\n                        const waitOn1 = [];\n                        for (const intentState1 of this._intentStates.values()){\n                            this._abortOperatorList({\n                                intentState: intentState1,\n                                reason: new Error(\"Page was destroyed.\"),\n                                force: true\n                            });\n                            if (intentState1.opListReadCapability) {\n                                continue;\n                            }\n                            for (const internalRenderTask1 of intentState1.renderTasks){\n                                waitOn1.push(internalRenderTask1.completed);\n                                internalRenderTask1.cancel();\n                            }\n                        }\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        this.#abortDelayedCleanup();\n                        return Promise.all(waitOn1);\n                    }\n                    cleanup(resetStats1 = false) {\n                        this.#pendingCleanup = true;\n                        const success1 = this.#tryCleanup(false);\n                        if (resetStats1 && success1) {\n                            this._stats &&= new _display_utils.StatTimer();\n                        }\n                        return success1;\n                    }\n                    #tryCleanup(delayed1 = false) {\n                        this.#abortDelayedCleanup();\n                        if (!this.#pendingCleanup || this.destroyed) {\n                            return false;\n                        }\n                        if (delayed1) {\n                            this.#delayedCleanupTimeout = setTimeout(()=>{\n                                this.#delayedCleanupTimeout = null;\n                                this.#tryCleanup(false);\n                            }, DELAYED_CLEANUP_TIMEOUT);\n                            return false;\n                        }\n                        for (const { renderTasks: renderTasks1, operatorList: operatorList1 } of this._intentStates.values()){\n                            if (renderTasks1.size > 0 || !operatorList1.lastChunk) {\n                                return false;\n                            }\n                        }\n                        this._intentStates.clear();\n                        this.objs.clear();\n                        this.#pendingCleanup = false;\n                        return true;\n                    }\n                    #abortDelayedCleanup() {\n                        if (this.#delayedCleanupTimeout) {\n                            clearTimeout(this.#delayedCleanupTimeout);\n                            this.#delayedCleanupTimeout = null;\n                        }\n                    }\n                    _startRenderPage(transparency1, cacheKey1) {\n                        const intentState1 = this._intentStates.get(cacheKey1);\n                        if (!intentState1) {\n                            return;\n                        }\n                        this._stats?.timeEnd(\"Page Request\");\n                        intentState1.displayReadyCapability?.resolve(transparency1);\n                    }\n                    _renderPageChunk(operatorListChunk1, intentState1) {\n                        for(let i1 = 0, ii1 = operatorListChunk1.length; i1 < ii1; i1++){\n                            intentState1.operatorList.fnArray.push(operatorListChunk1.fnArray[i1]);\n                            intentState1.operatorList.argsArray.push(operatorListChunk1.argsArray[i1]);\n                        }\n                        intentState1.operatorList.lastChunk = operatorListChunk1.lastChunk;\n                        intentState1.operatorList.separateAnnots = operatorListChunk1.separateAnnots;\n                        for (const internalRenderTask1 of intentState1.renderTasks){\n                            internalRenderTask1.operatorListChanged();\n                        }\n                        if (operatorListChunk1.lastChunk) {\n                            this.#tryCleanup(true);\n                        }\n                    }\n                    _pumpOperatorList({ renderingIntent: renderingIntent1, cacheKey: cacheKey1, annotationStorageSerializable: annotationStorageSerializable1 }) {\n                        const { map: map1, transfers: transfers1 } = annotationStorageSerializable1;\n                        const readableStream1 = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n                            pageIndex: this._pageIndex,\n                            intent: renderingIntent1,\n                            cacheKey: cacheKey1,\n                            annotationStorage: map1\n                        }, transfers1);\n                        const reader1 = readableStream1.getReader();\n                        const intentState1 = this._intentStates.get(cacheKey1);\n                        intentState1.streamReader = reader1;\n                        const pump1 = ()=>{\n                            reader1.read().then(({ value: value1, done: done1 })=>{\n                                if (done1) {\n                                    intentState1.streamReader = null;\n                                    return;\n                                }\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                this._renderPageChunk(value1, intentState1);\n                                pump1();\n                            }, (reason1)=>{\n                                intentState1.streamReader = null;\n                                if (this._transport.destroyed) {\n                                    return;\n                                }\n                                if (intentState1.operatorList) {\n                                    intentState1.operatorList.lastChunk = true;\n                                    for (const internalRenderTask1 of intentState1.renderTasks){\n                                        internalRenderTask1.operatorListChanged();\n                                    }\n                                    this.#tryCleanup(true);\n                                }\n                                if (intentState1.displayReadyCapability) {\n                                    intentState1.displayReadyCapability.reject(reason1);\n                                } else if (intentState1.opListReadCapability) {\n                                    intentState1.opListReadCapability.reject(reason1);\n                                } else {\n                                    throw reason1;\n                                }\n                            });\n                        };\n                        pump1();\n                    }\n                    _abortOperatorList({ intentState: intentState1, reason: reason1, force: force1 = false }) {\n                        if (!intentState1.streamReader) {\n                            return;\n                        }\n                        if (intentState1.streamReaderCancelTimeout) {\n                            clearTimeout(intentState1.streamReaderCancelTimeout);\n                            intentState1.streamReaderCancelTimeout = null;\n                        }\n                        if (!force1) {\n                            if (intentState1.renderTasks.size > 0) {\n                                return;\n                            }\n                            if (reason1 instanceof _display_utils.RenderingCancelledException) {\n                                let delay1 = RENDERING_CANCELLED_TIMEOUT;\n                                if (reason1.extraDelay > 0 && reason1.extraDelay < 1000) {\n                                    delay1 += reason1.extraDelay;\n                                }\n                                intentState1.streamReaderCancelTimeout = setTimeout(()=>{\n                                    intentState1.streamReaderCancelTimeout = null;\n                                    this._abortOperatorList({\n                                        intentState: intentState1,\n                                        reason: reason1,\n                                        force: true\n                                    });\n                                }, delay1);\n                                return;\n                            }\n                        }\n                        intentState1.streamReader.cancel(new _util.AbortException(reason1.message)).catch(()=>{});\n                        intentState1.streamReader = null;\n                        if (this._transport.destroyed) {\n                            return;\n                        }\n                        for (const [curCacheKey1, curIntentState1] of this._intentStates){\n                            if (curIntentState1 === intentState1) {\n                                this._intentStates.delete(curCacheKey1);\n                                break;\n                            }\n                        }\n                        this.cleanup();\n                    }\n                    get stats() {\n                        return this._stats;\n                    }\n                }\n                exports.PDFPageProxy = PDFPageProxy;\n                class LoopbackPort {\n                    #listeners;\n                    #deferred;\n                    postMessage(obj1, transfer1) {\n                        const event1 = {\n                            data: structuredClone(obj1, transfer1 ? {\n                                transfer: transfer1\n                            } : null)\n                        };\n                        this.#deferred.then(()=>{\n                            for (const listener1 of this.#listeners){\n                                listener1.call(this, event1);\n                            }\n                        });\n                    }\n                    addEventListener(name1, listener1) {\n                        this.#listeners.add(listener1);\n                    }\n                    removeEventListener(name1, listener1) {\n                        this.#listeners.delete(listener1);\n                    }\n                    terminate() {\n                        this.#listeners.clear();\n                    }\n                    constructor(){\n                        this.#listeners = new Set();\n                        this.#deferred = Promise.resolve();\n                    }\n                }\n                exports.LoopbackPort = LoopbackPort;\n                const PDFWorkerUtil = {\n                    isWorkerDisabled: false,\n                    fallbackWorkerSrc: null,\n                    fakeWorkerId: 0\n                };\n                exports.PDFWorkerUtil = PDFWorkerUtil;\n                {\n                    if (_util.isNodeJS && \"function\" === \"function\") {\n                        PDFWorkerUtil.isWorkerDisabled = true;\n                        PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n                    } else if (typeof document === \"object\") {\n                        const pdfjsFilePath = document?.currentScript?.src;\n                        if (pdfjsFilePath) {\n                            PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n                        }\n                    }\n                    PDFWorkerUtil.isSameOrigin = function(baseUrl1, otherUrl1) {\n                        let base1;\n                        try {\n                            base1 = new URL(baseUrl1);\n                            if (!base1.origin || base1.origin === \"null\") {\n                                return false;\n                            }\n                        } catch  {\n                            return false;\n                        }\n                        const other1 = new URL(otherUrl1, base1);\n                        return base1.origin === other1.origin;\n                    };\n                    PDFWorkerUtil.createCDNWrapper = function(url1) {\n                        const wrapper1 = `importScripts(\"${url1}\");`;\n                        return URL.createObjectURL(new Blob([\n                            wrapper1\n                        ]));\n                    };\n                }\n                class PDFWorker {\n                    static #workerPorts;\n                    constructor({ name: name1 = null, port: port1 = null, verbosity: verbosity1 = (0, _util.getVerbosityLevel)() } = {}){\n                        this.name = name1;\n                        this.destroyed = false;\n                        this.verbosity = verbosity1;\n                        this._readyCapability = new _util.PromiseCapability();\n                        this._port = null;\n                        this._webWorker = null;\n                        this._messageHandler = null;\n                        if (port1) {\n                            if (PDFWorker.#workerPorts?.has(port1)) {\n                                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n                            }\n                            (PDFWorker.#workerPorts ||= new WeakMap()).set(port1, this);\n                            this._initializeFromPort(port1);\n                            return;\n                        }\n                        this._initialize();\n                    }\n                    get promise() {\n                        return this._readyCapability.promise;\n                    }\n                    get port() {\n                        return this._port;\n                    }\n                    get messageHandler() {\n                        return this._messageHandler;\n                    }\n                    _initializeFromPort(port1) {\n                        this._port = port1;\n                        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port1);\n                        this._messageHandler.on(\"ready\", function() {});\n                        this._readyCapability.resolve();\n                        this._messageHandler.send(\"configure\", {\n                            verbosity: this.verbosity\n                        });\n                    }\n                    _initialize() {\n                        if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n                            let { workerSrc: workerSrc1 } = PDFWorker;\n                            try {\n                                if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc1)) {\n                                    workerSrc1 = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc1, window.location).href);\n                                }\n                                const worker1 = new Worker(workerSrc1);\n                                const messageHandler1 = new _message_handler.MessageHandler(\"main\", \"worker\", worker1);\n                                const terminateEarly1 = ()=>{\n                                    worker1.removeEventListener(\"error\", onWorkerError1);\n                                    messageHandler1.destroy();\n                                    worker1.terminate();\n                                    if (this.destroyed) {\n                                        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                    } else {\n                                        this._setupFakeWorker();\n                                    }\n                                };\n                                const onWorkerError1 = ()=>{\n                                    if (!this._webWorker) {\n                                        terminateEarly1();\n                                    }\n                                };\n                                worker1.addEventListener(\"error\", onWorkerError1);\n                                messageHandler1.on(\"test\", (data1)=>{\n                                    worker1.removeEventListener(\"error\", onWorkerError1);\n                                    if (this.destroyed) {\n                                        terminateEarly1();\n                                        return;\n                                    }\n                                    if (data1) {\n                                        this._messageHandler = messageHandler1;\n                                        this._port = worker1;\n                                        this._webWorker = worker1;\n                                        this._readyCapability.resolve();\n                                        messageHandler1.send(\"configure\", {\n                                            verbosity: this.verbosity\n                                        });\n                                    } else {\n                                        this._setupFakeWorker();\n                                        messageHandler1.destroy();\n                                        worker1.terminate();\n                                    }\n                                });\n                                messageHandler1.on(\"ready\", (data1)=>{\n                                    worker1.removeEventListener(\"error\", onWorkerError1);\n                                    if (this.destroyed) {\n                                        terminateEarly1();\n                                        return;\n                                    }\n                                    try {\n                                        sendTest1();\n                                    } catch  {\n                                        this._setupFakeWorker();\n                                    }\n                                });\n                                const sendTest1 = ()=>{\n                                    const testObj1 = new Uint8Array();\n                                    messageHandler1.send(\"test\", testObj1, [\n                                        testObj1.buffer\n                                    ]);\n                                };\n                                sendTest1();\n                                return;\n                            } catch  {\n                                (0, _util.info)(\"The worker has been disabled.\");\n                            }\n                        }\n                        this._setupFakeWorker();\n                    }\n                    _setupFakeWorker() {\n                        if (!PDFWorkerUtil.isWorkerDisabled) {\n                            (0, _util.warn)(\"Setting up fake worker.\");\n                            PDFWorkerUtil.isWorkerDisabled = true;\n                        }\n                        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler1)=>{\n                            if (this.destroyed) {\n                                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                                return;\n                            }\n                            const port1 = new LoopbackPort();\n                            this._port = port1;\n                            const id1 = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n                            const workerHandler1 = new _message_handler.MessageHandler(id1 + \"_worker\", id1, port1);\n                            WorkerMessageHandler1.setup(workerHandler1, port1);\n                            const messageHandler1 = new _message_handler.MessageHandler(id1, id1 + \"_worker\", port1);\n                            this._messageHandler = messageHandler1;\n                            this._readyCapability.resolve();\n                            messageHandler1.send(\"configure\", {\n                                verbosity: this.verbosity\n                            });\n                        }).catch((reason1)=>{\n                            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason1.message}\".`));\n                        });\n                    }\n                    destroy() {\n                        this.destroyed = true;\n                        if (this._webWorker) {\n                            this._webWorker.terminate();\n                            this._webWorker = null;\n                        }\n                        PDFWorker.#workerPorts?.delete(this._port);\n                        this._port = null;\n                        if (this._messageHandler) {\n                            this._messageHandler.destroy();\n                            this._messageHandler = null;\n                        }\n                    }\n                    static fromPort(params1) {\n                        if (!params1?.port) {\n                            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n                        }\n                        const cachedPort1 = this.#workerPorts?.get(params1.port);\n                        if (cachedPort1) {\n                            if (cachedPort1._pendingDestroy) {\n                                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n                            }\n                            return cachedPort1;\n                        }\n                        return new PDFWorker(params1);\n                    }\n                    static get workerSrc() {\n                        if (_worker_options.GlobalWorkerOptions.workerSrc) {\n                            return _worker_options.GlobalWorkerOptions.workerSrc;\n                        }\n                        if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n                            if (!_util.isNodeJS) {\n                                (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                            }\n                            return PDFWorkerUtil.fallbackWorkerSrc;\n                        }\n                        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n                    }\n                    static get _mainThreadWorkerMessageHandler() {\n                        try {\n                            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n                        } catch  {\n                            return null;\n                        }\n                    }\n                    static get _setupFakeWorkerGlobal() {\n                        const loader = async ()=>{\n                            const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n                            if (mainWorkerMessageHandler) {\n                                return mainWorkerMessageHandler;\n                            }\n                            if (_util.isNodeJS && \"function\" === \"function\") {\n                                const worker = eval(\"require\")(this.workerSrc);\n                                return worker.WorkerMessageHandler;\n                            }\n                            await (0, _display_utils.loadScript)(this.workerSrc);\n                            return window.pdfjsWorker.WorkerMessageHandler;\n                        };\n                        return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n                    }\n                }\n                exports.PDFWorker = PDFWorker;\n                class WorkerTransport {\n                    #methodPromises;\n                    #pageCache;\n                    #pagePromises;\n                    #passwordCapability;\n                    constructor(messageHandler1, loadingTask1, networkStream1, params1, factory1){\n                        this.#methodPromises = new Map();\n                        this.#pageCache = new Map();\n                        this.#pagePromises = new Map();\n                        this.#passwordCapability = null;\n                        this.messageHandler = messageHandler1;\n                        this.loadingTask = loadingTask1;\n                        this.commonObjs = new PDFObjects();\n                        this.fontLoader = new _font_loader.FontLoader({\n                            ownerDocument: params1.ownerDocument,\n                            styleElement: params1.styleElement\n                        });\n                        this._params = params1;\n                        this.canvasFactory = factory1.canvasFactory;\n                        this.filterFactory = factory1.filterFactory;\n                        this.cMapReaderFactory = factory1.cMapReaderFactory;\n                        this.standardFontDataFactory = factory1.standardFontDataFactory;\n                        this.destroyed = false;\n                        this.destroyCapability = null;\n                        this._networkStream = networkStream1;\n                        this._fullReader = null;\n                        this._lastProgress = null;\n                        this.downloadInfoCapability = new _util.PromiseCapability();\n                        this.setupMessageHandler();\n                    }\n                    #cacheSimpleMethod(name1, data1 = null) {\n                        const cachedPromise1 = this.#methodPromises.get(name1);\n                        if (cachedPromise1) {\n                            return cachedPromise1;\n                        }\n                        const promise1 = this.messageHandler.sendWithPromise(name1, data1);\n                        this.#methodPromises.set(name1, promise1);\n                        return promise1;\n                    }\n                    get annotationStorage() {\n                        return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n                    }\n                    getRenderingIntent(intent1, annotationMode1 = _util.AnnotationMode.ENABLE, printAnnotationStorage1 = null, isOpList1 = false) {\n                        let renderingIntent1 = _util.RenderingIntentFlag.DISPLAY;\n                        let annotationStorageSerializable1 = _annotation_storage.SerializableEmpty;\n                        switch(intent1){\n                            case \"any\":\n                                renderingIntent1 = _util.RenderingIntentFlag.ANY;\n                                break;\n                            case \"display\":\n                                break;\n                            case \"print\":\n                                renderingIntent1 = _util.RenderingIntentFlag.PRINT;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent1}`);\n                        }\n                        switch(annotationMode1){\n                            case _util.AnnotationMode.DISABLE:\n                                renderingIntent1 += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                                break;\n                            case _util.AnnotationMode.ENABLE:\n                                break;\n                            case _util.AnnotationMode.ENABLE_FORMS:\n                                renderingIntent1 += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n                                break;\n                            case _util.AnnotationMode.ENABLE_STORAGE:\n                                renderingIntent1 += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                                const annotationStorage1 = renderingIntent1 & _util.RenderingIntentFlag.PRINT && printAnnotationStorage1 instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage1 : this.annotationStorage;\n                                annotationStorageSerializable1 = annotationStorage1.serializable;\n                                break;\n                            default:\n                                (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode1}`);\n                        }\n                        if (isOpList1) {\n                            renderingIntent1 += _util.RenderingIntentFlag.OPLIST;\n                        }\n                        return {\n                            renderingIntent: renderingIntent1,\n                            cacheKey: `${renderingIntent1}_${annotationStorageSerializable1.hash}`,\n                            annotationStorageSerializable: annotationStorageSerializable1\n                        };\n                    }\n                    destroy() {\n                        if (this.destroyCapability) {\n                            return this.destroyCapability.promise;\n                        }\n                        this.destroyed = true;\n                        this.destroyCapability = new _util.PromiseCapability();\n                        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n                        const waitOn1 = [];\n                        for (const page1 of this.#pageCache.values()){\n                            waitOn1.push(page1._destroy());\n                        }\n                        this.#pageCache.clear();\n                        this.#pagePromises.clear();\n                        if (this.hasOwnProperty(\"annotationStorage\")) {\n                            this.annotationStorage.resetModified();\n                        }\n                        const terminated1 = this.messageHandler.sendWithPromise(\"Terminate\", null);\n                        waitOn1.push(terminated1);\n                        Promise.all(waitOn1).then(()=>{\n                            this.commonObjs.clear();\n                            this.fontLoader.clear();\n                            this.#methodPromises.clear();\n                            this.filterFactory.destroy();\n                            this._networkStream?.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n                            if (this.messageHandler) {\n                                this.messageHandler.destroy();\n                                this.messageHandler = null;\n                            }\n                            this.destroyCapability.resolve();\n                        }, this.destroyCapability.reject);\n                        return this.destroyCapability.promise;\n                    }\n                    setupMessageHandler() {\n                        const { messageHandler: messageHandler1, loadingTask: loadingTask1 } = this;\n                        messageHandler1.on(\"GetReader\", (data1, sink1)=>{\n                            (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n                            this._fullReader = this._networkStream.getFullReader();\n                            this._fullReader.onProgress = (evt1)=>{\n                                this._lastProgress = {\n                                    loaded: evt1.loaded,\n                                    total: evt1.total\n                                };\n                            };\n                            sink1.onPull = ()=>{\n                                this._fullReader.read().then(function({ value: value1, done: done1 }) {\n                                    if (done1) {\n                                        sink1.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value1 instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                                    sink1.enqueue(new Uint8Array(value1), 1, [\n                                        value1\n                                    ]);\n                                }).catch((reason1)=>{\n                                    sink1.error(reason1);\n                                });\n                            };\n                            sink1.onCancel = (reason1)=>{\n                                this._fullReader.cancel(reason1);\n                                sink1.ready.catch((readyReason1)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason1;\n                                });\n                            };\n                        });\n                        messageHandler1.on(\"ReaderHeadersReady\", (data1)=>{\n                            const headersCapability1 = new _util.PromiseCapability();\n                            const fullReader1 = this._fullReader;\n                            fullReader1.headersReady.then(()=>{\n                                if (!fullReader1.isStreamingSupported || !fullReader1.isRangeSupported) {\n                                    if (this._lastProgress) {\n                                        loadingTask1.onProgress?.(this._lastProgress);\n                                    }\n                                    fullReader1.onProgress = (evt1)=>{\n                                        loadingTask1.onProgress?.({\n                                            loaded: evt1.loaded,\n                                            total: evt1.total\n                                        });\n                                    };\n                                }\n                                headersCapability1.resolve({\n                                    isStreamingSupported: fullReader1.isStreamingSupported,\n                                    isRangeSupported: fullReader1.isRangeSupported,\n                                    contentLength: fullReader1.contentLength\n                                });\n                            }, headersCapability1.reject);\n                            return headersCapability1.promise;\n                        });\n                        messageHandler1.on(\"GetRangeReader\", (data1, sink1)=>{\n                            (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n                            const rangeReader1 = this._networkStream.getRangeReader(data1.begin, data1.end);\n                            if (!rangeReader1) {\n                                sink1.close();\n                                return;\n                            }\n                            sink1.onPull = ()=>{\n                                rangeReader1.read().then(function({ value: value1, done: done1 }) {\n                                    if (done1) {\n                                        sink1.close();\n                                        return;\n                                    }\n                                    (0, _util.assert)(value1 instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                                    sink1.enqueue(new Uint8Array(value1), 1, [\n                                        value1\n                                    ]);\n                                }).catch((reason1)=>{\n                                    sink1.error(reason1);\n                                });\n                            };\n                            sink1.onCancel = (reason1)=>{\n                                rangeReader1.cancel(reason1);\n                                sink1.ready.catch((readyReason1)=>{\n                                    if (this.destroyed) {\n                                        return;\n                                    }\n                                    throw readyReason1;\n                                });\n                            };\n                        });\n                        messageHandler1.on(\"GetDoc\", ({ pdfInfo: pdfInfo1 })=>{\n                            this._numPages = pdfInfo1.numPages;\n                            this._htmlForXfa = pdfInfo1.htmlForXfa;\n                            delete pdfInfo1.htmlForXfa;\n                            loadingTask1._capability.resolve(new PDFDocumentProxy(pdfInfo1, this));\n                        });\n                        messageHandler1.on(\"DocException\", function(ex1) {\n                            let reason1;\n                            switch(ex1.name){\n                                case \"PasswordException\":\n                                    reason1 = new _util.PasswordException(ex1.message, ex1.code);\n                                    break;\n                                case \"InvalidPDFException\":\n                                    reason1 = new _util.InvalidPDFException(ex1.message);\n                                    break;\n                                case \"MissingPDFException\":\n                                    reason1 = new _util.MissingPDFException(ex1.message);\n                                    break;\n                                case \"UnexpectedResponseException\":\n                                    reason1 = new _util.UnexpectedResponseException(ex1.message, ex1.status);\n                                    break;\n                                case \"UnknownErrorException\":\n                                    reason1 = new _util.UnknownErrorException(ex1.message, ex1.details);\n                                    break;\n                                default:\n                                    (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n                            }\n                            loadingTask1._capability.reject(reason1);\n                        });\n                        messageHandler1.on(\"PasswordRequest\", (exception1)=>{\n                            this.#passwordCapability = new _util.PromiseCapability();\n                            if (loadingTask1.onPassword) {\n                                const updatePassword1 = (password1)=>{\n                                    if (password1 instanceof Error) {\n                                        this.#passwordCapability.reject(password1);\n                                    } else {\n                                        this.#passwordCapability.resolve({\n                                            password: password1\n                                        });\n                                    }\n                                };\n                                try {\n                                    loadingTask1.onPassword(updatePassword1, exception1.code);\n                                } catch (ex1) {\n                                    this.#passwordCapability.reject(ex1);\n                                }\n                            } else {\n                                this.#passwordCapability.reject(new _util.PasswordException(exception1.message, exception1.code));\n                            }\n                            return this.#passwordCapability.promise;\n                        });\n                        messageHandler1.on(\"DataLoaded\", (data1)=>{\n                            loadingTask1.onProgress?.({\n                                loaded: data1.length,\n                                total: data1.length\n                            });\n                            this.downloadInfoCapability.resolve(data1);\n                        });\n                        messageHandler1.on(\"StartRenderPage\", (data1)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const page1 = this.#pageCache.get(data1.pageIndex);\n                            page1._startRenderPage(data1.transparency, data1.cacheKey);\n                        });\n                        messageHandler1.on(\"commonobj\", ([id1, type1, exportedData1])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            if (this.commonObjs.has(id1)) {\n                                return;\n                            }\n                            switch(type1){\n                                case \"Font\":\n                                    const params1 = this._params;\n                                    if (\"error\" in exportedData1) {\n                                        const exportedError1 = exportedData1.error;\n                                        (0, _util.warn)(`Error during font loading: ${exportedError1}`);\n                                        this.commonObjs.resolve(id1, exportedError1);\n                                        break;\n                                    }\n                                    const inspectFont1 = params1.pdfBug && globalThis.FontInspector?.enabled ? (font1, url1)=>globalThis.FontInspector.fontAdded(font1, url1) : null;\n                                    const font1 = new _font_loader.FontFaceObject(exportedData1, {\n                                        isEvalSupported: params1.isEvalSupported,\n                                        disableFontFace: params1.disableFontFace,\n                                        ignoreErrors: params1.ignoreErrors,\n                                        inspectFont: inspectFont1\n                                    });\n                                    this.fontLoader.bind(font1).catch((reason1)=>{\n                                        return messageHandler1.sendWithPromise(\"FontFallback\", {\n                                            id: id1\n                                        });\n                                    }).finally(()=>{\n                                        if (!params1.fontExtraProperties && font1.data) {\n                                            font1.data = null;\n                                        }\n                                        this.commonObjs.resolve(id1, font1);\n                                    });\n                                    break;\n                                case \"FontPath\":\n                                case \"Image\":\n                                case \"Pattern\":\n                                    this.commonObjs.resolve(id1, exportedData1);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown common object type ${type1}`);\n                            }\n                        });\n                        messageHandler1.on(\"obj\", ([id1, pageIndex1, type1, imageData1])=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            const pageProxy1 = this.#pageCache.get(pageIndex1);\n                            if (pageProxy1.objs.has(id1)) {\n                                return;\n                            }\n                            switch(type1){\n                                case \"Image\":\n                                    pageProxy1.objs.resolve(id1, imageData1);\n                                    if (imageData1) {\n                                        let length1;\n                                        if (imageData1.bitmap) {\n                                            const { width: width2, height: height1 } = imageData1;\n                                            length1 = width2 * height1 * 4;\n                                        } else {\n                                            length1 = imageData1.data?.length || 0;\n                                        }\n                                        if (length1 > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n                                            pageProxy1._maybeCleanupAfterRender = true;\n                                        }\n                                    }\n                                    break;\n                                case \"Pattern\":\n                                    pageProxy1.objs.resolve(id1, imageData1);\n                                    break;\n                                default:\n                                    throw new Error(`Got unknown object type ${type1}`);\n                            }\n                        });\n                        messageHandler1.on(\"DocProgress\", (data1)=>{\n                            if (this.destroyed) {\n                                return;\n                            }\n                            loadingTask1.onProgress?.({\n                                loaded: data1.loaded,\n                                total: data1.total\n                            });\n                        });\n                        messageHandler1.on(\"FetchBuiltInCMap\", (data1)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.cMapReaderFactory) {\n                                return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.cMapReaderFactory.fetch(data1);\n                        });\n                        messageHandler1.on(\"FetchStandardFontData\", (data1)=>{\n                            if (this.destroyed) {\n                                return Promise.reject(new Error(\"Worker was destroyed.\"));\n                            }\n                            if (!this.standardFontDataFactory) {\n                                return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n                            }\n                            return this.standardFontDataFactory.fetch(data1);\n                        });\n                    }\n                    getData() {\n                        return this.messageHandler.sendWithPromise(\"GetData\", null);\n                    }\n                    saveDocument() {\n                        if (this.annotationStorage.size <= 0) {\n                            (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n                        }\n                        const { map: map1, transfers: transfers1 } = this.annotationStorage.serializable;\n                        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n                            isPureXfa: !!this._htmlForXfa,\n                            numPages: this._numPages,\n                            annotationStorage: map1,\n                            filename: this._fullReader?.filename ?? null\n                        }, transfers1).finally(()=>{\n                            this.annotationStorage.resetModified();\n                        });\n                    }\n                    getPage(pageNumber1) {\n                        if (!Number.isInteger(pageNumber1) || pageNumber1 <= 0 || pageNumber1 > this._numPages) {\n                            return Promise.reject(new Error(\"Invalid page request.\"));\n                        }\n                        const pageIndex1 = pageNumber1 - 1, cachedPromise1 = this.#pagePromises.get(pageIndex1);\n                        if (cachedPromise1) {\n                            return cachedPromise1;\n                        }\n                        const promise1 = this.messageHandler.sendWithPromise(\"GetPage\", {\n                            pageIndex: pageIndex1\n                        }).then((pageInfo1)=>{\n                            if (this.destroyed) {\n                                throw new Error(\"Transport destroyed\");\n                            }\n                            const page1 = new PDFPageProxy(pageIndex1, pageInfo1, this, this._params.pdfBug);\n                            this.#pageCache.set(pageIndex1, page1);\n                            return page1;\n                        });\n                        this.#pagePromises.set(pageIndex1, promise1);\n                        return promise1;\n                    }\n                    getPageIndex(ref1) {\n                        if (typeof ref1 !== \"object\" || ref1 === null || !Number.isInteger(ref1.num) || ref1.num < 0 || !Number.isInteger(ref1.gen) || ref1.gen < 0) {\n                            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n                            num: ref1.num,\n                            gen: ref1.gen\n                        });\n                    }\n                    getAnnotations(pageIndex1, intent1) {\n                        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n                            pageIndex: pageIndex1,\n                            intent: intent1\n                        });\n                    }\n                    getFieldObjects() {\n                        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n                    }\n                    hasJSActions() {\n                        return this.#cacheSimpleMethod(\"HasJSActions\");\n                    }\n                    getCalculationOrderIds() {\n                        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n                    }\n                    getDestinations() {\n                        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n                    }\n                    getDestination(id1) {\n                        if (typeof id1 !== \"string\") {\n                            return Promise.reject(new Error(\"Invalid destination request.\"));\n                        }\n                        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n                            id: id1\n                        });\n                    }\n                    getPageLabels() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n                    }\n                    getPageLayout() {\n                        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n                    }\n                    getPageMode() {\n                        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n                    }\n                    getViewerPreferences() {\n                        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n                    }\n                    getOpenAction() {\n                        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n                    }\n                    getAttachments() {\n                        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n                    }\n                    getDocJSActions() {\n                        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n                    }\n                    getPageJSActions(pageIndex1) {\n                        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n                            pageIndex: pageIndex1\n                        });\n                    }\n                    getStructTree(pageIndex1) {\n                        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n                            pageIndex: pageIndex1\n                        });\n                    }\n                    getOutline() {\n                        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n                    }\n                    getOptionalContentConfig() {\n                        return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then((results1)=>{\n                            return new _optional_content_config.OptionalContentConfig(results1);\n                        });\n                    }\n                    getPermissions() {\n                        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n                    }\n                    getMetadata() {\n                        const name1 = \"GetMetadata\", cachedPromise1 = this.#methodPromises.get(name1);\n                        if (cachedPromise1) {\n                            return cachedPromise1;\n                        }\n                        const promise1 = this.messageHandler.sendWithPromise(name1, null).then((results1)=>{\n                            return {\n                                info: results1[0],\n                                metadata: results1[1] ? new _metadata.Metadata(results1[1]) : null,\n                                contentDispositionFilename: this._fullReader?.filename ?? null,\n                                contentLength: this._fullReader?.contentLength ?? null\n                            };\n                        });\n                        this.#methodPromises.set(name1, promise1);\n                        return promise1;\n                    }\n                    getMarkInfo() {\n                        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n                    }\n                    async startCleanup(keepLoadedFonts1 = false) {\n                        if (this.destroyed) {\n                            return;\n                        }\n                        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n                        for (const page1 of this.#pageCache.values()){\n                            const cleanupSuccessful1 = page1.cleanup();\n                            if (!cleanupSuccessful1) {\n                                throw new Error(`startCleanup: Page ${page1.pageNumber} is currently rendering.`);\n                            }\n                        }\n                        this.commonObjs.clear();\n                        if (!keepLoadedFonts1) {\n                            this.fontLoader.clear();\n                        }\n                        this.#methodPromises.clear();\n                        this.filterFactory.destroy(true);\n                    }\n                    get loadingParams() {\n                        const { disableAutoFetch: disableAutoFetch1, enableXfa: enableXfa1 } = this._params;\n                        return (0, _util.shadow)(this, \"loadingParams\", {\n                            disableAutoFetch: disableAutoFetch1,\n                            enableXfa: enableXfa1\n                        });\n                    }\n                }\n                class PDFObjects {\n                    #objs;\n                    #ensureObj(objId1) {\n                        return this.#objs[objId1] ||= {\n                            capability: new _util.PromiseCapability(),\n                            data: null\n                        };\n                    }\n                    get(objId1, callback1 = null) {\n                        if (callback1) {\n                            const obj1 = this.#ensureObj(objId1);\n                            obj1.capability.promise.then(()=>callback1(obj1.data));\n                            return null;\n                        }\n                        const obj1 = this.#objs[objId1];\n                        if (!obj1?.capability.settled) {\n                            throw new Error(`Requesting object that isn't resolved yet ${objId1}.`);\n                        }\n                        return obj1.data;\n                    }\n                    has(objId1) {\n                        const obj1 = this.#objs[objId1];\n                        return obj1?.capability.settled || false;\n                    }\n                    resolve(objId1, data1 = null) {\n                        const obj1 = this.#ensureObj(objId1);\n                        obj1.data = data1;\n                        obj1.capability.resolve();\n                    }\n                    clear() {\n                        for(const objId1 in this.#objs){\n                            const { data: data1 } = this.#objs[objId1];\n                            data1?.bitmap?.close();\n                        }\n                        this.#objs = Object.create(null);\n                    }\n                    constructor(){\n                        this.#objs = Object.create(null);\n                    }\n                }\n                class RenderTask {\n                    #internalRenderTask;\n                    constructor(internalRenderTask1){\n                        this.#internalRenderTask = null;\n                        this.#internalRenderTask = internalRenderTask1;\n                        this.onContinue = null;\n                    }\n                    get promise() {\n                        return this.#internalRenderTask.capability.promise;\n                    }\n                    cancel(extraDelay1 = 0) {\n                        this.#internalRenderTask.cancel(null, extraDelay1);\n                    }\n                    get separateAnnots() {\n                        const { separateAnnots: separateAnnots1 } = this.#internalRenderTask.operatorList;\n                        if (!separateAnnots1) {\n                            return false;\n                        }\n                        const { annotationCanvasMap: annotationCanvasMap1 } = this.#internalRenderTask;\n                        return separateAnnots1.form || separateAnnots1.canvas && annotationCanvasMap1?.size > 0;\n                    }\n                }\n                exports.RenderTask = RenderTask;\n                class InternalRenderTask {\n                    static #canvasInUse = new WeakSet();\n                    constructor({ callback: callback1, params: params1, objs: objs1, commonObjs: commonObjs1, annotationCanvasMap: annotationCanvasMap1, operatorList: operatorList1, pageIndex: pageIndex1, canvasFactory: canvasFactory1, filterFactory: filterFactory1, useRequestAnimationFrame: useRequestAnimationFrame1 = false, pdfBug: pdfBug1 = false, pageColors: pageColors1 = null }){\n                        this.callback = callback1;\n                        this.params = params1;\n                        this.objs = objs1;\n                        this.commonObjs = commonObjs1;\n                        this.annotationCanvasMap = annotationCanvasMap1;\n                        this.operatorListIdx = null;\n                        this.operatorList = operatorList1;\n                        this._pageIndex = pageIndex1;\n                        this.canvasFactory = canvasFactory1;\n                        this.filterFactory = filterFactory1;\n                        this._pdfBug = pdfBug1;\n                        this.pageColors = pageColors1;\n                        this.running = false;\n                        this.graphicsReadyCallback = null;\n                        this.graphicsReady = false;\n                        this._useRequestAnimationFrame = useRequestAnimationFrame1 === true && \"undefined\" !== \"undefined\";\n                        this.cancelled = false;\n                        this.capability = new _util.PromiseCapability();\n                        this.task = new RenderTask(this);\n                        this._cancelBound = this.cancel.bind(this);\n                        this._continueBound = this._continue.bind(this);\n                        this._scheduleNextBound = this._scheduleNext.bind(this);\n                        this._nextBound = this._next.bind(this);\n                        this._canvas = params1.canvasContext.canvas;\n                    }\n                    get completed() {\n                        return this.capability.promise.catch(function() {});\n                    }\n                    initializeGraphics({ transparency: transparency1 = false, optionalContentConfig: optionalContentConfig1 }) {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this._canvas) {\n                            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n                            }\n                            InternalRenderTask.#canvasInUse.add(this._canvas);\n                        }\n                        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n                            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n                            this.stepper.init(this.operatorList);\n                            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n                        }\n                        const { canvasContext: canvasContext1, viewport: viewport1, transform: transform1, background: background1 } = this.params;\n                        this.gfx = new _canvas.CanvasGraphics(canvasContext1, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                            optionalContentConfig: optionalContentConfig1\n                        }, this.annotationCanvasMap, this.pageColors);\n                        this.gfx.beginDrawing({\n                            transform: transform1,\n                            viewport: viewport1,\n                            transparency: transparency1,\n                            background: background1\n                        });\n                        this.operatorListIdx = 0;\n                        this.graphicsReady = true;\n                        this.graphicsReadyCallback?.();\n                    }\n                    cancel(error1 = null, extraDelay1 = 0) {\n                        this.running = false;\n                        this.cancelled = true;\n                        this.gfx?.endDrawing();\n                        InternalRenderTask.#canvasInUse.delete(this._canvas);\n                        this.callback(error1 || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay1));\n                    }\n                    operatorListChanged() {\n                        if (!this.graphicsReady) {\n                            this.graphicsReadyCallback ||= this._continueBound;\n                            return;\n                        }\n                        this.stepper?.updateOperatorList(this.operatorList);\n                        if (this.running) {\n                            return;\n                        }\n                        this._continue();\n                    }\n                    _continue() {\n                        this.running = true;\n                        if (this.cancelled) {\n                            return;\n                        }\n                        if (this.task.onContinue) {\n                            this.task.onContinue(this._scheduleNextBound);\n                        } else {\n                            this._scheduleNext();\n                        }\n                    }\n                    _scheduleNext() {\n                        if (this._useRequestAnimationFrame) {\n                            window.requestAnimationFrame(()=>{\n                                this._nextBound().catch(this._cancelBound);\n                            });\n                        } else {\n                            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n                        }\n                    }\n                    async _next() {\n                        if (this.cancelled) {\n                            return;\n                        }\n                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n                        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                            this.running = false;\n                            if (this.operatorList.lastChunk) {\n                                this.gfx.endDrawing();\n                                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                                this.callback();\n                            }\n                        }\n                    }\n                }\n                const version = \"3.11.174\";\n                exports.version = version;\n                const build = \"ce8716743\";\n                exports.build = build;\n            /***/ },\n            /* 3 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SerializableEmpty = exports1.PrintAnnotationStorage = exports1.AnnotationStorage = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _editor1 = __w_pdfjs_require__1(4);\n                var _murmurhash1 = __w_pdfjs_require__1(8);\n                const SerializableEmpty1 = Object.freeze({\n                    map: null,\n                    hash: \"\",\n                    transfers: undefined\n                });\n                exports1.SerializableEmpty = SerializableEmpty1;\n                class AnnotationStorage1 {\n                    #modified;\n                    #storage;\n                    constructor(){\n                        this.#modified = false;\n                        this.#storage = new Map();\n                        this.onSetModified = null;\n                        this.onResetModified = null;\n                        this.onAnnotationEditor = null;\n                    }\n                    getValue(key1, defaultValue1) {\n                        const value1 = this.#storage.get(key1);\n                        if (value1 === undefined) {\n                            return defaultValue1;\n                        }\n                        return Object.assign(defaultValue1, value1);\n                    }\n                    getRawValue(key1) {\n                        return this.#storage.get(key1);\n                    }\n                    remove(key1) {\n                        this.#storage.delete(key1);\n                        if (this.#storage.size === 0) {\n                            this.resetModified();\n                        }\n                        if (typeof this.onAnnotationEditor === \"function\") {\n                            for (const value1 of this.#storage.values()){\n                                if (value1 instanceof _editor1.AnnotationEditor) {\n                                    return;\n                                }\n                            }\n                            this.onAnnotationEditor(null);\n                        }\n                    }\n                    setValue(key1, value1) {\n                        const obj1 = this.#storage.get(key1);\n                        let modified1 = false;\n                        if (obj1 !== undefined) {\n                            for (const [entry1, val1] of Object.entries(value1)){\n                                if (obj1[entry1] !== val1) {\n                                    modified1 = true;\n                                    obj1[entry1] = val1;\n                                }\n                            }\n                        } else {\n                            modified1 = true;\n                            this.#storage.set(key1, value1);\n                        }\n                        if (modified1) {\n                            this.#setModified();\n                        }\n                        if (value1 instanceof _editor1.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n                            this.onAnnotationEditor(value1.constructor._type);\n                        }\n                    }\n                    has(key1) {\n                        return this.#storage.has(key1);\n                    }\n                    getAll() {\n                        return this.#storage.size > 0 ? (0, _util1.objectFromMap)(this.#storage) : null;\n                    }\n                    setAll(obj1) {\n                        for (const [key1, val1] of Object.entries(obj1)){\n                            this.setValue(key1, val1);\n                        }\n                    }\n                    get size() {\n                        return this.#storage.size;\n                    }\n                    #setModified() {\n                        if (!this.#modified) {\n                            this.#modified = true;\n                            if (typeof this.onSetModified === \"function\") {\n                                this.onSetModified();\n                            }\n                        }\n                    }\n                    resetModified() {\n                        if (this.#modified) {\n                            this.#modified = false;\n                            if (typeof this.onResetModified === \"function\") {\n                                this.onResetModified();\n                            }\n                        }\n                    }\n                    get print() {\n                        return new PrintAnnotationStorage1(this);\n                    }\n                    get serializable() {\n                        if (this.#storage.size === 0) {\n                            return SerializableEmpty1;\n                        }\n                        const map1 = new Map(), hash1 = new _murmurhash1.MurmurHash3_64(), transfers1 = [];\n                        const context1 = Object.create(null);\n                        let hasBitmap1 = false;\n                        for (const [key1, val1] of this.#storage){\n                            const serialized1 = val1 instanceof _editor1.AnnotationEditor ? val1.serialize(false, context1) : val1;\n                            if (serialized1) {\n                                map1.set(key1, serialized1);\n                                hash1.update(`${key1}:${JSON.stringify(serialized1)}`);\n                                hasBitmap1 ||= !!serialized1.bitmap;\n                            }\n                        }\n                        if (hasBitmap1) {\n                            for (const value1 of map1.values()){\n                                if (value1.bitmap) {\n                                    transfers1.push(value1.bitmap);\n                                }\n                            }\n                        }\n                        return map1.size > 0 ? {\n                            map: map1,\n                            hash: hash1.hexdigest(),\n                            transfers: transfers1\n                        } : SerializableEmpty1;\n                    }\n                }\n                exports1.AnnotationStorage = AnnotationStorage1;\n                class PrintAnnotationStorage1 extends AnnotationStorage1 {\n                    #serializable;\n                    constructor(parent1){\n                        super();\n                        const { map: map1, hash: hash1, transfers: transfers1 } = parent1.serializable;\n                        const clone1 = structuredClone(map1, transfers1 ? {\n                            transfer: transfers1\n                        } : null);\n                        this.#serializable = {\n                            map: clone1,\n                            hash: hash1,\n                            transfers: transfers1\n                        };\n                    }\n                    get print() {\n                        (0, _util1.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n                    }\n                    get serializable() {\n                        return this.#serializable;\n                    }\n                }\n                exports1.PrintAnnotationStorage = PrintAnnotationStorage1;\n            /***/ },\n            /* 4 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditor = void 0;\n                var _tools1 = __w_pdfjs_require__1(5);\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                class AnnotationEditor1 {\n                    #altText;\n                    #altTextDecorative;\n                    #altTextButton;\n                    #altTextTooltip;\n                    #altTextTooltipTimeout;\n                    #keepAspectRatio;\n                    #resizersDiv;\n                    #boundFocusin;\n                    #boundFocusout;\n                    #hasBeenClicked;\n                    #isEditing;\n                    #isInEditMode;\n                    #isDraggable;\n                    #zIndex;\n                    static{\n                        this._borderLineWidth = -1;\n                    }\n                    static{\n                        this._colorManager = new _tools1.ColorManager();\n                    }\n                    static{\n                        this._zIndex = 1;\n                    }\n                    static{\n                        this.SMALL_EDITOR_SIZE = 0;\n                    }\n                    constructor(parameters1){\n                        this.#altText = \"\";\n                        this.#altTextDecorative = false;\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                        this.#altTextTooltipTimeout = null;\n                        this.#keepAspectRatio = false;\n                        this.#resizersDiv = null;\n                        this.#boundFocusin = this.focusin.bind(this);\n                        this.#boundFocusout = this.focusout.bind(this);\n                        this.#hasBeenClicked = false;\n                        this.#isEditing = false;\n                        this.#isInEditMode = false;\n                        this._initialOptions = Object.create(null);\n                        this._uiManager = null;\n                        this._focusEventsAllowed = true;\n                        this._l10nPromise = null;\n                        this.#isDraggable = false;\n                        this.#zIndex = AnnotationEditor1._zIndex++;\n                        if (this.constructor === AnnotationEditor1) {\n                            (0, _util1.unreachable)(\"Cannot initialize AnnotationEditor.\");\n                        }\n                        this.parent = parameters1.parent;\n                        this.id = parameters1.id;\n                        this.width = this.height = null;\n                        this.pageIndex = parameters1.parent.pageIndex;\n                        this.name = parameters1.name;\n                        this.div = null;\n                        this._uiManager = parameters1.uiManager;\n                        this.annotationElementId = null;\n                        this._willKeepAspectRatio = false;\n                        this._initialOptions.isCentered = parameters1.isCentered;\n                        this._structTreeParentId = null;\n                        const { rotation: rotation1, rawDims: { pageWidth: pageWidth1, pageHeight: pageHeight1, pageX: pageX1, pageY: pageY1 } } = this.parent.viewport;\n                        this.rotation = rotation1;\n                        this.pageRotation = (360 + rotation1 - this._uiManager.viewParameters.rotation) % 360;\n                        this.pageDimensions = [\n                            pageWidth1,\n                            pageHeight1\n                        ];\n                        this.pageTranslation = [\n                            pageX1,\n                            pageY1\n                        ];\n                        const [width2, height1] = this.parentDimensions;\n                        this.x = parameters1.x / width2;\n                        this.y = parameters1.y / height1;\n                        this.isAttachedToDOM = false;\n                        this.deleted = false;\n                    }\n                    get editorType() {\n                        return Object.getPrototypeOf(this).constructor._type;\n                    }\n                    static get _defaultLineColor() {\n                        return (0, _util1.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n                    }\n                    static deleteAnnotationElement(editor1) {\n                        const fakeEditor1 = new FakeEditor1({\n                            id: editor1.parent.getNextId(),\n                            parent: editor1.parent,\n                            uiManager: editor1._uiManager\n                        });\n                        fakeEditor1.annotationElementId = editor1.annotationElementId;\n                        fakeEditor1.deleted = true;\n                        fakeEditor1._uiManager.addToAnnotationStorage(fakeEditor1);\n                    }\n                    static initialize(l10n1, options1 = null) {\n                        AnnotationEditor1._l10nPromise ||= new Map([\n                            \"editor_alt_text_button_label\",\n                            \"editor_alt_text_edit_button_label\",\n                            \"editor_alt_text_decorative_tooltip\"\n                        ].map((str1)=>[\n                                str1,\n                                l10n1.get(str1)\n                            ]));\n                        if (options1?.strings) {\n                            for (const str1 of options1.strings){\n                                AnnotationEditor1._l10nPromise.set(str1, l10n1.get(str1));\n                            }\n                        }\n                        if (AnnotationEditor1._borderLineWidth !== -1) {\n                            return;\n                        }\n                        const style1 = getComputedStyle(document.documentElement);\n                        AnnotationEditor1._borderLineWidth = parseFloat(style1.getPropertyValue(\"--outline-width\")) || 0;\n                    }\n                    static updateDefaultParams(_type1, _value1) {}\n                    static get defaultPropertiesToUpdate() {\n                        return [];\n                    }\n                    static isHandlingMimeForPasting(mime1) {\n                        return false;\n                    }\n                    static paste(item1, parent1) {\n                        (0, _util1.unreachable)(\"Not implemented\");\n                    }\n                    get propertiesToUpdate() {\n                        return [];\n                    }\n                    get _isDraggable() {\n                        return this.#isDraggable;\n                    }\n                    set _isDraggable(value1) {\n                        this.#isDraggable = value1;\n                        this.div?.classList.toggle(\"draggable\", value1);\n                    }\n                    center() {\n                        const [pageWidth1, pageHeight1] = this.pageDimensions;\n                        switch(this.parentRotation){\n                            case 90:\n                                this.x -= this.height * pageHeight1 / (pageWidth1 * 2);\n                                this.y += this.width * pageWidth1 / (pageHeight1 * 2);\n                                break;\n                            case 180:\n                                this.x += this.width / 2;\n                                this.y += this.height / 2;\n                                break;\n                            case 270:\n                                this.x += this.height * pageHeight1 / (pageWidth1 * 2);\n                                this.y -= this.width * pageWidth1 / (pageHeight1 * 2);\n                                break;\n                            default:\n                                this.x -= this.width / 2;\n                                this.y -= this.height / 2;\n                                break;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    addCommands(params1) {\n                        this._uiManager.addCommands(params1);\n                    }\n                    get currentLayer() {\n                        return this._uiManager.currentLayer;\n                    }\n                    setInBackground() {\n                        this.div.style.zIndex = 0;\n                    }\n                    setInForeground() {\n                        this.div.style.zIndex = this.#zIndex;\n                    }\n                    setParent(parent1) {\n                        if (parent1 !== null) {\n                            this.pageIndex = parent1.pageIndex;\n                            this.pageDimensions = parent1.pageDimensions;\n                        }\n                        this.parent = parent1;\n                    }\n                    focusin(event1) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.#hasBeenClicked) {\n                            this.parent.setSelected(this);\n                        } else {\n                            this.#hasBeenClicked = false;\n                        }\n                    }\n                    focusout(event1) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            return;\n                        }\n                        const target1 = event1.relatedTarget;\n                        if (target1?.closest(`#${this.id}`)) {\n                            return;\n                        }\n                        event1.preventDefault();\n                        if (!this.parent?.isMultipleSelection) {\n                            this.commitOrRemove();\n                        }\n                    }\n                    commitOrRemove() {\n                        if (this.isEmpty()) {\n                            this.remove();\n                        } else {\n                            this.commit();\n                        }\n                    }\n                    commit() {\n                        this.addToAnnotationStorage();\n                    }\n                    addToAnnotationStorage() {\n                        this._uiManager.addToAnnotationStorage(this);\n                    }\n                    setAt(x4, y4, tx2, ty2) {\n                        const [width2, height1] = this.parentDimensions;\n                        [tx2, ty2] = this.screenToPageTranslation(tx2, ty2);\n                        this.x = (x4 + tx2) / width2;\n                        this.y = (y4 + ty2) / height1;\n                        this.fixAndSetPosition();\n                    }\n                    #translate([width2, height1], x4, y4) {\n                        [x4, y4] = this.screenToPageTranslation(x4, y4);\n                        this.x += x4 / width2;\n                        this.y += y4 / height1;\n                        this.fixAndSetPosition();\n                    }\n                    translate(x4, y4) {\n                        this.#translate(this.parentDimensions, x4, y4);\n                    }\n                    translateInPage(x4, y4) {\n                        this.#translate(this.pageDimensions, x4, y4);\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    drag(tx2, ty2) {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.x += tx2 / parentWidth1;\n                        this.y += ty2 / parentHeight1;\n                        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n                            const { x: x4, y: y4 } = this.div.getBoundingClientRect();\n                            if (this.parent.findNewParent(this, x4, y4)) {\n                                this.x -= Math.floor(this.x);\n                                this.y -= Math.floor(this.y);\n                            }\n                        }\n                        let { x: x4, y: y4 } = this;\n                        const [bx1, by1] = this.#getBaseTranslation();\n                        x4 += bx1;\n                        y4 += by1;\n                        this.div.style.left = `${(100 * x4).toFixed(2)}%`;\n                        this.div.style.top = `${(100 * y4).toFixed(2)}%`;\n                        this.div.scrollIntoView({\n                            block: \"nearest\"\n                        });\n                    }\n                    #getBaseTranslation() {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        const { _borderLineWidth: _borderLineWidth1 } = AnnotationEditor1;\n                        const x4 = _borderLineWidth1 / parentWidth1;\n                        const y4 = _borderLineWidth1 / parentHeight1;\n                        switch(this.rotation){\n                            case 90:\n                                return [\n                                    -x4,\n                                    y4\n                                ];\n                            case 180:\n                                return [\n                                    x4,\n                                    y4\n                                ];\n                            case 270:\n                                return [\n                                    x4,\n                                    -y4\n                                ];\n                            default:\n                                return [\n                                    -x4,\n                                    -y4\n                                ];\n                        }\n                    }\n                    fixAndSetPosition() {\n                        const [pageWidth1, pageHeight1] = this.pageDimensions;\n                        let { x: x4, y: y4, width: width2, height: height1 } = this;\n                        width2 *= pageWidth1;\n                        height1 *= pageHeight1;\n                        x4 *= pageWidth1;\n                        y4 *= pageHeight1;\n                        switch(this.rotation){\n                            case 0:\n                                x4 = Math.max(0, Math.min(pageWidth1 - width2, x4));\n                                y4 = Math.max(0, Math.min(pageHeight1 - height1, y4));\n                                break;\n                            case 90:\n                                x4 = Math.max(0, Math.min(pageWidth1 - height1, x4));\n                                y4 = Math.min(pageHeight1, Math.max(width2, y4));\n                                break;\n                            case 180:\n                                x4 = Math.min(pageWidth1, Math.max(width2, x4));\n                                y4 = Math.min(pageHeight1, Math.max(height1, y4));\n                                break;\n                            case 270:\n                                x4 = Math.min(pageWidth1, Math.max(height1, x4));\n                                y4 = Math.max(0, Math.min(pageHeight1 - width2, y4));\n                                break;\n                        }\n                        this.x = x4 /= pageWidth1;\n                        this.y = y4 /= pageHeight1;\n                        const [bx1, by1] = this.#getBaseTranslation();\n                        x4 += bx1;\n                        y4 += by1;\n                        const { style: style1 } = this.div;\n                        style1.left = `${(100 * x4).toFixed(2)}%`;\n                        style1.top = `${(100 * y4).toFixed(2)}%`;\n                        this.moveInDOM();\n                    }\n                    static #rotatePoint(x4, y4, angle1) {\n                        switch(angle1){\n                            case 90:\n                                return [\n                                    y4,\n                                    -x4\n                                ];\n                            case 180:\n                                return [\n                                    -x4,\n                                    -y4\n                                ];\n                            case 270:\n                                return [\n                                    -y4,\n                                    x4\n                                ];\n                            default:\n                                return [\n                                    x4,\n                                    y4\n                                ];\n                        }\n                    }\n                    screenToPageTranslation(x4, y4) {\n                        return AnnotationEditor1.#rotatePoint(x4, y4, this.parentRotation);\n                    }\n                    pageTranslationToScreen(x4, y4) {\n                        return AnnotationEditor1.#rotatePoint(x4, y4, 360 - this.parentRotation);\n                    }\n                    #getRotationMatrix(rotation1) {\n                        switch(rotation1){\n                            case 90:\n                                {\n                                    const [pageWidth1, pageHeight1] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        -pageWidth1 / pageHeight1,\n                                        pageHeight1 / pageWidth1,\n                                        0\n                                    ];\n                                }\n                            case 180:\n                                return [\n                                    -1,\n                                    0,\n                                    0,\n                                    -1\n                                ];\n                            case 270:\n                                {\n                                    const [pageWidth1, pageHeight1] = this.pageDimensions;\n                                    return [\n                                        0,\n                                        pageWidth1 / pageHeight1,\n                                        -pageHeight1 / pageWidth1,\n                                        0\n                                    ];\n                                }\n                            default:\n                                return [\n                                    1,\n                                    0,\n                                    0,\n                                    1\n                                ];\n                        }\n                    }\n                    get parentScale() {\n                        return this._uiManager.viewParameters.realScale;\n                    }\n                    get parentRotation() {\n                        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n                    }\n                    get parentDimensions() {\n                        const { parentScale: parentScale1, pageDimensions: [pageWidth1, pageHeight1] } = this;\n                        const scaledWidth1 = pageWidth1 * parentScale1;\n                        const scaledHeight1 = pageHeight1 * parentScale1;\n                        return _util1.FeatureTest.isCSSRoundSupported ? [\n                            Math.round(scaledWidth1),\n                            Math.round(scaledHeight1)\n                        ] : [\n                            scaledWidth1,\n                            scaledHeight1\n                        ];\n                    }\n                    setDims(width2, height1) {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.div.style.width = `${(100 * width2 / parentWidth1).toFixed(2)}%`;\n                        if (!this.#keepAspectRatio) {\n                            this.div.style.height = `${(100 * height1 / parentHeight1).toFixed(2)}%`;\n                        }\n                        this.#altTextButton?.classList.toggle(\"small\", width2 < AnnotationEditor1.SMALL_EDITOR_SIZE || height1 < AnnotationEditor1.SMALL_EDITOR_SIZE);\n                    }\n                    fixDims() {\n                        const { style: style1 } = this.div;\n                        const { height: height1, width: width2 } = style1;\n                        const widthPercent1 = width2.endsWith(\"%\");\n                        const heightPercent1 = !this.#keepAspectRatio && height1.endsWith(\"%\");\n                        if (widthPercent1 && heightPercent1) {\n                            return;\n                        }\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        if (!widthPercent1) {\n                            style1.width = `${(100 * parseFloat(width2) / parentWidth1).toFixed(2)}%`;\n                        }\n                        if (!this.#keepAspectRatio && !heightPercent1) {\n                            style1.height = `${(100 * parseFloat(height1) / parentHeight1).toFixed(2)}%`;\n                        }\n                    }\n                    getInitialTranslation() {\n                        return [\n                            0,\n                            0\n                        ];\n                    }\n                    #createResizers() {\n                        if (this.#resizersDiv) {\n                            return;\n                        }\n                        this.#resizersDiv = document.createElement(\"div\");\n                        this.#resizersDiv.classList.add(\"resizers\");\n                        const classes1 = [\n                            \"topLeft\",\n                            \"topRight\",\n                            \"bottomRight\",\n                            \"bottomLeft\"\n                        ];\n                        if (!this._willKeepAspectRatio) {\n                            classes1.push(\"topMiddle\", \"middleRight\", \"bottomMiddle\", \"middleLeft\");\n                        }\n                        for (const name1 of classes1){\n                            const div1 = document.createElement(\"div\");\n                            this.#resizersDiv.append(div1);\n                            div1.classList.add(\"resizer\", name1);\n                            div1.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name1));\n                            div1.addEventListener(\"contextmenu\", _display_utils1.noContextMenu);\n                        }\n                        this.div.prepend(this.#resizersDiv);\n                    }\n                    #resizerPointerdown(name1, event1) {\n                        event1.preventDefault();\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        if (event1.button !== 0 || event1.ctrlKey && isMac1) {\n                            return;\n                        }\n                        const boundResizerPointermove1 = this.#resizerPointermove.bind(this, name1);\n                        const savedDraggable1 = this._isDraggable;\n                        this._isDraggable = false;\n                        const pointerMoveOptions1 = {\n                            passive: true,\n                            capture: true\n                        };\n                        window.addEventListener(\"pointermove\", boundResizerPointermove1, pointerMoveOptions1);\n                        const savedX1 = this.x;\n                        const savedY1 = this.y;\n                        const savedWidth1 = this.width;\n                        const savedHeight1 = this.height;\n                        const savedParentCursor1 = this.parent.div.style.cursor;\n                        const savedCursor1 = this.div.style.cursor;\n                        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event1.target).cursor;\n                        const pointerUpCallback1 = ()=>{\n                            this._isDraggable = savedDraggable1;\n                            window.removeEventListener(\"pointerup\", pointerUpCallback1);\n                            window.removeEventListener(\"blur\", pointerUpCallback1);\n                            window.removeEventListener(\"pointermove\", boundResizerPointermove1, pointerMoveOptions1);\n                            this.parent.div.style.cursor = savedParentCursor1;\n                            this.div.style.cursor = savedCursor1;\n                            const newX1 = this.x;\n                            const newY1 = this.y;\n                            const newWidth1 = this.width;\n                            const newHeight1 = this.height;\n                            if (newX1 === savedX1 && newY1 === savedY1 && newWidth1 === savedWidth1 && newHeight1 === savedHeight1) {\n                                return;\n                            }\n                            this.addCommands({\n                                cmd: ()=>{\n                                    this.width = newWidth1;\n                                    this.height = newHeight1;\n                                    this.x = newX1;\n                                    this.y = newY1;\n                                    const [parentWidth1, parentHeight1] = this.parentDimensions;\n                                    this.setDims(parentWidth1 * newWidth1, parentHeight1 * newHeight1);\n                                    this.fixAndSetPosition();\n                                },\n                                undo: ()=>{\n                                    this.width = savedWidth1;\n                                    this.height = savedHeight1;\n                                    this.x = savedX1;\n                                    this.y = savedY1;\n                                    const [parentWidth1, parentHeight1] = this.parentDimensions;\n                                    this.setDims(parentWidth1 * savedWidth1, parentHeight1 * savedHeight1);\n                                    this.fixAndSetPosition();\n                                },\n                                mustExec: true\n                            });\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback1);\n                        window.addEventListener(\"blur\", pointerUpCallback1);\n                    }\n                    #resizerPointermove(name1, event1) {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        const savedX1 = this.x;\n                        const savedY1 = this.y;\n                        const savedWidth1 = this.width;\n                        const savedHeight1 = this.height;\n                        const minWidth1 = AnnotationEditor1.MIN_SIZE / parentWidth1;\n                        const minHeight1 = AnnotationEditor1.MIN_SIZE / parentHeight1;\n                        const round1 = (x4)=>Math.round(x4 * 10000) / 10000;\n                        const rotationMatrix1 = this.#getRotationMatrix(this.rotation);\n                        const transf1 = (x4, y4)=>[\n                                rotationMatrix1[0] * x4 + rotationMatrix1[2] * y4,\n                                rotationMatrix1[1] * x4 + rotationMatrix1[3] * y4\n                            ];\n                        const invRotationMatrix1 = this.#getRotationMatrix(360 - this.rotation);\n                        const invTransf1 = (x4, y4)=>[\n                                invRotationMatrix1[0] * x4 + invRotationMatrix1[2] * y4,\n                                invRotationMatrix1[1] * x4 + invRotationMatrix1[3] * y4\n                            ];\n                        let getPoint1;\n                        let getOpposite1;\n                        let isDiagonal1 = false;\n                        let isHorizontal1 = false;\n                        switch(name1){\n                            case \"topLeft\":\n                                isDiagonal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        0,\n                                        0\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        w1,\n                                        h3\n                                    ];\n                                break;\n                            case \"topMiddle\":\n                                getPoint1 = (w1, h3)=>[\n                                        w1 / 2,\n                                        0\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        w1 / 2,\n                                        h3\n                                    ];\n                                break;\n                            case \"topRight\":\n                                isDiagonal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        w1,\n                                        0\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        0,\n                                        h3\n                                    ];\n                                break;\n                            case \"middleRight\":\n                                isHorizontal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        w1,\n                                        h3 / 2\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        0,\n                                        h3 / 2\n                                    ];\n                                break;\n                            case \"bottomRight\":\n                                isDiagonal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        w1,\n                                        h3\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        0,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomMiddle\":\n                                getPoint1 = (w1, h3)=>[\n                                        w1 / 2,\n                                        h3\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        w1 / 2,\n                                        0\n                                    ];\n                                break;\n                            case \"bottomLeft\":\n                                isDiagonal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        0,\n                                        h3\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        w1,\n                                        0\n                                    ];\n                                break;\n                            case \"middleLeft\":\n                                isHorizontal1 = true;\n                                getPoint1 = (w1, h3)=>[\n                                        0,\n                                        h3 / 2\n                                    ];\n                                getOpposite1 = (w1, h3)=>[\n                                        w1,\n                                        h3 / 2\n                                    ];\n                                break;\n                        }\n                        const point2 = getPoint1(savedWidth1, savedHeight1);\n                        const oppositePoint1 = getOpposite1(savedWidth1, savedHeight1);\n                        let transfOppositePoint1 = transf1(...oppositePoint1);\n                        const oppositeX1 = round1(savedX1 + transfOppositePoint1[0]);\n                        const oppositeY1 = round1(savedY1 + transfOppositePoint1[1]);\n                        let ratioX1 = 1;\n                        let ratioY1 = 1;\n                        let [deltaX1, deltaY1] = this.screenToPageTranslation(event1.movementX, event1.movementY);\n                        [deltaX1, deltaY1] = invTransf1(deltaX1 / parentWidth1, deltaY1 / parentHeight1);\n                        if (isDiagonal1) {\n                            const oldDiag1 = Math.hypot(savedWidth1, savedHeight1);\n                            ratioX1 = ratioY1 = Math.max(Math.min(Math.hypot(oppositePoint1[0] - point2[0] - deltaX1, oppositePoint1[1] - point2[1] - deltaY1) / oldDiag1, 1 / savedWidth1, 1 / savedHeight1), minWidth1 / savedWidth1, minHeight1 / savedHeight1);\n                        } else if (isHorizontal1) {\n                            ratioX1 = Math.max(minWidth1, Math.min(1, Math.abs(oppositePoint1[0] - point2[0] - deltaX1))) / savedWidth1;\n                        } else {\n                            ratioY1 = Math.max(minHeight1, Math.min(1, Math.abs(oppositePoint1[1] - point2[1] - deltaY1))) / savedHeight1;\n                        }\n                        const newWidth1 = round1(savedWidth1 * ratioX1);\n                        const newHeight1 = round1(savedHeight1 * ratioY1);\n                        transfOppositePoint1 = transf1(...getOpposite1(newWidth1, newHeight1));\n                        const newX1 = oppositeX1 - transfOppositePoint1[0];\n                        const newY1 = oppositeY1 - transfOppositePoint1[1];\n                        this.width = newWidth1;\n                        this.height = newHeight1;\n                        this.x = newX1;\n                        this.y = newY1;\n                        this.setDims(parentWidth1 * newWidth1, parentHeight1 * newHeight1);\n                        this.fixAndSetPosition();\n                    }\n                    async addAltTextButton() {\n                        if (this.#altTextButton) {\n                            return;\n                        }\n                        const altText1 = this.#altTextButton = document.createElement(\"button\");\n                        altText1.className = \"altText\";\n                        const msg1 = await AnnotationEditor1._l10nPromise.get(\"editor_alt_text_button_label\");\n                        altText1.textContent = msg1;\n                        altText1.setAttribute(\"aria-label\", msg1);\n                        altText1.tabIndex = \"0\";\n                        altText1.addEventListener(\"contextmenu\", _display_utils1.noContextMenu);\n                        altText1.addEventListener(\"pointerdown\", (event1)=>event1.stopPropagation());\n                        altText1.addEventListener(\"click\", (event1)=>{\n                            event1.preventDefault();\n                            this._uiManager.editAltText(this);\n                        }, {\n                            capture: true\n                        });\n                        altText1.addEventListener(\"keydown\", (event1)=>{\n                            if (event1.target === altText1 && event1.key === \"Enter\") {\n                                event1.preventDefault();\n                                this._uiManager.editAltText(this);\n                            }\n                        });\n                        this.#setAltTextButtonState();\n                        this.div.append(altText1);\n                        if (!AnnotationEditor1.SMALL_EDITOR_SIZE) {\n                            const PERCENT1 = 40;\n                            AnnotationEditor1.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText1.getBoundingClientRect().width * (1 + PERCENT1 / 100)));\n                        }\n                    }\n                    async #setAltTextButtonState() {\n                        const button1 = this.#altTextButton;\n                        if (!button1) {\n                            return;\n                        }\n                        if (!this.#altText && !this.#altTextDecorative) {\n                            button1.classList.remove(\"done\");\n                            this.#altTextTooltip?.remove();\n                            return;\n                        }\n                        AnnotationEditor1._l10nPromise.get(\"editor_alt_text_edit_button_label\").then((msg1)=>{\n                            button1.setAttribute(\"aria-label\", msg1);\n                        });\n                        let tooltip1 = this.#altTextTooltip;\n                        if (!tooltip1) {\n                            this.#altTextTooltip = tooltip1 = document.createElement(\"span\");\n                            tooltip1.className = \"tooltip\";\n                            tooltip1.setAttribute(\"role\", \"tooltip\");\n                            const id1 = tooltip1.id = `alt-text-tooltip-${this.id}`;\n                            button1.setAttribute(\"aria-describedby\", id1);\n                            const DELAY_TO_SHOW_TOOLTIP1 = 100;\n                            button1.addEventListener(\"mouseenter\", ()=>{\n                                this.#altTextTooltipTimeout = setTimeout(()=>{\n                                    this.#altTextTooltipTimeout = null;\n                                    this.#altTextTooltip.classList.add(\"show\");\n                                    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                                        source: this,\n                                        details: {\n                                            type: \"editing\",\n                                            subtype: this.editorType,\n                                            data: {\n                                                action: \"alt_text_tooltip\"\n                                            }\n                                        }\n                                    });\n                                }, DELAY_TO_SHOW_TOOLTIP1);\n                            });\n                            button1.addEventListener(\"mouseleave\", ()=>{\n                                clearTimeout(this.#altTextTooltipTimeout);\n                                this.#altTextTooltipTimeout = null;\n                                this.#altTextTooltip?.classList.remove(\"show\");\n                            });\n                        }\n                        button1.classList.add(\"done\");\n                        tooltip1.innerText = this.#altTextDecorative ? await AnnotationEditor1._l10nPromise.get(\"editor_alt_text_decorative_tooltip\") : this.#altText;\n                        if (!tooltip1.parentNode) {\n                            button1.append(tooltip1);\n                        }\n                    }\n                    getClientDimensions() {\n                        return this.div.getBoundingClientRect();\n                    }\n                    get altTextData() {\n                        return {\n                            altText: this.#altText,\n                            decorative: this.#altTextDecorative\n                        };\n                    }\n                    set altTextData({ altText: altText1, decorative: decorative1 }) {\n                        if (this.#altText === altText1 && this.#altTextDecorative === decorative1) {\n                            return;\n                        }\n                        this.#altText = altText1;\n                        this.#altTextDecorative = decorative1;\n                        this.#setAltTextButtonState();\n                    }\n                    render() {\n                        this.div = document.createElement(\"div\");\n                        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n                        this.div.className = this.name;\n                        this.div.setAttribute(\"id\", this.id);\n                        this.div.setAttribute(\"tabIndex\", 0);\n                        this.setInForeground();\n                        this.div.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.addEventListener(\"focusout\", this.#boundFocusout);\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        if (this.parentRotation % 180 !== 0) {\n                            this.div.style.maxWidth = `${(100 * parentHeight1 / parentWidth1).toFixed(2)}%`;\n                            this.div.style.maxHeight = `${(100 * parentWidth1 / parentHeight1).toFixed(2)}%`;\n                        }\n                        const [tx2, ty2] = this.getInitialTranslation();\n                        this.translate(tx2, ty2);\n                        (0, _tools1.bindEvents)(this, this.div, [\n                            \"pointerdown\"\n                        ]);\n                        return this.div;\n                    }\n                    pointerdown(event1) {\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        if (event1.button !== 0 || event1.ctrlKey && isMac1) {\n                            event1.preventDefault();\n                            return;\n                        }\n                        this.#hasBeenClicked = true;\n                        this.#setUpDragSession(event1);\n                    }\n                    #setUpDragSession(event1) {\n                        if (!this._isDraggable) {\n                            return;\n                        }\n                        const isSelected1 = this._uiManager.isSelected(this);\n                        this._uiManager.setUpDragSession();\n                        let pointerMoveOptions1, pointerMoveCallback1;\n                        if (isSelected1) {\n                            pointerMoveOptions1 = {\n                                passive: true,\n                                capture: true\n                            };\n                            pointerMoveCallback1 = (e1)=>{\n                                const [tx2, ty2] = this.screenToPageTranslation(e1.movementX, e1.movementY);\n                                this._uiManager.dragSelectedEditors(tx2, ty2);\n                            };\n                            window.addEventListener(\"pointermove\", pointerMoveCallback1, pointerMoveOptions1);\n                        }\n                        const pointerUpCallback1 = ()=>{\n                            window.removeEventListener(\"pointerup\", pointerUpCallback1);\n                            window.removeEventListener(\"blur\", pointerUpCallback1);\n                            if (isSelected1) {\n                                window.removeEventListener(\"pointermove\", pointerMoveCallback1, pointerMoveOptions1);\n                            }\n                            this.#hasBeenClicked = false;\n                            if (!this._uiManager.endDragSession()) {\n                                const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                                if (event1.ctrlKey && !isMac1 || event1.shiftKey || event1.metaKey && isMac1) {\n                                    this.parent.toggleSelected(this);\n                                } else {\n                                    this.parent.setSelected(this);\n                                }\n                            }\n                        };\n                        window.addEventListener(\"pointerup\", pointerUpCallback1);\n                        window.addEventListener(\"blur\", pointerUpCallback1);\n                    }\n                    moveInDOM() {\n                        this.parent?.moveEditorInDOM(this);\n                    }\n                    _setParentAndPosition(parent1, x4, y4) {\n                        parent1.changeParent(this);\n                        this.x = x4;\n                        this.y = y4;\n                        this.fixAndSetPosition();\n                    }\n                    getRect(tx2, ty2) {\n                        const scale1 = this.parentScale;\n                        const [pageWidth1, pageHeight1] = this.pageDimensions;\n                        const [pageX1, pageY1] = this.pageTranslation;\n                        const shiftX1 = tx2 / scale1;\n                        const shiftY1 = ty2 / scale1;\n                        const x4 = this.x * pageWidth1;\n                        const y4 = this.y * pageHeight1;\n                        const width2 = this.width * pageWidth1;\n                        const height1 = this.height * pageHeight1;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x4 + shiftX1 + pageX1,\n                                    pageHeight1 - y4 - shiftY1 - height1 + pageY1,\n                                    x4 + shiftX1 + width2 + pageX1,\n                                    pageHeight1 - y4 - shiftY1 + pageY1\n                                ];\n                            case 90:\n                                return [\n                                    x4 + shiftY1 + pageX1,\n                                    pageHeight1 - y4 + shiftX1 + pageY1,\n                                    x4 + shiftY1 + height1 + pageX1,\n                                    pageHeight1 - y4 + shiftX1 + width2 + pageY1\n                                ];\n                            case 180:\n                                return [\n                                    x4 - shiftX1 - width2 + pageX1,\n                                    pageHeight1 - y4 + shiftY1 + pageY1,\n                                    x4 - shiftX1 + pageX1,\n                                    pageHeight1 - y4 + shiftY1 + height1 + pageY1\n                                ];\n                            case 270:\n                                return [\n                                    x4 - shiftY1 - height1 + pageX1,\n                                    pageHeight1 - y4 - shiftX1 - width2 + pageY1,\n                                    x4 - shiftY1 + pageX1,\n                                    pageHeight1 - y4 - shiftX1 + pageY1\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    getRectInCurrentCoords(rect3, pageHeight1) {\n                        const [x11, y11, x21, y21] = rect3;\n                        const width2 = x21 - x11;\n                        const height1 = y21 - y11;\n                        switch(this.rotation){\n                            case 0:\n                                return [\n                                    x11,\n                                    pageHeight1 - y21,\n                                    width2,\n                                    height1\n                                ];\n                            case 90:\n                                return [\n                                    x11,\n                                    pageHeight1 - y11,\n                                    height1,\n                                    width2\n                                ];\n                            case 180:\n                                return [\n                                    x21,\n                                    pageHeight1 - y11,\n                                    width2,\n                                    height1\n                                ];\n                            case 270:\n                                return [\n                                    x21,\n                                    pageHeight1 - y21,\n                                    height1,\n                                    width2\n                                ];\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                    }\n                    onceAdded() {}\n                    isEmpty() {\n                        return false;\n                    }\n                    enableEditMode() {\n                        this.#isInEditMode = true;\n                    }\n                    disableEditMode() {\n                        this.#isInEditMode = false;\n                    }\n                    isInEditMode() {\n                        return this.#isInEditMode;\n                    }\n                    shouldGetKeyboardEvents() {\n                        return false;\n                    }\n                    needsToBeRebuilt() {\n                        return this.div && !this.isAttachedToDOM;\n                    }\n                    rebuild() {\n                        this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n                        this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n                    }\n                    serialize(isForCopying1 = false, context1 = null) {\n                        (0, _util1.unreachable)(\"An editor must be serializable\");\n                    }\n                    static deserialize(data1, parent1, uiManager1) {\n                        const editor1 = new this.prototype.constructor({\n                            parent: parent1,\n                            id: parent1.getNextId(),\n                            uiManager: uiManager1\n                        });\n                        editor1.rotation = data1.rotation;\n                        const [pageWidth1, pageHeight1] = editor1.pageDimensions;\n                        const [x4, y4, width2, height1] = editor1.getRectInCurrentCoords(data1.rect, pageHeight1);\n                        editor1.x = x4 / pageWidth1;\n                        editor1.y = y4 / pageHeight1;\n                        editor1.width = width2 / pageWidth1;\n                        editor1.height = height1 / pageHeight1;\n                        return editor1;\n                    }\n                    remove() {\n                        this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n                        this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        if (this.parent) {\n                            this.parent.remove(this);\n                        } else {\n                            this._uiManager.removeEditor(this);\n                        }\n                        this.#altTextButton?.remove();\n                        this.#altTextButton = null;\n                        this.#altTextTooltip = null;\n                    }\n                    get isResizable() {\n                        return false;\n                    }\n                    makeResizable() {\n                        if (this.isResizable) {\n                            this.#createResizers();\n                            this.#resizersDiv.classList.remove(\"hidden\");\n                        }\n                    }\n                    select() {\n                        this.makeResizable();\n                        this.div?.classList.add(\"selectedEditor\");\n                    }\n                    unselect() {\n                        this.#resizersDiv?.classList.add(\"hidden\");\n                        this.div?.classList.remove(\"selectedEditor\");\n                        if (this.div?.contains(document.activeElement)) {\n                            this._uiManager.currentLayer.div.focus();\n                        }\n                    }\n                    updateParams(type1, value1) {}\n                    disableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = true;\n                        }\n                    }\n                    enableEditing() {\n                        if (this.#altTextButton) {\n                            this.#altTextButton.hidden = false;\n                        }\n                    }\n                    enterInEditMode() {}\n                    get contentDiv() {\n                        return this.div;\n                    }\n                    get isEditing() {\n                        return this.#isEditing;\n                    }\n                    set isEditing(value1) {\n                        this.#isEditing = value1;\n                        if (!this.parent) {\n                            return;\n                        }\n                        if (value1) {\n                            this.parent.setSelected(this);\n                            this.parent.setActiveEditor(this);\n                        } else {\n                            this.parent.setActiveEditor(null);\n                        }\n                    }\n                    setAspectRatio(width2, height1) {\n                        this.#keepAspectRatio = true;\n                        const aspectRatio1 = width2 / height1;\n                        const { style: style1 } = this.div;\n                        style1.aspectRatio = aspectRatio1;\n                        style1.height = \"auto\";\n                    }\n                    static get MIN_SIZE() {\n                        return 16;\n                    }\n                }\n                exports1.AnnotationEditor = AnnotationEditor1;\n                class FakeEditor1 extends AnnotationEditor1 {\n                    constructor(params1){\n                        super(params1);\n                        this.annotationElementId = params1.annotationElementId;\n                        this.deleted = true;\n                    }\n                    serialize() {\n                        return {\n                            id: this.annotationElementId,\n                            deleted: true,\n                            pageIndex: this.pageIndex\n                        };\n                    }\n                }\n            /***/ },\n            /* 5 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.KeyboardManager = exports1.CommandManager = exports1.ColorManager = exports1.AnnotationEditorUIManager = void 0;\n                exports1.bindEvents = bindEvents1;\n                exports1.opacityToHex = opacityToHex1;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                function bindEvents1(obj1, element1, names1) {\n                    for (const name1 of names1){\n                        element1.addEventListener(name1, obj1[name1].bind(obj1));\n                    }\n                }\n                function opacityToHex1(opacity1) {\n                    return Math.round(Math.min(255, Math.max(1, 255 * opacity1))).toString(16).padStart(2, \"0\");\n                }\n                class IdManager1 {\n                    #id;\n                    getId() {\n                        return `${_util1.AnnotationEditorPrefix}${this.#id++}`;\n                    }\n                    constructor(){\n                        this.#id = 0;\n                    }\n                }\n                class ImageManager1 {\n                    #baseId;\n                    #id;\n                    #cache;\n                    static get _isSVGFittingCanvas() {\n                        const svg1 = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n                        const canvas1 = new OffscreenCanvas(1, 3);\n                        const ctx1 = canvas1.getContext(\"2d\");\n                        const image1 = new Image();\n                        image1.src = svg1;\n                        const promise1 = image1.decode().then(()=>{\n                            ctx1.drawImage(image1, 0, 0, 1, 1, 0, 0, 1, 3);\n                            return new Uint32Array(ctx1.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n                        });\n                        return (0, _util1.shadow)(this, \"_isSVGFittingCanvas\", promise1);\n                    }\n                    async #get(key1, rawData1) {\n                        this.#cache ||= new Map();\n                        let data1 = this.#cache.get(key1);\n                        if (data1 === null) {\n                            return null;\n                        }\n                        if (data1?.bitmap) {\n                            data1.refCounter += 1;\n                            return data1;\n                        }\n                        try {\n                            data1 ||= {\n                                bitmap: null,\n                                id: `image_${this.#baseId}_${this.#id++}`,\n                                refCounter: 0,\n                                isSvg: false\n                            };\n                            let image1;\n                            if (typeof rawData1 === \"string\") {\n                                data1.url = rawData1;\n                                const response1 = await fetch(rawData1);\n                                if (!response1.ok) {\n                                    throw new Error(response1.statusText);\n                                }\n                                image1 = await response1.blob();\n                            } else {\n                                image1 = data1.file = rawData1;\n                            }\n                            if (image1.type === \"image/svg+xml\") {\n                                const mustRemoveAspectRatioPromise1 = ImageManager1._isSVGFittingCanvas;\n                                const fileReader1 = new FileReader();\n                                const imageElement1 = new Image();\n                                const imagePromise1 = new Promise((resolve1, reject1)=>{\n                                    imageElement1.onload = ()=>{\n                                        data1.bitmap = imageElement1;\n                                        data1.isSvg = true;\n                                        resolve1();\n                                    };\n                                    fileReader1.onload = async ()=>{\n                                        const url1 = data1.svgUrl = fileReader1.result;\n                                        imageElement1.src = await mustRemoveAspectRatioPromise1 ? `${url1}#svgView(preserveAspectRatio(none))` : url1;\n                                    };\n                                    imageElement1.onerror = fileReader1.onerror = reject1;\n                                });\n                                fileReader1.readAsDataURL(image1);\n                                await imagePromise1;\n                            } else {\n                                data1.bitmap = await createImageBitmap(image1);\n                            }\n                            data1.refCounter = 1;\n                        } catch (e1) {\n                            console.error(e1);\n                            data1 = null;\n                        }\n                        this.#cache.set(key1, data1);\n                        if (data1) {\n                            this.#cache.set(data1.id, data1);\n                        }\n                        return data1;\n                    }\n                    async getFromFile(file1) {\n                        const { lastModified: lastModified1, name: name1, size: size1, type: type1 } = file1;\n                        return this.#get(`${lastModified1}_${name1}_${size1}_${type1}`, file1);\n                    }\n                    async getFromUrl(url1) {\n                        return this.#get(url1, url1);\n                    }\n                    async getFromId(id1) {\n                        this.#cache ||= new Map();\n                        const data1 = this.#cache.get(id1);\n                        if (!data1) {\n                            return null;\n                        }\n                        if (data1.bitmap) {\n                            data1.refCounter += 1;\n                            return data1;\n                        }\n                        if (data1.file) {\n                            return this.getFromFile(data1.file);\n                        }\n                        return this.getFromUrl(data1.url);\n                    }\n                    getSvgUrl(id1) {\n                        const data1 = this.#cache.get(id1);\n                        if (!data1?.isSvg) {\n                            return null;\n                        }\n                        return data1.svgUrl;\n                    }\n                    deleteId(id1) {\n                        this.#cache ||= new Map();\n                        const data1 = this.#cache.get(id1);\n                        if (!data1) {\n                            return;\n                        }\n                        data1.refCounter -= 1;\n                        if (data1.refCounter !== 0) {\n                            return;\n                        }\n                        data1.bitmap = null;\n                    }\n                    isValidId(id1) {\n                        return id1.startsWith(`image_${this.#baseId}_`);\n                    }\n                    constructor(){\n                        this.#baseId = (0, _util1.getUuid)();\n                        this.#id = 0;\n                        this.#cache = null;\n                    }\n                }\n                class CommandManager1 {\n                    #commands;\n                    #locked;\n                    #maxSize;\n                    #position;\n                    constructor(maxSize1 = 128){\n                        this.#commands = [];\n                        this.#locked = false;\n                        this.#position = -1;\n                        this.#maxSize = maxSize1;\n                    }\n                    add({ cmd: cmd1, undo: undo1, mustExec: mustExec1, type: type1 = NaN, overwriteIfSameType: overwriteIfSameType1 = false, keepUndo: keepUndo1 = false }) {\n                        if (mustExec1) {\n                            cmd1();\n                        }\n                        if (this.#locked) {\n                            return;\n                        }\n                        const save1 = {\n                            cmd: cmd1,\n                            undo: undo1,\n                            type: type1\n                        };\n                        if (this.#position === -1) {\n                            if (this.#commands.length > 0) {\n                                this.#commands.length = 0;\n                            }\n                            this.#position = 0;\n                            this.#commands.push(save1);\n                            return;\n                        }\n                        if (overwriteIfSameType1 && this.#commands[this.#position].type === type1) {\n                            if (keepUndo1) {\n                                save1.undo = this.#commands[this.#position].undo;\n                            }\n                            this.#commands[this.#position] = save1;\n                            return;\n                        }\n                        const next1 = this.#position + 1;\n                        if (next1 === this.#maxSize) {\n                            this.#commands.splice(0, 1);\n                        } else {\n                            this.#position = next1;\n                            if (next1 < this.#commands.length) {\n                                this.#commands.splice(next1);\n                            }\n                        }\n                        this.#commands.push(save1);\n                    }\n                    undo() {\n                        if (this.#position === -1) {\n                            return;\n                        }\n                        this.#locked = true;\n                        this.#commands[this.#position].undo();\n                        this.#locked = false;\n                        this.#position -= 1;\n                    }\n                    redo() {\n                        if (this.#position < this.#commands.length - 1) {\n                            this.#position += 1;\n                            this.#locked = true;\n                            this.#commands[this.#position].cmd();\n                            this.#locked = false;\n                        }\n                    }\n                    hasSomethingToUndo() {\n                        return this.#position !== -1;\n                    }\n                    hasSomethingToRedo() {\n                        return this.#position < this.#commands.length - 1;\n                    }\n                    destroy() {\n                        this.#commands = null;\n                    }\n                }\n                exports1.CommandManager = CommandManager1;\n                class KeyboardManager1 {\n                    constructor(callbacks1){\n                        this.buffer = [];\n                        this.callbacks = new Map();\n                        this.allKeys = new Set();\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        for (const [keys1, callback1, options1 = {}] of callbacks1){\n                            for (const key1 of keys1){\n                                const isMacKey1 = key1.startsWith(\"mac+\");\n                                if (isMac1 && isMacKey1) {\n                                    this.callbacks.set(key1.slice(4), {\n                                        callback: callback1,\n                                        options: options1\n                                    });\n                                    this.allKeys.add(key1.split(\"+\").at(-1));\n                                } else if (!isMac1 && !isMacKey1) {\n                                    this.callbacks.set(key1, {\n                                        callback: callback1,\n                                        options: options1\n                                    });\n                                    this.allKeys.add(key1.split(\"+\").at(-1));\n                                }\n                            }\n                        }\n                    }\n                    #serialize(event1) {\n                        if (event1.altKey) {\n                            this.buffer.push(\"alt\");\n                        }\n                        if (event1.ctrlKey) {\n                            this.buffer.push(\"ctrl\");\n                        }\n                        if (event1.metaKey) {\n                            this.buffer.push(\"meta\");\n                        }\n                        if (event1.shiftKey) {\n                            this.buffer.push(\"shift\");\n                        }\n                        this.buffer.push(event1.key);\n                        const str1 = this.buffer.join(\"+\");\n                        this.buffer.length = 0;\n                        return str1;\n                    }\n                    exec(self1, event1) {\n                        if (!this.allKeys.has(event1.key)) {\n                            return;\n                        }\n                        const info1 = this.callbacks.get(this.#serialize(event1));\n                        if (!info1) {\n                            return;\n                        }\n                        const { callback: callback1, options: { bubbles: bubbles1 = false, args: args1 = [], checker: checker1 = null } } = info1;\n                        if (checker1 && !checker1(self1, event1)) {\n                            return;\n                        }\n                        callback1.bind(self1, ...args1)();\n                        if (!bubbles1) {\n                            event1.stopPropagation();\n                            event1.preventDefault();\n                        }\n                    }\n                }\n                exports1.KeyboardManager = KeyboardManager1;\n                class ColorManager1 {\n                    static{\n                        this._colorsMapping = new Map([\n                            [\n                                \"CanvasText\",\n                                [\n                                    0,\n                                    0,\n                                    0\n                                ]\n                            ],\n                            [\n                                \"Canvas\",\n                                [\n                                    255,\n                                    255,\n                                    255\n                                ]\n                            ]\n                        ]);\n                    }\n                    get _colors() {\n                        const colors1 = new Map([\n                            [\n                                \"CanvasText\",\n                                null\n                            ],\n                            [\n                                \"Canvas\",\n                                null\n                            ]\n                        ]);\n                        (0, _display_utils1.getColorValues)(colors1);\n                        return (0, _util1.shadow)(this, \"_colors\", colors1);\n                    }\n                    convert(color1) {\n                        const rgb1 = (0, _display_utils1.getRGB)(color1);\n                        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n                            return rgb1;\n                        }\n                        for (const [name1, RGB1] of this._colors){\n                            if (RGB1.every((x4, i1)=>x4 === rgb1[i1])) {\n                                return ColorManager1._colorsMapping.get(name1);\n                            }\n                        }\n                        return rgb1;\n                    }\n                    getHexCode(name1) {\n                        const rgb1 = this._colors.get(name1);\n                        if (!rgb1) {\n                            return name1;\n                        }\n                        return _util1.Util.makeHexColor(...rgb1);\n                    }\n                }\n                exports1.ColorManager = ColorManager1;\n                class AnnotationEditorUIManager1 {\n                    #activeEditor;\n                    #allEditors;\n                    #allLayers;\n                    #altTextManager;\n                    #annotationStorage;\n                    #commandManager;\n                    #currentPageIndex;\n                    #deletedAnnotationsElementIds;\n                    #draggingEditors;\n                    #editorTypes;\n                    #editorsToRescale;\n                    #filterFactory;\n                    #idManager;\n                    #isEnabled;\n                    #isWaiting;\n                    #lastActiveElement;\n                    #mode;\n                    #selectedEditors;\n                    #pageColors;\n                    #boundBlur;\n                    #boundFocus;\n                    #boundCopy;\n                    #boundCut;\n                    #boundPaste;\n                    #boundKeydown;\n                    #boundOnEditingAction;\n                    #boundOnPageChanging;\n                    #boundOnScaleChanging;\n                    #boundOnRotationChanging;\n                    #previousStates;\n                    #translation;\n                    #translationTimeoutId;\n                    #container;\n                    #viewer;\n                    static{\n                        this.TRANSLATE_SMALL = 1;\n                    }\n                    static{\n                        this.TRANSLATE_BIG = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto1 = AnnotationEditorUIManager1.prototype;\n                        const arrowChecker1 = (self1)=>{\n                            const { activeElement: activeElement1 } = document;\n                            return activeElement1 && self1.#container.contains(activeElement1) && self1.hasSomethingToControl();\n                        };\n                        const small1 = this.TRANSLATE_SMALL;\n                        const big1 = this.TRANSLATE_BIG;\n                        return (0, _util1.shadow)(this, \"_keyboardManager\", new KeyboardManager1([\n                            [\n                                [\n                                    \"ctrl+a\",\n                                    \"mac+meta+a\"\n                                ],\n                                proto1.selectAll\n                            ],\n                            [\n                                [\n                                    \"ctrl+z\",\n                                    \"mac+meta+z\"\n                                ],\n                                proto1.undo\n                            ],\n                            [\n                                [\n                                    \"ctrl+y\",\n                                    \"ctrl+shift+z\",\n                                    \"mac+meta+shift+z\",\n                                    \"ctrl+shift+Z\",\n                                    \"mac+meta+shift+Z\"\n                                ],\n                                proto1.redo\n                            ],\n                            [\n                                [\n                                    \"Backspace\",\n                                    \"alt+Backspace\",\n                                    \"ctrl+Backspace\",\n                                    \"shift+Backspace\",\n                                    \"mac+Backspace\",\n                                    \"mac+alt+Backspace\",\n                                    \"mac+ctrl+Backspace\",\n                                    \"Delete\",\n                                    \"ctrl+Delete\",\n                                    \"shift+Delete\",\n                                    \"mac+Delete\"\n                                ],\n                                proto1.delete\n                            ],\n                            [\n                                [\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto1.unselectAll\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -small1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        -big1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        small1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        big1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -small1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        -big1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        small1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto1.translateSelectedEditors,\n                                {\n                                    args: [\n                                        0,\n                                        big1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ]\n                        ]));\n                    }\n                    constructor(container1, viewer1, altTextManager1, eventBus1, pdfDocument1, pageColors1){\n                        this.#activeEditor = null;\n                        this.#allEditors = new Map();\n                        this.#allLayers = new Map();\n                        this.#altTextManager = null;\n                        this.#annotationStorage = null;\n                        this.#commandManager = new CommandManager1();\n                        this.#currentPageIndex = 0;\n                        this.#deletedAnnotationsElementIds = new Set();\n                        this.#draggingEditors = null;\n                        this.#editorTypes = null;\n                        this.#editorsToRescale = new Set();\n                        this.#filterFactory = null;\n                        this.#idManager = new IdManager1();\n                        this.#isEnabled = false;\n                        this.#isWaiting = false;\n                        this.#lastActiveElement = null;\n                        this.#mode = _util1.AnnotationEditorType.NONE;\n                        this.#selectedEditors = new Set();\n                        this.#pageColors = null;\n                        this.#boundBlur = this.blur.bind(this);\n                        this.#boundFocus = this.focus.bind(this);\n                        this.#boundCopy = this.copy.bind(this);\n                        this.#boundCut = this.cut.bind(this);\n                        this.#boundPaste = this.paste.bind(this);\n                        this.#boundKeydown = this.keydown.bind(this);\n                        this.#boundOnEditingAction = this.onEditingAction.bind(this);\n                        this.#boundOnPageChanging = this.onPageChanging.bind(this);\n                        this.#boundOnScaleChanging = this.onScaleChanging.bind(this);\n                        this.#boundOnRotationChanging = this.onRotationChanging.bind(this);\n                        this.#previousStates = {\n                            isEditing: false,\n                            isEmpty: true,\n                            hasSomethingToUndo: false,\n                            hasSomethingToRedo: false,\n                            hasSelectedEditor: false\n                        };\n                        this.#translation = [\n                            0,\n                            0\n                        ];\n                        this.#translationTimeoutId = null;\n                        this.#container = null;\n                        this.#viewer = null;\n                        this.#container = container1;\n                        this.#viewer = viewer1;\n                        this.#altTextManager = altTextManager1;\n                        this._eventBus = eventBus1;\n                        this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n                        this.#annotationStorage = pdfDocument1.annotationStorage;\n                        this.#filterFactory = pdfDocument1.filterFactory;\n                        this.#pageColors = pageColors1;\n                        this.viewParameters = {\n                            realScale: _display_utils1.PixelsPerInch.PDF_TO_CSS_UNITS,\n                            rotation: 0\n                        };\n                    }\n                    destroy() {\n                        this.#removeKeyboardManager();\n                        this.#removeFocusManager();\n                        this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n                        this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n                        this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n                        this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n                        for (const layer1 of this.#allLayers.values()){\n                            layer1.destroy();\n                        }\n                        this.#allLayers.clear();\n                        this.#allEditors.clear();\n                        this.#editorsToRescale.clear();\n                        this.#activeEditor = null;\n                        this.#selectedEditors.clear();\n                        this.#commandManager.destroy();\n                        this.#altTextManager.destroy();\n                    }\n                    get hcmFilter() {\n                        return (0, _util1.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n                    }\n                    get direction() {\n                        return (0, _util1.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n                    }\n                    editAltText(editor1) {\n                        this.#altTextManager?.editAltText(this, editor1);\n                    }\n                    onPageChanging({ pageNumber: pageNumber1 }) {\n                        this.#currentPageIndex = pageNumber1 - 1;\n                    }\n                    focusMainContainer() {\n                        this.#container.focus();\n                    }\n                    findParent(x4, y4) {\n                        for (const layer1 of this.#allLayers.values()){\n                            const { x: layerX1, y: layerY1, width: width2, height: height1 } = layer1.div.getBoundingClientRect();\n                            if (x4 >= layerX1 && x4 <= layerX1 + width2 && y4 >= layerY1 && y4 <= layerY1 + height1) {\n                                return layer1;\n                            }\n                        }\n                        return null;\n                    }\n                    disableUserSelect(value1 = false) {\n                        this.#viewer.classList.toggle(\"noUserSelect\", value1);\n                    }\n                    addShouldRescale(editor1) {\n                        this.#editorsToRescale.add(editor1);\n                    }\n                    removeShouldRescale(editor1) {\n                        this.#editorsToRescale.delete(editor1);\n                    }\n                    onScaleChanging({ scale: scale1 }) {\n                        this.commitOrRemove();\n                        this.viewParameters.realScale = scale1 * _display_utils1.PixelsPerInch.PDF_TO_CSS_UNITS;\n                        for (const editor1 of this.#editorsToRescale){\n                            editor1.onScaleChanging();\n                        }\n                    }\n                    onRotationChanging({ pagesRotation: pagesRotation1 }) {\n                        this.commitOrRemove();\n                        this.viewParameters.rotation = pagesRotation1;\n                    }\n                    addToAnnotationStorage(editor1) {\n                        if (!editor1.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor1.id)) {\n                            this.#annotationStorage.setValue(editor1.id, editor1);\n                        }\n                    }\n                    #addFocusManager() {\n                        window.addEventListener(\"focus\", this.#boundFocus);\n                        window.addEventListener(\"blur\", this.#boundBlur);\n                    }\n                    #removeFocusManager() {\n                        window.removeEventListener(\"focus\", this.#boundFocus);\n                        window.removeEventListener(\"blur\", this.#boundBlur);\n                    }\n                    blur() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const { activeElement: activeElement1 } = document;\n                        for (const editor1 of this.#selectedEditors){\n                            if (editor1.div.contains(activeElement1)) {\n                                this.#lastActiveElement = [\n                                    editor1,\n                                    activeElement1\n                                ];\n                                editor1._focusEventsAllowed = false;\n                                break;\n                            }\n                        }\n                    }\n                    focus() {\n                        if (!this.#lastActiveElement) {\n                            return;\n                        }\n                        const [lastEditor1, lastActiveElement1] = this.#lastActiveElement;\n                        this.#lastActiveElement = null;\n                        lastActiveElement1.addEventListener(\"focusin\", ()=>{\n                            lastEditor1._focusEventsAllowed = true;\n                        }, {\n                            once: true\n                        });\n                        lastActiveElement1.focus();\n                    }\n                    #addKeyboardManager() {\n                        window.addEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #removeKeyboardManager() {\n                        window.removeEventListener(\"keydown\", this.#boundKeydown, {\n                            capture: true\n                        });\n                    }\n                    #addCopyPasteListeners() {\n                        document.addEventListener(\"copy\", this.#boundCopy);\n                        document.addEventListener(\"cut\", this.#boundCut);\n                        document.addEventListener(\"paste\", this.#boundPaste);\n                    }\n                    #removeCopyPasteListeners() {\n                        document.removeEventListener(\"copy\", this.#boundCopy);\n                        document.removeEventListener(\"cut\", this.#boundCut);\n                        document.removeEventListener(\"paste\", this.#boundPaste);\n                    }\n                    addEditListeners() {\n                        this.#addKeyboardManager();\n                        this.#addCopyPasteListeners();\n                    }\n                    removeEditListeners() {\n                        this.#removeKeyboardManager();\n                        this.#removeCopyPasteListeners();\n                    }\n                    copy(event1) {\n                        event1.preventDefault();\n                        this.#activeEditor?.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors1 = [];\n                        for (const editor1 of this.#selectedEditors){\n                            const serialized1 = editor1.serialize(true);\n                            if (serialized1) {\n                                editors1.push(serialized1);\n                            }\n                        }\n                        if (editors1.length === 0) {\n                            return;\n                        }\n                        event1.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors1));\n                    }\n                    cut(event1) {\n                        this.copy(event1);\n                        this.delete();\n                    }\n                    paste(event1) {\n                        event1.preventDefault();\n                        const { clipboardData: clipboardData1 } = event1;\n                        for (const item1 of clipboardData1.items){\n                            for (const editorType1 of this.#editorTypes){\n                                if (editorType1.isHandlingMimeForPasting(item1.type)) {\n                                    editorType1.paste(item1, this.currentLayer);\n                                    return;\n                                }\n                            }\n                        }\n                        let data1 = clipboardData1.getData(\"application/pdfjs\");\n                        if (!data1) {\n                            return;\n                        }\n                        try {\n                            data1 = JSON.parse(data1);\n                        } catch (ex1) {\n                            (0, _util1.warn)(`paste: \"${ex1.message}\".`);\n                            return;\n                        }\n                        if (!Array.isArray(data1)) {\n                            return;\n                        }\n                        this.unselectAll();\n                        const layer1 = this.currentLayer;\n                        try {\n                            const newEditors1 = [];\n                            for (const editor1 of data1){\n                                const deserializedEditor1 = layer1.deserialize(editor1);\n                                if (!deserializedEditor1) {\n                                    return;\n                                }\n                                newEditors1.push(deserializedEditor1);\n                            }\n                            const cmd1 = ()=>{\n                                for (const editor1 of newEditors1){\n                                    this.#addEditorToLayer(editor1);\n                                }\n                                this.#selectEditors(newEditors1);\n                            };\n                            const undo1 = ()=>{\n                                for (const editor1 of newEditors1){\n                                    editor1.remove();\n                                }\n                            };\n                            this.addCommands({\n                                cmd: cmd1,\n                                undo: undo1,\n                                mustExec: true\n                            });\n                        } catch (ex1) {\n                            (0, _util1.warn)(`paste: \"${ex1.message}\".`);\n                        }\n                    }\n                    keydown(event1) {\n                        if (!this.getActive()?.shouldGetKeyboardEvents()) {\n                            AnnotationEditorUIManager1._keyboardManager.exec(this, event1);\n                        }\n                    }\n                    onEditingAction(details1) {\n                        if ([\n                            \"undo\",\n                            \"redo\",\n                            \"delete\",\n                            \"selectAll\"\n                        ].includes(details1.name)) {\n                            this[details1.name]();\n                        }\n                    }\n                    #dispatchUpdateStates(details1) {\n                        const hasChanged1 = Object.entries(details1).some(([key1, value1])=>this.#previousStates[key1] !== value1);\n                        if (hasChanged1) {\n                            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                                source: this,\n                                details: Object.assign(this.#previousStates, details1)\n                            });\n                        }\n                    }\n                    #dispatchUpdateUI(details1) {\n                        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n                            source: this,\n                            details: details1\n                        });\n                    }\n                    setEditingState(isEditing1) {\n                        if (isEditing1) {\n                            this.#addFocusManager();\n                            this.#addKeyboardManager();\n                            this.#addCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: this.#mode !== _util1.AnnotationEditorType.NONE,\n                                isEmpty: this.#isEmpty(),\n                                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                                hasSelectedEditor: false\n                            });\n                        } else {\n                            this.#removeFocusManager();\n                            this.#removeKeyboardManager();\n                            this.#removeCopyPasteListeners();\n                            this.#dispatchUpdateStates({\n                                isEditing: false\n                            });\n                            this.disableUserSelect(false);\n                        }\n                    }\n                    registerEditorTypes(types1) {\n                        if (this.#editorTypes) {\n                            return;\n                        }\n                        this.#editorTypes = types1;\n                        for (const editorType1 of this.#editorTypes){\n                            this.#dispatchUpdateUI(editorType1.defaultPropertiesToUpdate);\n                        }\n                    }\n                    getId() {\n                        return this.#idManager.getId();\n                    }\n                    get currentLayer() {\n                        return this.#allLayers.get(this.#currentPageIndex);\n                    }\n                    getLayer(pageIndex1) {\n                        return this.#allLayers.get(pageIndex1);\n                    }\n                    get currentPageIndex() {\n                        return this.#currentPageIndex;\n                    }\n                    addLayer(layer1) {\n                        this.#allLayers.set(layer1.pageIndex, layer1);\n                        if (this.#isEnabled) {\n                            layer1.enable();\n                        } else {\n                            layer1.disable();\n                        }\n                    }\n                    removeLayer(layer1) {\n                        this.#allLayers.delete(layer1.pageIndex);\n                    }\n                    updateMode(mode1, editId1 = null) {\n                        if (this.#mode === mode1) {\n                            return;\n                        }\n                        this.#mode = mode1;\n                        if (mode1 === _util1.AnnotationEditorType.NONE) {\n                            this.setEditingState(false);\n                            this.#disableAll();\n                            return;\n                        }\n                        this.setEditingState(true);\n                        this.#enableAll();\n                        this.unselectAll();\n                        for (const layer1 of this.#allLayers.values()){\n                            layer1.updateMode(mode1);\n                        }\n                        if (!editId1) {\n                            return;\n                        }\n                        for (const editor1 of this.#allEditors.values()){\n                            if (editor1.annotationElementId === editId1) {\n                                this.setSelected(editor1);\n                                editor1.enterInEditMode();\n                                break;\n                            }\n                        }\n                    }\n                    updateToolbar(mode1) {\n                        if (mode1 === this.#mode) {\n                            return;\n                        }\n                        this._eventBus.dispatch(\"switchannotationeditormode\", {\n                            source: this,\n                            mode: mode1\n                        });\n                    }\n                    updateParams(type1, value1) {\n                        if (!this.#editorTypes) {\n                            return;\n                        }\n                        if (type1 === _util1.AnnotationEditorParamsType.CREATE) {\n                            this.currentLayer.addNewEditor(type1);\n                            return;\n                        }\n                        for (const editor1 of this.#selectedEditors){\n                            editor1.updateParams(type1, value1);\n                        }\n                        for (const editorType1 of this.#editorTypes){\n                            editorType1.updateDefaultParams(type1, value1);\n                        }\n                    }\n                    enableWaiting(mustWait1 = false) {\n                        if (this.#isWaiting === mustWait1) {\n                            return;\n                        }\n                        this.#isWaiting = mustWait1;\n                        for (const layer1 of this.#allLayers.values()){\n                            if (mustWait1) {\n                                layer1.disableClick();\n                            } else {\n                                layer1.enableClick();\n                            }\n                            layer1.div.classList.toggle(\"waiting\", mustWait1);\n                        }\n                    }\n                    #enableAll() {\n                        if (!this.#isEnabled) {\n                            this.#isEnabled = true;\n                            for (const layer1 of this.#allLayers.values()){\n                                layer1.enable();\n                            }\n                        }\n                    }\n                    #disableAll() {\n                        this.unselectAll();\n                        if (this.#isEnabled) {\n                            this.#isEnabled = false;\n                            for (const layer1 of this.#allLayers.values()){\n                                layer1.disable();\n                            }\n                        }\n                    }\n                    getEditors(pageIndex1) {\n                        const editors1 = [];\n                        for (const editor1 of this.#allEditors.values()){\n                            if (editor1.pageIndex === pageIndex1) {\n                                editors1.push(editor1);\n                            }\n                        }\n                        return editors1;\n                    }\n                    getEditor(id1) {\n                        return this.#allEditors.get(id1);\n                    }\n                    addEditor(editor1) {\n                        this.#allEditors.set(editor1.id, editor1);\n                    }\n                    removeEditor(editor1) {\n                        this.#allEditors.delete(editor1.id);\n                        this.unselect(editor1);\n                        if (!editor1.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor1.annotationElementId)) {\n                            this.#annotationStorage?.remove(editor1.id);\n                        }\n                    }\n                    addDeletedAnnotationElement(editor1) {\n                        this.#deletedAnnotationsElementIds.add(editor1.annotationElementId);\n                        editor1.deleted = true;\n                    }\n                    isDeletedAnnotationElement(annotationElementId1) {\n                        return this.#deletedAnnotationsElementIds.has(annotationElementId1);\n                    }\n                    removeDeletedAnnotationElement(editor1) {\n                        this.#deletedAnnotationsElementIds.delete(editor1.annotationElementId);\n                        editor1.deleted = false;\n                    }\n                    #addEditorToLayer(editor1) {\n                        const layer1 = this.#allLayers.get(editor1.pageIndex);\n                        if (layer1) {\n                            layer1.addOrRebuild(editor1);\n                        } else {\n                            this.addEditor(editor1);\n                        }\n                    }\n                    setActiveEditor(editor1) {\n                        if (this.#activeEditor === editor1) {\n                            return;\n                        }\n                        this.#activeEditor = editor1;\n                        if (editor1) {\n                            this.#dispatchUpdateUI(editor1.propertiesToUpdate);\n                        }\n                    }\n                    toggleSelected(editor1) {\n                        if (this.#selectedEditors.has(editor1)) {\n                            this.#selectedEditors.delete(editor1);\n                            editor1.unselect();\n                            this.#dispatchUpdateStates({\n                                hasSelectedEditor: this.hasSelection\n                            });\n                            return;\n                        }\n                        this.#selectedEditors.add(editor1);\n                        editor1.select();\n                        this.#dispatchUpdateUI(editor1.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    setSelected(editor1) {\n                        for (const ed1 of this.#selectedEditors){\n                            if (ed1 !== editor1) {\n                                ed1.unselect();\n                            }\n                        }\n                        this.#selectedEditors.clear();\n                        this.#selectedEditors.add(editor1);\n                        editor1.select();\n                        this.#dispatchUpdateUI(editor1.propertiesToUpdate);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    isSelected(editor1) {\n                        return this.#selectedEditors.has(editor1);\n                    }\n                    unselect(editor1) {\n                        editor1.unselect();\n                        this.#selectedEditors.delete(editor1);\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: this.hasSelection\n                        });\n                    }\n                    get hasSelection() {\n                        return this.#selectedEditors.size !== 0;\n                    }\n                    undo() {\n                        this.#commandManager.undo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                            hasSomethingToRedo: true,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    redo() {\n                        this.#commandManager.redo();\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    addCommands(params1) {\n                        this.#commandManager.add(params1);\n                        this.#dispatchUpdateStates({\n                            hasSomethingToUndo: true,\n                            hasSomethingToRedo: false,\n                            isEmpty: this.#isEmpty()\n                        });\n                    }\n                    #isEmpty() {\n                        if (this.#allEditors.size === 0) {\n                            return true;\n                        }\n                        if (this.#allEditors.size === 1) {\n                            for (const editor1 of this.#allEditors.values()){\n                                return editor1.isEmpty();\n                            }\n                        }\n                        return false;\n                    }\n                    delete() {\n                        this.commitOrRemove();\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        const editors1 = [\n                            ...this.#selectedEditors\n                        ];\n                        const cmd1 = ()=>{\n                            for (const editor1 of editors1){\n                                editor1.remove();\n                            }\n                        };\n                        const undo1 = ()=>{\n                            for (const editor1 of editors1){\n                                this.#addEditorToLayer(editor1);\n                            }\n                        };\n                        this.addCommands({\n                            cmd: cmd1,\n                            undo: undo1,\n                            mustExec: true\n                        });\n                    }\n                    commitOrRemove() {\n                        this.#activeEditor?.commitOrRemove();\n                    }\n                    hasSomethingToControl() {\n                        return this.#activeEditor || this.hasSelection;\n                    }\n                    #selectEditors(editors1) {\n                        this.#selectedEditors.clear();\n                        for (const editor1 of editors1){\n                            if (editor1.isEmpty()) {\n                                continue;\n                            }\n                            this.#selectedEditors.add(editor1);\n                            editor1.select();\n                        }\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: true\n                        });\n                    }\n                    selectAll() {\n                        for (const editor1 of this.#selectedEditors){\n                            editor1.commit();\n                        }\n                        this.#selectEditors(this.#allEditors.values());\n                    }\n                    unselectAll() {\n                        if (this.#activeEditor) {\n                            this.#activeEditor.commitOrRemove();\n                            return;\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        for (const editor1 of this.#selectedEditors){\n                            editor1.unselect();\n                        }\n                        this.#selectedEditors.clear();\n                        this.#dispatchUpdateStates({\n                            hasSelectedEditor: false\n                        });\n                    }\n                    translateSelectedEditors(x4, y4, noCommit1 = false) {\n                        if (!noCommit1) {\n                            this.commitOrRemove();\n                        }\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.#translation[0] += x4;\n                        this.#translation[1] += y4;\n                        const [totalX1, totalY1] = this.#translation;\n                        const editors1 = [\n                            ...this.#selectedEditors\n                        ];\n                        const TIME_TO_WAIT1 = 1000;\n                        if (this.#translationTimeoutId) {\n                            clearTimeout(this.#translationTimeoutId);\n                        }\n                        this.#translationTimeoutId = setTimeout(()=>{\n                            this.#translationTimeoutId = null;\n                            this.#translation[0] = this.#translation[1] = 0;\n                            this.addCommands({\n                                cmd: ()=>{\n                                    for (const editor1 of editors1){\n                                        if (this.#allEditors.has(editor1.id)) {\n                                            editor1.translateInPage(totalX1, totalY1);\n                                        }\n                                    }\n                                },\n                                undo: ()=>{\n                                    for (const editor1 of editors1){\n                                        if (this.#allEditors.has(editor1.id)) {\n                                            editor1.translateInPage(-totalX1, -totalY1);\n                                        }\n                                    }\n                                },\n                                mustExec: false\n                            });\n                        }, TIME_TO_WAIT1);\n                        for (const editor1 of editors1){\n                            editor1.translateInPage(x4, y4);\n                        }\n                    }\n                    setUpDragSession() {\n                        if (!this.hasSelection) {\n                            return;\n                        }\n                        this.disableUserSelect(true);\n                        this.#draggingEditors = new Map();\n                        for (const editor1 of this.#selectedEditors){\n                            this.#draggingEditors.set(editor1, {\n                                savedX: editor1.x,\n                                savedY: editor1.y,\n                                savedPageIndex: editor1.pageIndex,\n                                newX: 0,\n                                newY: 0,\n                                newPageIndex: -1\n                            });\n                        }\n                    }\n                    endDragSession() {\n                        if (!this.#draggingEditors) {\n                            return false;\n                        }\n                        this.disableUserSelect(false);\n                        const map1 = this.#draggingEditors;\n                        this.#draggingEditors = null;\n                        let mustBeAddedInUndoStack1 = false;\n                        for (const [{ x: x4, y: y4, pageIndex: pageIndex1 }, value1] of map1){\n                            value1.newX = x4;\n                            value1.newY = y4;\n                            value1.newPageIndex = pageIndex1;\n                            mustBeAddedInUndoStack1 ||= x4 !== value1.savedX || y4 !== value1.savedY || pageIndex1 !== value1.savedPageIndex;\n                        }\n                        if (!mustBeAddedInUndoStack1) {\n                            return false;\n                        }\n                        const move1 = (editor1, x4, y4, pageIndex1)=>{\n                            if (this.#allEditors.has(editor1.id)) {\n                                const parent1 = this.#allLayers.get(pageIndex1);\n                                if (parent1) {\n                                    editor1._setParentAndPosition(parent1, x4, y4);\n                                } else {\n                                    editor1.pageIndex = pageIndex1;\n                                    editor1.x = x4;\n                                    editor1.y = y4;\n                                }\n                            }\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                for (const [editor1, { newX: newX1, newY: newY1, newPageIndex: newPageIndex1 }] of map1){\n                                    move1(editor1, newX1, newY1, newPageIndex1);\n                                }\n                            },\n                            undo: ()=>{\n                                for (const [editor1, { savedX: savedX1, savedY: savedY1, savedPageIndex: savedPageIndex1 }] of map1){\n                                    move1(editor1, savedX1, savedY1, savedPageIndex1);\n                                }\n                            },\n                            mustExec: true\n                        });\n                        return true;\n                    }\n                    dragSelectedEditors(tx2, ty2) {\n                        if (!this.#draggingEditors) {\n                            return;\n                        }\n                        for (const editor1 of this.#draggingEditors.keys()){\n                            editor1.drag(tx2, ty2);\n                        }\n                    }\n                    rebuild(editor1) {\n                        if (editor1.parent === null) {\n                            const parent1 = this.getLayer(editor1.pageIndex);\n                            if (parent1) {\n                                parent1.changeParent(editor1);\n                                parent1.addOrRebuild(editor1);\n                            } else {\n                                this.addEditor(editor1);\n                                this.addToAnnotationStorage(editor1);\n                                editor1.rebuild();\n                            }\n                        } else {\n                            editor1.parent.addOrRebuild(editor1);\n                        }\n                    }\n                    isActive(editor1) {\n                        return this.#activeEditor === editor1;\n                    }\n                    getActive() {\n                        return this.#activeEditor;\n                    }\n                    getMode() {\n                        return this.#mode;\n                    }\n                    get imageManager() {\n                        return (0, _util1.shadow)(this, \"imageManager\", new ImageManager1());\n                    }\n                }\n                exports1.AnnotationEditorUIManager = AnnotationEditorUIManager1;\n            /***/ },\n            /* 6 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StatTimer = exports1.RenderingCancelledException = exports1.PixelsPerInch = exports1.PageViewport = exports1.PDFDateString = exports1.DOMStandardFontDataFactory = exports1.DOMSVGFactory = exports1.DOMFilterFactory = exports1.DOMCanvasFactory = exports1.DOMCMapReaderFactory = void 0;\n                exports1.deprecated = deprecated1;\n                exports1.getColorValues = getColorValues1;\n                exports1.getCurrentTransform = getCurrentTransform1;\n                exports1.getCurrentTransformInverse = getCurrentTransformInverse1;\n                exports1.getFilenameFromUrl = getFilenameFromUrl1;\n                exports1.getPdfFilenameFromUrl = getPdfFilenameFromUrl1;\n                exports1.getRGB = getRGB1;\n                exports1.getXfaPageViewport = getXfaPageViewport1;\n                exports1.isDataScheme = isDataScheme1;\n                exports1.isPdfFile = isPdfFile1;\n                exports1.isValidFetchUrl = isValidFetchUrl1;\n                exports1.loadScript = loadScript1;\n                exports1.noContextMenu = noContextMenu1;\n                exports1.setLayerDimensions = setLayerDimensions1;\n                var _base_factory1 = __w_pdfjs_require__1(7);\n                var _util1 = __w_pdfjs_require__1(1);\n                const SVG_NS1 = \"http://www.w3.org/2000/svg\";\n                class PixelsPerInch1 {\n                    static{\n                        this.CSS = 96.0;\n                    }\n                    static{\n                        this.PDF = 72.0;\n                    }\n                    static{\n                        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n                    }\n                }\n                exports1.PixelsPerInch = PixelsPerInch1;\n                class DOMFilterFactory1 extends _base_factory1.BaseFilterFactory {\n                    #_cache;\n                    #_defs;\n                    #docId;\n                    #document;\n                    #hcmFilter;\n                    #hcmKey;\n                    #hcmUrl;\n                    #hcmHighlightFilter;\n                    #hcmHighlightKey;\n                    #hcmHighlightUrl;\n                    #id;\n                    constructor({ docId: docId1, ownerDocument: ownerDocument1 = globalThis.document } = {}){\n                        super();\n                        this.#id = 0;\n                        this.#docId = docId1;\n                        this.#document = ownerDocument1;\n                    }\n                    get #cache() {\n                        return this.#_cache ||= new Map();\n                    }\n                    get #defs() {\n                        if (!this.#_defs) {\n                            const div1 = this.#document.createElement(\"div\");\n                            const { style: style1 } = div1;\n                            style1.visibility = \"hidden\";\n                            style1.contain = \"strict\";\n                            style1.width = style1.height = 0;\n                            style1.position = \"absolute\";\n                            style1.top = style1.left = 0;\n                            style1.zIndex = -1;\n                            const svg1 = this.#document.createElementNS(SVG_NS1, \"svg\");\n                            svg1.setAttribute(\"width\", 0);\n                            svg1.setAttribute(\"height\", 0);\n                            this.#_defs = this.#document.createElementNS(SVG_NS1, \"defs\");\n                            div1.append(svg1);\n                            svg1.append(this.#_defs);\n                            this.#document.body.append(div1);\n                        }\n                        return this.#_defs;\n                    }\n                    addFilter(maps1) {\n                        if (!maps1) {\n                            return \"none\";\n                        }\n                        let value1 = this.#cache.get(maps1);\n                        if (value1) {\n                            return value1;\n                        }\n                        let tableR1, tableG1, tableB1, key1;\n                        if (maps1.length === 1) {\n                            const mapR1 = maps1[0];\n                            const buffer1 = new Array(256);\n                            for(let i1 = 0; i1 < 256; i1++){\n                                buffer1[i1] = mapR1[i1] / 255;\n                            }\n                            key1 = tableR1 = tableG1 = tableB1 = buffer1.join(\",\");\n                        } else {\n                            const [mapR1, mapG1, mapB1] = maps1;\n                            const bufferR1 = new Array(256);\n                            const bufferG1 = new Array(256);\n                            const bufferB1 = new Array(256);\n                            for(let i1 = 0; i1 < 256; i1++){\n                                bufferR1[i1] = mapR1[i1] / 255;\n                                bufferG1[i1] = mapG1[i1] / 255;\n                                bufferB1[i1] = mapB1[i1] / 255;\n                            }\n                            tableR1 = bufferR1.join(\",\");\n                            tableG1 = bufferG1.join(\",\");\n                            tableB1 = bufferB1.join(\",\");\n                            key1 = `${tableR1}${tableG1}${tableB1}`;\n                        }\n                        value1 = this.#cache.get(key1);\n                        if (value1) {\n                            this.#cache.set(maps1, value1);\n                            return value1;\n                        }\n                        const id1 = `g_${this.#docId}_transfer_map_${this.#id++}`;\n                        const url1 = `url(#${id1})`;\n                        this.#cache.set(maps1, url1);\n                        this.#cache.set(key1, url1);\n                        const filter1 = this.#createFilter(id1);\n                        this.#addTransferMapConversion(tableR1, tableG1, tableB1, filter1);\n                        return url1;\n                    }\n                    addHCMFilter(fgColor1, bgColor1) {\n                        const key1 = `${fgColor1}-${bgColor1}`;\n                        if (this.#hcmKey === key1) {\n                            return this.#hcmUrl;\n                        }\n                        this.#hcmKey = key1;\n                        this.#hcmUrl = \"none\";\n                        this.#hcmFilter?.remove();\n                        if (!fgColor1 || !bgColor1) {\n                            return this.#hcmUrl;\n                        }\n                        const fgRGB1 = this.#getRGB(fgColor1);\n                        fgColor1 = _util1.Util.makeHexColor(...fgRGB1);\n                        const bgRGB1 = this.#getRGB(bgColor1);\n                        bgColor1 = _util1.Util.makeHexColor(...bgRGB1);\n                        this.#defs.style.color = \"\";\n                        if (fgColor1 === \"#000000\" && bgColor1 === \"#ffffff\" || fgColor1 === bgColor1) {\n                            return this.#hcmUrl;\n                        }\n                        const map1 = new Array(256);\n                        for(let i1 = 0; i1 <= 255; i1++){\n                            const x4 = i1 / 255;\n                            map1[i1] = x4 <= 0.03928 ? x4 / 12.92 : ((x4 + 0.055) / 1.055) ** 2.4;\n                        }\n                        const table1 = map1.join(\",\");\n                        const id1 = `g_${this.#docId}_hcm_filter`;\n                        const filter1 = this.#hcmHighlightFilter = this.#createFilter(id1);\n                        this.#addTransferMapConversion(table1, table1, table1, filter1);\n                        this.#addGrayConversion(filter1);\n                        const getSteps1 = (c4, n1)=>{\n                            const start1 = fgRGB1[c4] / 255;\n                            const end1 = bgRGB1[c4] / 255;\n                            const arr3 = new Array(n1 + 1);\n                            for(let i1 = 0; i1 <= n1; i1++){\n                                arr3[i1] = start1 + i1 / n1 * (end1 - start1);\n                            }\n                            return arr3.join(\",\");\n                        };\n                        this.#addTransferMapConversion(getSteps1(0, 5), getSteps1(1, 5), getSteps1(2, 5), filter1);\n                        this.#hcmUrl = `url(#${id1})`;\n                        return this.#hcmUrl;\n                    }\n                    addHighlightHCMFilter(fgColor1, bgColor1, newFgColor1, newBgColor1) {\n                        const key1 = `${fgColor1}-${bgColor1}-${newFgColor1}-${newBgColor1}`;\n                        if (this.#hcmHighlightKey === key1) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        this.#hcmHighlightKey = key1;\n                        this.#hcmHighlightUrl = \"none\";\n                        this.#hcmHighlightFilter?.remove();\n                        if (!fgColor1 || !bgColor1) {\n                            return this.#hcmHighlightUrl;\n                        }\n                        const [fgRGB1, bgRGB1] = [\n                            fgColor1,\n                            bgColor1\n                        ].map(this.#getRGB.bind(this));\n                        let fgGray1 = Math.round(0.2126 * fgRGB1[0] + 0.7152 * fgRGB1[1] + 0.0722 * fgRGB1[2]);\n                        let bgGray1 = Math.round(0.2126 * bgRGB1[0] + 0.7152 * bgRGB1[1] + 0.0722 * bgRGB1[2]);\n                        let [newFgRGB1, newBgRGB1] = [\n                            newFgColor1,\n                            newBgColor1\n                        ].map(this.#getRGB.bind(this));\n                        if (bgGray1 < fgGray1) {\n                            [fgGray1, bgGray1, newFgRGB1, newBgRGB1] = [\n                                bgGray1,\n                                fgGray1,\n                                newBgRGB1,\n                                newFgRGB1\n                            ];\n                        }\n                        this.#defs.style.color = \"\";\n                        const getSteps1 = (fg1, bg1, n1)=>{\n                            const arr3 = new Array(256);\n                            const step1 = (bgGray1 - fgGray1) / n1;\n                            const newStart1 = fg1 / 255;\n                            const newStep1 = (bg1 - fg1) / (255 * n1);\n                            let prev1 = 0;\n                            for(let i1 = 0; i1 <= n1; i1++){\n                                const k3 = Math.round(fgGray1 + i1 * step1);\n                                const value1 = newStart1 + i1 * newStep1;\n                                for(let j1 = prev1; j1 <= k3; j1++){\n                                    arr3[j1] = value1;\n                                }\n                                prev1 = k3 + 1;\n                            }\n                            for(let i1 = prev1; i1 < 256; i1++){\n                                arr3[i1] = arr3[prev1 - 1];\n                            }\n                            return arr3.join(\",\");\n                        };\n                        const id1 = `g_${this.#docId}_hcm_highlight_filter`;\n                        const filter1 = this.#hcmHighlightFilter = this.#createFilter(id1);\n                        this.#addGrayConversion(filter1);\n                        this.#addTransferMapConversion(getSteps1(newFgRGB1[0], newBgRGB1[0], 5), getSteps1(newFgRGB1[1], newBgRGB1[1], 5), getSteps1(newFgRGB1[2], newBgRGB1[2], 5), filter1);\n                        this.#hcmHighlightUrl = `url(#${id1})`;\n                        return this.#hcmHighlightUrl;\n                    }\n                    destroy(keepHCM1 = false) {\n                        if (keepHCM1 && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n                            return;\n                        }\n                        if (this.#_defs) {\n                            this.#_defs.parentNode.parentNode.remove();\n                            this.#_defs = null;\n                        }\n                        if (this.#_cache) {\n                            this.#_cache.clear();\n                            this.#_cache = null;\n                        }\n                        this.#id = 0;\n                    }\n                    #addGrayConversion(filter1) {\n                        const feColorMatrix1 = this.#document.createElementNS(SVG_NS1, \"feColorMatrix\");\n                        feColorMatrix1.setAttribute(\"type\", \"matrix\");\n                        feColorMatrix1.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n                        filter1.append(feColorMatrix1);\n                    }\n                    #createFilter(id1) {\n                        const filter1 = this.#document.createElementNS(SVG_NS1, \"filter\");\n                        filter1.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n                        filter1.setAttribute(\"id\", id1);\n                        this.#defs.append(filter1);\n                        return filter1;\n                    }\n                    #appendFeFunc(feComponentTransfer1, func1, table1) {\n                        const feFunc1 = this.#document.createElementNS(SVG_NS1, func1);\n                        feFunc1.setAttribute(\"type\", \"discrete\");\n                        feFunc1.setAttribute(\"tableValues\", table1);\n                        feComponentTransfer1.append(feFunc1);\n                    }\n                    #addTransferMapConversion(rTable1, gTable1, bTable1, filter1) {\n                        const feComponentTransfer1 = this.#document.createElementNS(SVG_NS1, \"feComponentTransfer\");\n                        filter1.append(feComponentTransfer1);\n                        this.#appendFeFunc(feComponentTransfer1, \"feFuncR\", rTable1);\n                        this.#appendFeFunc(feComponentTransfer1, \"feFuncG\", gTable1);\n                        this.#appendFeFunc(feComponentTransfer1, \"feFuncB\", bTable1);\n                    }\n                    #getRGB(color1) {\n                        this.#defs.style.color = color1;\n                        return getRGB1(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n                    }\n                }\n                exports1.DOMFilterFactory = DOMFilterFactory1;\n                class DOMCanvasFactory1 extends _base_factory1.BaseCanvasFactory {\n                    constructor({ ownerDocument: ownerDocument1 = globalThis.document } = {}){\n                        super();\n                        this._document = ownerDocument1;\n                    }\n                    _createCanvas(width2, height1) {\n                        const canvas1 = this._document.createElement(\"canvas\");\n                        canvas1.width = width2;\n                        canvas1.height = height1;\n                        return canvas1;\n                    }\n                }\n                exports1.DOMCanvasFactory = DOMCanvasFactory1;\n                async function fetchData1(url1, asTypedArray1 = false) {\n                    if (isValidFetchUrl1(url1, document.baseURI)) {\n                        const response1 = await fetch(url1);\n                        if (!response1.ok) {\n                            throw new Error(response1.statusText);\n                        }\n                        return asTypedArray1 ? new Uint8Array(await response1.arrayBuffer()) : (0, _util1.stringToBytes)(await response1.text());\n                    }\n                    return new Promise((resolve1, reject1)=>{\n                        const request1 = new XMLHttpRequest();\n                        request1.open(\"GET\", url1, true);\n                        if (asTypedArray1) {\n                            request1.responseType = \"arraybuffer\";\n                        }\n                        request1.onreadystatechange = ()=>{\n                            if (request1.readyState !== XMLHttpRequest.DONE) {\n                                return;\n                            }\n                            if (request1.status === 200 || request1.status === 0) {\n                                let data1;\n                                if (asTypedArray1 && request1.response) {\n                                    data1 = new Uint8Array(request1.response);\n                                } else if (!asTypedArray1 && request1.responseText) {\n                                    data1 = (0, _util1.stringToBytes)(request1.responseText);\n                                }\n                                if (data1) {\n                                    resolve1(data1);\n                                    return;\n                                }\n                            }\n                            reject1(new Error(request1.statusText));\n                        };\n                        request1.send(null);\n                    });\n                }\n                class DOMCMapReaderFactory1 extends _base_factory1.BaseCMapReaderFactory {\n                    _fetchData(url1, compressionType1) {\n                        return fetchData1(url1, this.isCompressed).then((data1)=>{\n                            return {\n                                cMapData: data1,\n                                compressionType: compressionType1\n                            };\n                        });\n                    }\n                }\n                exports1.DOMCMapReaderFactory = DOMCMapReaderFactory1;\n                class DOMStandardFontDataFactory1 extends _base_factory1.BaseStandardFontDataFactory {\n                    _fetchData(url1) {\n                        return fetchData1(url1, true);\n                    }\n                }\n                exports1.DOMStandardFontDataFactory = DOMStandardFontDataFactory1;\n                class DOMSVGFactory1 extends _base_factory1.BaseSVGFactory {\n                    _createSVG(type1) {\n                        return document.createElementNS(SVG_NS1, type1);\n                    }\n                }\n                exports1.DOMSVGFactory = DOMSVGFactory1;\n                class PageViewport1 {\n                    constructor({ viewBox: viewBox1, scale: scale1, rotation: rotation1, offsetX: offsetX1 = 0, offsetY: offsetY1 = 0, dontFlip: dontFlip1 = false }){\n                        this.viewBox = viewBox1;\n                        this.scale = scale1;\n                        this.rotation = rotation1;\n                        this.offsetX = offsetX1;\n                        this.offsetY = offsetY1;\n                        const centerX1 = (viewBox1[2] + viewBox1[0]) / 2;\n                        const centerY1 = (viewBox1[3] + viewBox1[1]) / 2;\n                        let rotateA1, rotateB1, rotateC1, rotateD1;\n                        rotation1 %= 360;\n                        if (rotation1 < 0) {\n                            rotation1 += 360;\n                        }\n                        switch(rotation1){\n                            case 180:\n                                rotateA1 = -1;\n                                rotateB1 = 0;\n                                rotateC1 = 0;\n                                rotateD1 = 1;\n                                break;\n                            case 90:\n                                rotateA1 = 0;\n                                rotateB1 = 1;\n                                rotateC1 = 1;\n                                rotateD1 = 0;\n                                break;\n                            case 270:\n                                rotateA1 = 0;\n                                rotateB1 = -1;\n                                rotateC1 = -1;\n                                rotateD1 = 0;\n                                break;\n                            case 0:\n                                rotateA1 = 1;\n                                rotateB1 = 0;\n                                rotateC1 = 0;\n                                rotateD1 = -1;\n                                break;\n                            default:\n                                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n                        }\n                        if (dontFlip1) {\n                            rotateC1 = -rotateC1;\n                            rotateD1 = -rotateD1;\n                        }\n                        let offsetCanvasX1, offsetCanvasY1;\n                        let width2, height1;\n                        if (rotateA1 === 0) {\n                            offsetCanvasX1 = Math.abs(centerY1 - viewBox1[1]) * scale1 + offsetX1;\n                            offsetCanvasY1 = Math.abs(centerX1 - viewBox1[0]) * scale1 + offsetY1;\n                            width2 = (viewBox1[3] - viewBox1[1]) * scale1;\n                            height1 = (viewBox1[2] - viewBox1[0]) * scale1;\n                        } else {\n                            offsetCanvasX1 = Math.abs(centerX1 - viewBox1[0]) * scale1 + offsetX1;\n                            offsetCanvasY1 = Math.abs(centerY1 - viewBox1[1]) * scale1 + offsetY1;\n                            width2 = (viewBox1[2] - viewBox1[0]) * scale1;\n                            height1 = (viewBox1[3] - viewBox1[1]) * scale1;\n                        }\n                        this.transform = [\n                            rotateA1 * scale1,\n                            rotateB1 * scale1,\n                            rotateC1 * scale1,\n                            rotateD1 * scale1,\n                            offsetCanvasX1 - rotateA1 * scale1 * centerX1 - rotateC1 * scale1 * centerY1,\n                            offsetCanvasY1 - rotateB1 * scale1 * centerX1 - rotateD1 * scale1 * centerY1\n                        ];\n                        this.width = width2;\n                        this.height = height1;\n                    }\n                    get rawDims() {\n                        const { viewBox: viewBox1 } = this;\n                        return (0, _util1.shadow)(this, \"rawDims\", {\n                            pageWidth: viewBox1[2] - viewBox1[0],\n                            pageHeight: viewBox1[3] - viewBox1[1],\n                            pageX: viewBox1[0],\n                            pageY: viewBox1[1]\n                        });\n                    }\n                    clone({ scale: scale1 = this.scale, rotation: rotation1 = this.rotation, offsetX: offsetX1 = this.offsetX, offsetY: offsetY1 = this.offsetY, dontFlip: dontFlip1 = false } = {}) {\n                        return new PageViewport1({\n                            viewBox: this.viewBox.slice(),\n                            scale: scale1,\n                            rotation: rotation1,\n                            offsetX: offsetX1,\n                            offsetY: offsetY1,\n                            dontFlip: dontFlip1\n                        });\n                    }\n                    convertToViewportPoint(x4, y4) {\n                        return _util1.Util.applyTransform([\n                            x4,\n                            y4\n                        ], this.transform);\n                    }\n                    convertToViewportRectangle(rect3) {\n                        const topLeft1 = _util1.Util.applyTransform([\n                            rect3[0],\n                            rect3[1]\n                        ], this.transform);\n                        const bottomRight1 = _util1.Util.applyTransform([\n                            rect3[2],\n                            rect3[3]\n                        ], this.transform);\n                        return [\n                            topLeft1[0],\n                            topLeft1[1],\n                            bottomRight1[0],\n                            bottomRight1[1]\n                        ];\n                    }\n                    convertToPdfPoint(x4, y4) {\n                        return _util1.Util.applyInverseTransform([\n                            x4,\n                            y4\n                        ], this.transform);\n                    }\n                }\n                exports1.PageViewport = PageViewport1;\n                class RenderingCancelledException1 extends _util1.BaseException {\n                    constructor(msg1, extraDelay1 = 0){\n                        super(msg1, \"RenderingCancelledException\");\n                        this.extraDelay = extraDelay1;\n                    }\n                }\n                exports1.RenderingCancelledException = RenderingCancelledException1;\n                function isDataScheme1(url1) {\n                    const ii1 = url1.length;\n                    let i1 = 0;\n                    while(i1 < ii1 && url1[i1].trim() === \"\"){\n                        i1++;\n                    }\n                    return url1.substring(i1, i1 + 5).toLowerCase() === \"data:\";\n                }\n                function isPdfFile1(filename1) {\n                    return typeof filename1 === \"string\" && /\\.pdf$/i.test(filename1);\n                }\n                function getFilenameFromUrl1(url1, onlyStripPath1 = false) {\n                    if (!onlyStripPath1) {\n                        [url1] = url1.split(/[#?]/, 1);\n                    }\n                    return url1.substring(url1.lastIndexOf(\"/\") + 1);\n                }\n                function getPdfFilenameFromUrl1(url1, defaultFilename1 = \"document.pdf\") {\n                    if (typeof url1 !== \"string\") {\n                        return defaultFilename1;\n                    }\n                    if (isDataScheme1(url1)) {\n                        (0, _util1.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n                        return defaultFilename1;\n                    }\n                    const reURI1 = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n                    const reFilename1 = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n                    const splitURI1 = reURI1.exec(url1);\n                    let suggestedFilename1 = reFilename1.exec(splitURI1[1]) || reFilename1.exec(splitURI1[2]) || reFilename1.exec(splitURI1[3]);\n                    if (suggestedFilename1) {\n                        suggestedFilename1 = suggestedFilename1[0];\n                        if (suggestedFilename1.includes(\"%\")) {\n                            try {\n                                suggestedFilename1 = reFilename1.exec(decodeURIComponent(suggestedFilename1))[0];\n                            } catch  {}\n                        }\n                    }\n                    return suggestedFilename1 || defaultFilename1;\n                }\n                class StatTimer1 {\n                    time(name1) {\n                        if (name1 in this.started) {\n                            (0, _util1.warn)(`Timer is already running for ${name1}`);\n                        }\n                        this.started[name1] = Date.now();\n                    }\n                    timeEnd(name1) {\n                        if (!(name1 in this.started)) {\n                            (0, _util1.warn)(`Timer has not been started for ${name1}`);\n                        }\n                        this.times.push({\n                            name: name1,\n                            start: this.started[name1],\n                            end: Date.now()\n                        });\n                        delete this.started[name1];\n                    }\n                    toString() {\n                        const outBuf1 = [];\n                        let longest1 = 0;\n                        for (const { name: name1 } of this.times){\n                            longest1 = Math.max(name1.length, longest1);\n                        }\n                        for (const { name: name1, start: start1, end: end1 } of this.times){\n                            outBuf1.push(`${name1.padEnd(longest1)} ${end1 - start1}ms\\n`);\n                        }\n                        return outBuf1.join(\"\");\n                    }\n                    constructor(){\n                        this.started = Object.create(null);\n                        this.times = [];\n                    }\n                }\n                exports1.StatTimer = StatTimer1;\n                function isValidFetchUrl1(url1, baseUrl1) {\n                    try {\n                        const { protocol: protocol1 } = baseUrl1 ? new URL(url1, baseUrl1) : new URL(url1);\n                        return protocol1 === \"http:\" || protocol1 === \"https:\";\n                    } catch  {\n                        return false;\n                    }\n                }\n                function noContextMenu1(e1) {\n                    e1.preventDefault();\n                }\n                function loadScript1(src1, removeScriptElement1 = false) {\n                    return new Promise((resolve1, reject1)=>{\n                        const script1 = document.createElement(\"script\");\n                        script1.src = src1;\n                        script1.onload = function(evt1) {\n                            if (removeScriptElement1) {\n                                script1.remove();\n                            }\n                            resolve1(evt1);\n                        };\n                        script1.onerror = function() {\n                            reject1(new Error(`Cannot load script at: ${script1.src}`));\n                        };\n                        (document.head || document.documentElement).append(script1);\n                    });\n                }\n                function deprecated1(details1) {\n                    console.log(\"Deprecated API usage: \" + details1);\n                }\n                let pdfDateStringRegex1;\n                class PDFDateString1 {\n                    static toDateObject(input1) {\n                        if (!input1 || typeof input1 !== \"string\") {\n                            return null;\n                        }\n                        pdfDateStringRegex1 ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n                        const matches1 = pdfDateStringRegex1.exec(input1);\n                        if (!matches1) {\n                            return null;\n                        }\n                        const year1 = parseInt(matches1[1], 10);\n                        let month1 = parseInt(matches1[2], 10);\n                        month1 = month1 >= 1 && month1 <= 12 ? month1 - 1 : 0;\n                        let day1 = parseInt(matches1[3], 10);\n                        day1 = day1 >= 1 && day1 <= 31 ? day1 : 1;\n                        let hour1 = parseInt(matches1[4], 10);\n                        hour1 = hour1 >= 0 && hour1 <= 23 ? hour1 : 0;\n                        let minute1 = parseInt(matches1[5], 10);\n                        minute1 = minute1 >= 0 && minute1 <= 59 ? minute1 : 0;\n                        let second1 = parseInt(matches1[6], 10);\n                        second1 = second1 >= 0 && second1 <= 59 ? second1 : 0;\n                        const universalTimeRelation1 = matches1[7] || \"Z\";\n                        let offsetHour1 = parseInt(matches1[8], 10);\n                        offsetHour1 = offsetHour1 >= 0 && offsetHour1 <= 23 ? offsetHour1 : 0;\n                        let offsetMinute1 = parseInt(matches1[9], 10) || 0;\n                        offsetMinute1 = offsetMinute1 >= 0 && offsetMinute1 <= 59 ? offsetMinute1 : 0;\n                        if (universalTimeRelation1 === \"-\") {\n                            hour1 += offsetHour1;\n                            minute1 += offsetMinute1;\n                        } else if (universalTimeRelation1 === \"+\") {\n                            hour1 -= offsetHour1;\n                            minute1 -= offsetMinute1;\n                        }\n                        return new Date(Date.UTC(year1, month1, day1, hour1, minute1, second1));\n                    }\n                }\n                exports1.PDFDateString = PDFDateString1;\n                function getXfaPageViewport1(xfaPage1, { scale: scale1 = 1, rotation: rotation1 = 0 }) {\n                    const { width: width2, height: height1 } = xfaPage1.attributes.style;\n                    const viewBox1 = [\n                        0,\n                        0,\n                        parseInt(width2),\n                        parseInt(height1)\n                    ];\n                    return new PageViewport1({\n                        viewBox: viewBox1,\n                        scale: scale1,\n                        rotation: rotation1\n                    });\n                }\n                function getRGB1(color1) {\n                    if (color1.startsWith(\"#\")) {\n                        const colorRGB1 = parseInt(color1.slice(1), 16);\n                        return [\n                            (colorRGB1 & 0xff0000) >> 16,\n                            (colorRGB1 & 0x00ff00) >> 8,\n                            colorRGB1 & 0x0000ff\n                        ];\n                    }\n                    if (color1.startsWith(\"rgb(\")) {\n                        return color1.slice(4, -1).split(\",\").map((x4)=>parseInt(x4));\n                    }\n                    if (color1.startsWith(\"rgba(\")) {\n                        return color1.slice(5, -1).split(\",\").map((x4)=>parseInt(x4)).slice(0, 3);\n                    }\n                    (0, _util1.warn)(`Not a valid color format: \"${color1}\"`);\n                    return [\n                        0,\n                        0,\n                        0\n                    ];\n                }\n                function getColorValues1(colors1) {\n                    const span1 = document.createElement(\"span\");\n                    span1.style.visibility = \"hidden\";\n                    document.body.append(span1);\n                    for (const name1 of colors1.keys()){\n                        span1.style.color = name1;\n                        const computedColor1 = window.getComputedStyle(span1).color;\n                        colors1.set(name1, getRGB1(computedColor1));\n                    }\n                    span1.remove();\n                }\n                function getCurrentTransform1(ctx1) {\n                    const { a: a1, b: b4, c: c4, d: d5, e: e1, f: f1 } = ctx1.getTransform();\n                    return [\n                        a1,\n                        b4,\n                        c4,\n                        d5,\n                        e1,\n                        f1\n                    ];\n                }\n                function getCurrentTransformInverse1(ctx1) {\n                    const { a: a1, b: b4, c: c4, d: d5, e: e1, f: f1 } = ctx1.getTransform().invertSelf();\n                    return [\n                        a1,\n                        b4,\n                        c4,\n                        d5,\n                        e1,\n                        f1\n                    ];\n                }\n                function setLayerDimensions1(div1, viewport1, mustFlip1 = false, mustRotate1 = true) {\n                    if (viewport1 instanceof PageViewport1) {\n                        const { pageWidth: pageWidth1, pageHeight: pageHeight1 } = viewport1.rawDims;\n                        const { style: style1 } = div1;\n                        const useRound1 = _util1.FeatureTest.isCSSRoundSupported;\n                        const w1 = `var(--scale-factor) * ${pageWidth1}px`, h3 = `var(--scale-factor) * ${pageHeight1}px`;\n                        const widthStr1 = useRound1 ? `round(${w1}, 1px)` : `calc(${w1})`, heightStr1 = useRound1 ? `round(${h3}, 1px)` : `calc(${h3})`;\n                        if (!mustFlip1 || viewport1.rotation % 180 === 0) {\n                            style1.width = widthStr1;\n                            style1.height = heightStr1;\n                        } else {\n                            style1.width = heightStr1;\n                            style1.height = widthStr1;\n                        }\n                    }\n                    if (mustRotate1) {\n                        div1.setAttribute(\"data-main-rotation\", viewport1.rotation);\n                    }\n                }\n            /***/ },\n            /* 7 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.BaseStandardFontDataFactory = exports1.BaseSVGFactory = exports1.BaseFilterFactory = exports1.BaseCanvasFactory = exports1.BaseCMapReaderFactory = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                class BaseFilterFactory1 {\n                    constructor(){\n                        if (this.constructor === BaseFilterFactory1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n                        }\n                    }\n                    addFilter(maps1) {\n                        return \"none\";\n                    }\n                    addHCMFilter(fgColor1, bgColor1) {\n                        return \"none\";\n                    }\n                    addHighlightHCMFilter(fgColor1, bgColor1, newFgColor1, newBgColor1) {\n                        return \"none\";\n                    }\n                    destroy(keepHCM1 = false) {}\n                }\n                exports1.BaseFilterFactory = BaseFilterFactory1;\n                class BaseCanvasFactory1 {\n                    constructor(){\n                        if (this.constructor === BaseCanvasFactory1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n                        }\n                    }\n                    create(width2, height1) {\n                        if (width2 <= 0 || height1 <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        const canvas1 = this._createCanvas(width2, height1);\n                        return {\n                            canvas: canvas1,\n                            context: canvas1.getContext(\"2d\")\n                        };\n                    }\n                    reset(canvasAndContext1, width2, height1) {\n                        if (!canvasAndContext1.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        if (width2 <= 0 || height1 <= 0) {\n                            throw new Error(\"Invalid canvas size\");\n                        }\n                        canvasAndContext1.canvas.width = width2;\n                        canvasAndContext1.canvas.height = height1;\n                    }\n                    destroy(canvasAndContext1) {\n                        if (!canvasAndContext1.canvas) {\n                            throw new Error(\"Canvas is not specified\");\n                        }\n                        canvasAndContext1.canvas.width = 0;\n                        canvasAndContext1.canvas.height = 0;\n                        canvasAndContext1.canvas = null;\n                        canvasAndContext1.context = null;\n                    }\n                    _createCanvas(width2, height1) {\n                        (0, _util1.unreachable)(\"Abstract method `_createCanvas` called.\");\n                    }\n                }\n                exports1.BaseCanvasFactory = BaseCanvasFactory1;\n                class BaseCMapReaderFactory1 {\n                    constructor({ baseUrl: baseUrl1 = null, isCompressed: isCompressed1 = true }){\n                        if (this.constructor === BaseCMapReaderFactory1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n                        }\n                        this.baseUrl = baseUrl1;\n                        this.isCompressed = isCompressed1;\n                    }\n                    async fetch({ name: name1 }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n                        }\n                        if (!name1) {\n                            throw new Error(\"CMap name must be specified.\");\n                        }\n                        const url1 = this.baseUrl + name1 + (this.isCompressed ? \".bcmap\" : \"\");\n                        const compressionType1 = this.isCompressed ? _util1.CMapCompressionType.BINARY : _util1.CMapCompressionType.NONE;\n                        return this._fetchData(url1, compressionType1).catch((reason1)=>{\n                            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url1}`);\n                        });\n                    }\n                    _fetchData(url1, compressionType1) {\n                        (0, _util1.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseCMapReaderFactory = BaseCMapReaderFactory1;\n                class BaseStandardFontDataFactory1 {\n                    constructor({ baseUrl: baseUrl1 = null }){\n                        if (this.constructor === BaseStandardFontDataFactory1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n                        }\n                        this.baseUrl = baseUrl1;\n                    }\n                    async fetch({ filename: filename1 }) {\n                        if (!this.baseUrl) {\n                            throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n                        }\n                        if (!filename1) {\n                            throw new Error(\"Font filename must be specified.\");\n                        }\n                        const url1 = `${this.baseUrl}${filename1}`;\n                        return this._fetchData(url1).catch((reason1)=>{\n                            throw new Error(`Unable to load font data at: ${url1}`);\n                        });\n                    }\n                    _fetchData(url1) {\n                        (0, _util1.unreachable)(\"Abstract method `_fetchData` called.\");\n                    }\n                }\n                exports1.BaseStandardFontDataFactory = BaseStandardFontDataFactory1;\n                class BaseSVGFactory1 {\n                    constructor(){\n                        if (this.constructor === BaseSVGFactory1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n                        }\n                    }\n                    create(width2, height1, skipDimensions1 = false) {\n                        if (width2 <= 0 || height1 <= 0) {\n                            throw new Error(\"Invalid SVG dimensions\");\n                        }\n                        const svg1 = this._createSVG(\"svg:svg\");\n                        svg1.setAttribute(\"version\", \"1.1\");\n                        if (!skipDimensions1) {\n                            svg1.setAttribute(\"width\", `${width2}px`);\n                            svg1.setAttribute(\"height\", `${height1}px`);\n                        }\n                        svg1.setAttribute(\"preserveAspectRatio\", \"none\");\n                        svg1.setAttribute(\"viewBox\", `0 0 ${width2} ${height1}`);\n                        return svg1;\n                    }\n                    createElement(type1) {\n                        if (typeof type1 !== \"string\") {\n                            throw new Error(\"Invalid SVG element type\");\n                        }\n                        return this._createSVG(type1);\n                    }\n                    _createSVG(type1) {\n                        (0, _util1.unreachable)(\"Abstract method `_createSVG` called.\");\n                    }\n                }\n                exports1.BaseSVGFactory = BaseSVGFactory1;\n            /***/ },\n            /* 8 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MurmurHash3_64 = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                const SEED1 = 0xc3d2e1f0;\n                const MASK_HIGH1 = 0xffff0000;\n                const MASK_LOW1 = 0xffff;\n                class MurmurHash3_641 {\n                    constructor(seed1){\n                        this.h1 = seed1 ? seed1 & 0xffffffff : SEED1;\n                        this.h2 = seed1 ? seed1 & 0xffffffff : SEED1;\n                    }\n                    update(input1) {\n                        let data1, length1;\n                        if (typeof input1 === \"string\") {\n                            data1 = new Uint8Array(input1.length * 2);\n                            length1 = 0;\n                            for(let i1 = 0, ii1 = input1.length; i1 < ii1; i1++){\n                                const code1 = input1.charCodeAt(i1);\n                                if (code1 <= 0xff) {\n                                    data1[length1++] = code1;\n                                } else {\n                                    data1[length1++] = code1 >>> 8;\n                                    data1[length1++] = code1 & 0xff;\n                                }\n                            }\n                        } else if ((0, _util1.isArrayBuffer)(input1)) {\n                            data1 = input1.slice();\n                            length1 = data1.byteLength;\n                        } else {\n                            throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n                        }\n                        const blockCounts1 = length1 >> 2;\n                        const tailLength1 = length1 - blockCounts1 * 4;\n                        const dataUint321 = new Uint32Array(data1.buffer, 0, blockCounts1);\n                        let k11 = 0, k21 = 0;\n                        let h11 = this.h1, h21 = this.h2;\n                        const C11 = 0xcc9e2d51, C21 = 0x1b873593;\n                        const C1_LOW1 = C11 & MASK_LOW1, C2_LOW1 = C21 & MASK_LOW1;\n                        for(let i1 = 0; i1 < blockCounts1; i1++){\n                            if (i1 & 1) {\n                                k11 = dataUint321[i1];\n                                k11 = k11 * C11 & MASK_HIGH1 | k11 * C1_LOW1 & MASK_LOW1;\n                                k11 = k11 << 15 | k11 >>> 17;\n                                k11 = k11 * C21 & MASK_HIGH1 | k11 * C2_LOW1 & MASK_LOW1;\n                                h11 ^= k11;\n                                h11 = h11 << 13 | h11 >>> 19;\n                                h11 = h11 * 5 + 0xe6546b64;\n                            } else {\n                                k21 = dataUint321[i1];\n                                k21 = k21 * C11 & MASK_HIGH1 | k21 * C1_LOW1 & MASK_LOW1;\n                                k21 = k21 << 15 | k21 >>> 17;\n                                k21 = k21 * C21 & MASK_HIGH1 | k21 * C2_LOW1 & MASK_LOW1;\n                                h21 ^= k21;\n                                h21 = h21 << 13 | h21 >>> 19;\n                                h21 = h21 * 5 + 0xe6546b64;\n                            }\n                        }\n                        k11 = 0;\n                        switch(tailLength1){\n                            case 3:\n                                k11 ^= data1[blockCounts1 * 4 + 2] << 16;\n                            case 2:\n                                k11 ^= data1[blockCounts1 * 4 + 1] << 8;\n                            case 1:\n                                k11 ^= data1[blockCounts1 * 4];\n                                k11 = k11 * C11 & MASK_HIGH1 | k11 * C1_LOW1 & MASK_LOW1;\n                                k11 = k11 << 15 | k11 >>> 17;\n                                k11 = k11 * C21 & MASK_HIGH1 | k11 * C2_LOW1 & MASK_LOW1;\n                                if (blockCounts1 & 1) {\n                                    h11 ^= k11;\n                                } else {\n                                    h21 ^= k11;\n                                }\n                        }\n                        this.h1 = h11;\n                        this.h2 = h21;\n                    }\n                    hexdigest() {\n                        let h11 = this.h1, h21 = this.h2;\n                        h11 ^= h21 >>> 1;\n                        h11 = h11 * 0xed558ccd & MASK_HIGH1 | h11 * 0x8ccd & MASK_LOW1;\n                        h21 = h21 * 0xff51afd7 & MASK_HIGH1 | ((h21 << 16 | h11 >>> 16) * 0xafd7ed55 & MASK_HIGH1) >>> 16;\n                        h11 ^= h21 >>> 1;\n                        h11 = h11 * 0x1a85ec53 & MASK_HIGH1 | h11 * 0xec53 & MASK_LOW1;\n                        h21 = h21 * 0xc4ceb9fe & MASK_HIGH1 | ((h21 << 16 | h11 >>> 16) * 0xb9fe1a85 & MASK_HIGH1) >>> 16;\n                        h11 ^= h21 >>> 1;\n                        return (h11 >>> 0).toString(16).padStart(8, \"0\") + (h21 >>> 0).toString(16).padStart(8, \"0\");\n                    }\n                }\n                exports1.MurmurHash3_64 = MurmurHash3_641;\n            /***/ },\n            /* 9 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FontLoader = exports1.FontFaceObject = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                class FontLoader1 {\n                    #systemFonts;\n                    constructor({ ownerDocument: ownerDocument1 = globalThis.document, styleElement: styleElement1 = null }){\n                        this.#systemFonts = new Set();\n                        this._document = ownerDocument1;\n                        this.nativeFontFaces = new Set();\n                        this.styleElement = null;\n                        this.loadingRequests = [];\n                        this.loadTestFontId = 0;\n                    }\n                    addNativeFontFace(nativeFontFace1) {\n                        this.nativeFontFaces.add(nativeFontFace1);\n                        this._document.fonts.add(nativeFontFace1);\n                    }\n                    removeNativeFontFace(nativeFontFace1) {\n                        this.nativeFontFaces.delete(nativeFontFace1);\n                        this._document.fonts.delete(nativeFontFace1);\n                    }\n                    insertRule(rule1) {\n                        if (!this.styleElement) {\n                            this.styleElement = this._document.createElement(\"style\");\n                            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n                        }\n                        const styleSheet1 = this.styleElement.sheet;\n                        styleSheet1.insertRule(rule1, styleSheet1.cssRules.length);\n                    }\n                    clear() {\n                        for (const nativeFontFace1 of this.nativeFontFaces){\n                            this._document.fonts.delete(nativeFontFace1);\n                        }\n                        this.nativeFontFaces.clear();\n                        this.#systemFonts.clear();\n                        if (this.styleElement) {\n                            this.styleElement.remove();\n                            this.styleElement = null;\n                        }\n                    }\n                    async loadSystemFont(info1) {\n                        if (!info1 || this.#systemFonts.has(info1.loadedName)) {\n                            return;\n                        }\n                        (0, _util1.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n                        if (this.isFontLoadingAPISupported) {\n                            const { loadedName: loadedName1, src: src1, style: style1 } = info1;\n                            const fontFace1 = new FontFace(loadedName1, src1, style1);\n                            this.addNativeFontFace(fontFace1);\n                            try {\n                                await fontFace1.load();\n                                this.#systemFonts.add(loadedName1);\n                            } catch  {\n                                (0, _util1.warn)(`Cannot load system font: ${info1.baseFontName}, installing it could help to improve PDF rendering.`);\n                                this.removeNativeFontFace(fontFace1);\n                            }\n                            return;\n                        }\n                        (0, _util1.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n                    }\n                    async bind(font1) {\n                        if (font1.attached || font1.missingFile && !font1.systemFontInfo) {\n                            return;\n                        }\n                        font1.attached = true;\n                        if (font1.systemFontInfo) {\n                            await this.loadSystemFont(font1.systemFontInfo);\n                            return;\n                        }\n                        if (this.isFontLoadingAPISupported) {\n                            const nativeFontFace1 = font1.createNativeFontFace();\n                            if (nativeFontFace1) {\n                                this.addNativeFontFace(nativeFontFace1);\n                                try {\n                                    await nativeFontFace1.loaded;\n                                } catch (ex1) {\n                                    (0, _util1.warn)(`Failed to load font '${nativeFontFace1.family}': '${ex1}'.`);\n                                    font1.disableFontFace = true;\n                                    throw ex1;\n                                }\n                            }\n                            return;\n                        }\n                        const rule1 = font1.createFontFaceRule();\n                        if (rule1) {\n                            this.insertRule(rule1);\n                            if (this.isSyncFontLoadingSupported) {\n                                return;\n                            }\n                            await new Promise((resolve1)=>{\n                                const request1 = this._queueLoadingCallback(resolve1);\n                                this._prepareFontLoadEvent(font1, request1);\n                            });\n                        }\n                    }\n                    get isFontLoadingAPISupported() {\n                        const hasFonts1 = !!this._document?.fonts;\n                        return (0, _util1.shadow)(this, \"isFontLoadingAPISupported\", hasFonts1);\n                    }\n                    get isSyncFontLoadingSupported() {\n                        let supported1 = false;\n                        if (_util1.isNodeJS) {\n                            supported1 = true;\n                        } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n                            supported1 = true;\n                        }\n                        return (0, _util1.shadow)(this, \"isSyncFontLoadingSupported\", supported1);\n                    }\n                    _queueLoadingCallback(callback1) {\n                        function completeRequest1() {\n                            (0, _util1.assert)(!request1.done, \"completeRequest() cannot be called twice.\");\n                            request1.done = true;\n                            while(loadingRequests1.length > 0 && loadingRequests1[0].done){\n                                const otherRequest1 = loadingRequests1.shift();\n                                setTimeout(otherRequest1.callback, 0);\n                            }\n                        }\n                        const { loadingRequests: loadingRequests1 } = this;\n                        const request1 = {\n                            done: false,\n                            complete: completeRequest1,\n                            callback: callback1\n                        };\n                        loadingRequests1.push(request1);\n                        return request1;\n                    }\n                    get _loadTestFont() {\n                        const testFont1 = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n                        return (0, _util1.shadow)(this, \"_loadTestFont\", testFont1);\n                    }\n                    _prepareFontLoadEvent(font1, request1) {\n                        function int321(data1, offset1) {\n                            return data1.charCodeAt(offset1) << 24 | data1.charCodeAt(offset1 + 1) << 16 | data1.charCodeAt(offset1 + 2) << 8 | data1.charCodeAt(offset1 + 3) & 0xff;\n                        }\n                        function spliceString1(s4, offset1, remove1, insert1) {\n                            const chunk11 = s4.substring(0, offset1);\n                            const chunk21 = s4.substring(offset1 + remove1);\n                            return chunk11 + insert1 + chunk21;\n                        }\n                        let i1, ii1;\n                        const canvas1 = this._document.createElement(\"canvas\");\n                        canvas1.width = 1;\n                        canvas1.height = 1;\n                        const ctx1 = canvas1.getContext(\"2d\");\n                        let called1 = 0;\n                        function isFontReady1(name1, callback1) {\n                            if (++called1 > 30) {\n                                (0, _util1.warn)(\"Load test font never loaded.\");\n                                callback1();\n                                return;\n                            }\n                            ctx1.font = \"30px \" + name1;\n                            ctx1.fillText(\".\", 0, 20);\n                            const imageData1 = ctx1.getImageData(0, 0, 1, 1);\n                            if (imageData1.data[3] > 0) {\n                                callback1();\n                                return;\n                            }\n                            setTimeout(isFontReady1.bind(null, name1, callback1));\n                        }\n                        const loadTestFontId1 = `lt${Date.now()}${this.loadTestFontId++}`;\n                        let data1 = this._loadTestFont;\n                        const COMMENT_OFFSET1 = 976;\n                        data1 = spliceString1(data1, COMMENT_OFFSET1, loadTestFontId1.length, loadTestFontId1);\n                        const CFF_CHECKSUM_OFFSET1 = 16;\n                        const XXXX_VALUE1 = 0x58585858;\n                        let checksum1 = int321(data1, CFF_CHECKSUM_OFFSET1);\n                        for(i1 = 0, ii1 = loadTestFontId1.length - 3; i1 < ii1; i1 += 4){\n                            checksum1 = checksum1 - XXXX_VALUE1 + int321(loadTestFontId1, i1) | 0;\n                        }\n                        if (i1 < loadTestFontId1.length) {\n                            checksum1 = checksum1 - XXXX_VALUE1 + int321(loadTestFontId1 + \"XXX\", i1) | 0;\n                        }\n                        data1 = spliceString1(data1, CFF_CHECKSUM_OFFSET1, 4, (0, _util1.string32)(checksum1));\n                        const url1 = `url(data:font/opentype;base64,${btoa(data1)});`;\n                        const rule1 = `@font-face {font-family:\"${loadTestFontId1}\";src:${url1}}`;\n                        this.insertRule(rule1);\n                        const div1 = this._document.createElement(\"div\");\n                        div1.style.visibility = \"hidden\";\n                        div1.style.width = div1.style.height = \"10px\";\n                        div1.style.position = \"absolute\";\n                        div1.style.top = div1.style.left = \"0px\";\n                        for (const name1 of [\n                            font1.loadedName,\n                            loadTestFontId1\n                        ]){\n                            const span1 = this._document.createElement(\"span\");\n                            span1.textContent = \"Hi\";\n                            span1.style.fontFamily = name1;\n                            div1.append(span1);\n                        }\n                        this._document.body.append(div1);\n                        isFontReady1(loadTestFontId1, ()=>{\n                            div1.remove();\n                            request1.complete();\n                        });\n                    }\n                }\n                exports1.FontLoader = FontLoader1;\n                class FontFaceObject1 {\n                    constructor(translatedData1, { isEvalSupported: isEvalSupported1 = true, disableFontFace: disableFontFace1 = false, ignoreErrors: ignoreErrors1 = false, inspectFont: inspectFont1 = null }){\n                        this.compiledGlyphs = Object.create(null);\n                        for(const i1 in translatedData1){\n                            this[i1] = translatedData1[i1];\n                        }\n                        this.isEvalSupported = isEvalSupported1 !== false;\n                        this.disableFontFace = disableFontFace1 === true;\n                        this.ignoreErrors = ignoreErrors1 === true;\n                        this._inspectFont = inspectFont1;\n                    }\n                    createNativeFontFace() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        let nativeFontFace1;\n                        if (!this.cssFontInfo) {\n                            nativeFontFace1 = new FontFace(this.loadedName, this.data, {});\n                        } else {\n                            const css1 = {\n                                weight: this.cssFontInfo.fontWeight\n                            };\n                            if (this.cssFontInfo.italicAngle) {\n                                css1.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n                            }\n                            nativeFontFace1 = new FontFace(this.cssFontInfo.fontFamily, this.data, css1);\n                        }\n                        this._inspectFont?.(this);\n                        return nativeFontFace1;\n                    }\n                    createFontFaceRule() {\n                        if (!this.data || this.disableFontFace) {\n                            return null;\n                        }\n                        const data1 = (0, _util1.bytesToString)(this.data);\n                        const url1 = `url(data:${this.mimetype};base64,${btoa(data1)});`;\n                        let rule1;\n                        if (!this.cssFontInfo) {\n                            rule1 = `@font-face {font-family:\"${this.loadedName}\";src:${url1}}`;\n                        } else {\n                            let css1 = `font-weight: ${this.cssFontInfo.fontWeight};`;\n                            if (this.cssFontInfo.italicAngle) {\n                                css1 += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n                            }\n                            rule1 = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css1}src:${url1}}`;\n                        }\n                        this._inspectFont?.(this, url1);\n                        return rule1;\n                    }\n                    getPathGenerator(objs1, character1) {\n                        if (this.compiledGlyphs[character1] !== undefined) {\n                            return this.compiledGlyphs[character1];\n                        }\n                        let cmds1;\n                        try {\n                            cmds1 = objs1.get(this.loadedName + \"_path_\" + character1);\n                        } catch (ex1) {\n                            if (!this.ignoreErrors) {\n                                throw ex1;\n                            }\n                            (0, _util1.warn)(`getPathGenerator - ignoring character: \"${ex1}\".`);\n                            return this.compiledGlyphs[character1] = function(c4, size1) {};\n                        }\n                        if (this.isEvalSupported && _util1.FeatureTest.isEvalSupported) {\n                            const jsBuf1 = [];\n                            for (const current1 of cmds1){\n                                const args1 = current1.args !== undefined ? current1.args.join(\",\") : \"\";\n                                jsBuf1.push(\"c.\", current1.cmd, \"(\", args1, \");\\n\");\n                            }\n                            return this.compiledGlyphs[character1] = new Function(\"c\", \"size\", jsBuf1.join(\"\"));\n                        }\n                        return this.compiledGlyphs[character1] = function(c4, size1) {\n                            for (const current1 of cmds1){\n                                if (current1.cmd === \"scale\") {\n                                    current1.args = [\n                                        size1,\n                                        -size1\n                                    ];\n                                }\n                                c4[current1.cmd].apply(c4, current1.args);\n                            }\n                        };\n                    }\n                }\n                exports1.FontFaceObject = FontFaceObject1;\n            /***/ },\n            /* 10 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NodeStandardFontDataFactory = exports1.NodeFilterFactory = exports1.NodeCanvasFactory = exports1.NodeCMapReaderFactory = void 0;\n                var _base_factory1 = __w_pdfjs_require__1(7);\n                var _util1 = __w_pdfjs_require__1(1);\n                ;\n                ;\n                const fetchData1 = function(url1) {\n                    return new Promise((resolve1, reject1)=>{\n                        const fs1 = __webpack_require__(/*! fs */ \"fs\");\n                        fs1.readFile(url1, (error1, data1)=>{\n                            if (error1 || !data1) {\n                                reject1(new Error(error1));\n                                return;\n                            }\n                            resolve1(new Uint8Array(data1));\n                        });\n                    });\n                };\n                class NodeFilterFactory1 extends _base_factory1.BaseFilterFactory {\n                }\n                exports1.NodeFilterFactory = NodeFilterFactory1;\n                class NodeCanvasFactory1 extends _base_factory1.BaseCanvasFactory {\n                    _createCanvas(width2, height1) {\n                        const Canvas1 = __webpack_require__(/*! canvas */ \"?8412\");\n                        return Canvas1.createCanvas(width2, height1);\n                    }\n                }\n                exports1.NodeCanvasFactory = NodeCanvasFactory1;\n                class NodeCMapReaderFactory1 extends _base_factory1.BaseCMapReaderFactory {\n                    _fetchData(url1, compressionType1) {\n                        return fetchData1(url1).then((data1)=>{\n                            return {\n                                cMapData: data1,\n                                compressionType: compressionType1\n                            };\n                        });\n                    }\n                }\n                exports1.NodeCMapReaderFactory = NodeCMapReaderFactory1;\n                class NodeStandardFontDataFactory1 extends _base_factory1.BaseStandardFontDataFactory {\n                    _fetchData(url1) {\n                        return fetchData1(url1);\n                    }\n                }\n                exports1.NodeStandardFontDataFactory = NodeStandardFontDataFactory1;\n            /***/ },\n            /* 11 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.CanvasGraphics = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _pattern_helper1 = __w_pdfjs_require__1(12);\n                var _image_utils1 = __w_pdfjs_require__1(13);\n                const MIN_FONT_SIZE1 = 16;\n                const MAX_FONT_SIZE1 = 100;\n                const MAX_GROUP_SIZE1 = 4096;\n                const EXECUTION_TIME1 = 15;\n                const EXECUTION_STEPS1 = 10;\n                const MAX_SIZE_TO_COMPILE1 = 1000;\n                const FULL_CHUNK_HEIGHT1 = 16;\n                function mirrorContextOperations1(ctx1, destCtx1) {\n                    if (ctx1._removeMirroring) {\n                        throw new Error(\"Context is already forwarding operations.\");\n                    }\n                    ctx1.__originalSave = ctx1.save;\n                    ctx1.__originalRestore = ctx1.restore;\n                    ctx1.__originalRotate = ctx1.rotate;\n                    ctx1.__originalScale = ctx1.scale;\n                    ctx1.__originalTranslate = ctx1.translate;\n                    ctx1.__originalTransform = ctx1.transform;\n                    ctx1.__originalSetTransform = ctx1.setTransform;\n                    ctx1.__originalResetTransform = ctx1.resetTransform;\n                    ctx1.__originalClip = ctx1.clip;\n                    ctx1.__originalMoveTo = ctx1.moveTo;\n                    ctx1.__originalLineTo = ctx1.lineTo;\n                    ctx1.__originalBezierCurveTo = ctx1.bezierCurveTo;\n                    ctx1.__originalRect = ctx1.rect;\n                    ctx1.__originalClosePath = ctx1.closePath;\n                    ctx1.__originalBeginPath = ctx1.beginPath;\n                    ctx1._removeMirroring = ()=>{\n                        ctx1.save = ctx1.__originalSave;\n                        ctx1.restore = ctx1.__originalRestore;\n                        ctx1.rotate = ctx1.__originalRotate;\n                        ctx1.scale = ctx1.__originalScale;\n                        ctx1.translate = ctx1.__originalTranslate;\n                        ctx1.transform = ctx1.__originalTransform;\n                        ctx1.setTransform = ctx1.__originalSetTransform;\n                        ctx1.resetTransform = ctx1.__originalResetTransform;\n                        ctx1.clip = ctx1.__originalClip;\n                        ctx1.moveTo = ctx1.__originalMoveTo;\n                        ctx1.lineTo = ctx1.__originalLineTo;\n                        ctx1.bezierCurveTo = ctx1.__originalBezierCurveTo;\n                        ctx1.rect = ctx1.__originalRect;\n                        ctx1.closePath = ctx1.__originalClosePath;\n                        ctx1.beginPath = ctx1.__originalBeginPath;\n                        delete ctx1._removeMirroring;\n                    };\n                    ctx1.save = function ctxSave1() {\n                        destCtx1.save();\n                        this.__originalSave();\n                    };\n                    ctx1.restore = function ctxRestore1() {\n                        destCtx1.restore();\n                        this.__originalRestore();\n                    };\n                    ctx1.translate = function ctxTranslate1(x4, y4) {\n                        destCtx1.translate(x4, y4);\n                        this.__originalTranslate(x4, y4);\n                    };\n                    ctx1.scale = function ctxScale1(x4, y4) {\n                        destCtx1.scale(x4, y4);\n                        this.__originalScale(x4, y4);\n                    };\n                    ctx1.transform = function ctxTransform1(a1, b4, c4, d5, e1, f1) {\n                        destCtx1.transform(a1, b4, c4, d5, e1, f1);\n                        this.__originalTransform(a1, b4, c4, d5, e1, f1);\n                    };\n                    ctx1.setTransform = function ctxSetTransform1(a1, b4, c4, d5, e1, f1) {\n                        destCtx1.setTransform(a1, b4, c4, d5, e1, f1);\n                        this.__originalSetTransform(a1, b4, c4, d5, e1, f1);\n                    };\n                    ctx1.resetTransform = function ctxResetTransform1() {\n                        destCtx1.resetTransform();\n                        this.__originalResetTransform();\n                    };\n                    ctx1.rotate = function ctxRotate1(angle1) {\n                        destCtx1.rotate(angle1);\n                        this.__originalRotate(angle1);\n                    };\n                    ctx1.clip = function ctxRotate1(rule1) {\n                        destCtx1.clip(rule1);\n                        this.__originalClip(rule1);\n                    };\n                    ctx1.moveTo = function(x4, y4) {\n                        destCtx1.moveTo(x4, y4);\n                        this.__originalMoveTo(x4, y4);\n                    };\n                    ctx1.lineTo = function(x4, y4) {\n                        destCtx1.lineTo(x4, y4);\n                        this.__originalLineTo(x4, y4);\n                    };\n                    ctx1.bezierCurveTo = function(cp1x1, cp1y1, cp2x1, cp2y1, x4, y4) {\n                        destCtx1.bezierCurveTo(cp1x1, cp1y1, cp2x1, cp2y1, x4, y4);\n                        this.__originalBezierCurveTo(cp1x1, cp1y1, cp2x1, cp2y1, x4, y4);\n                    };\n                    ctx1.rect = function(x4, y4, width2, height1) {\n                        destCtx1.rect(x4, y4, width2, height1);\n                        this.__originalRect(x4, y4, width2, height1);\n                    };\n                    ctx1.closePath = function() {\n                        destCtx1.closePath();\n                        this.__originalClosePath();\n                    };\n                    ctx1.beginPath = function() {\n                        destCtx1.beginPath();\n                        this.__originalBeginPath();\n                    };\n                }\n                class CachedCanvases1 {\n                    constructor(canvasFactory1){\n                        this.canvasFactory = canvasFactory1;\n                        this.cache = Object.create(null);\n                    }\n                    getCanvas(id1, width2, height1) {\n                        let canvasEntry1;\n                        if (this.cache[id1] !== undefined) {\n                            canvasEntry1 = this.cache[id1];\n                            this.canvasFactory.reset(canvasEntry1, width2, height1);\n                        } else {\n                            canvasEntry1 = this.canvasFactory.create(width2, height1);\n                            this.cache[id1] = canvasEntry1;\n                        }\n                        return canvasEntry1;\n                    }\n                    delete(id1) {\n                        delete this.cache[id1];\n                    }\n                    clear() {\n                        for(const id1 in this.cache){\n                            const canvasEntry1 = this.cache[id1];\n                            this.canvasFactory.destroy(canvasEntry1);\n                            delete this.cache[id1];\n                        }\n                    }\n                }\n                function drawImageAtIntegerCoords1(ctx1, srcImg1, srcX1, srcY1, srcW1, srcH1, destX1, destY1, destW1, destH1) {\n                    const [a1, b4, c4, d5, tx2, ty2] = (0, _display_utils1.getCurrentTransform)(ctx1);\n                    if (b4 === 0 && c4 === 0) {\n                        const tlX1 = destX1 * a1 + tx2;\n                        const rTlX1 = Math.round(tlX1);\n                        const tlY1 = destY1 * d5 + ty2;\n                        const rTlY1 = Math.round(tlY1);\n                        const brX1 = (destX1 + destW1) * a1 + tx2;\n                        const rWidth1 = Math.abs(Math.round(brX1) - rTlX1) || 1;\n                        const brY1 = (destY1 + destH1) * d5 + ty2;\n                        const rHeight1 = Math.abs(Math.round(brY1) - rTlY1) || 1;\n                        ctx1.setTransform(Math.sign(a1), 0, 0, Math.sign(d5), rTlX1, rTlY1);\n                        ctx1.drawImage(srcImg1, srcX1, srcY1, srcW1, srcH1, 0, 0, rWidth1, rHeight1);\n                        ctx1.setTransform(a1, b4, c4, d5, tx2, ty2);\n                        return [\n                            rWidth1,\n                            rHeight1\n                        ];\n                    }\n                    if (a1 === 0 && d5 === 0) {\n                        const tlX1 = destY1 * c4 + tx2;\n                        const rTlX1 = Math.round(tlX1);\n                        const tlY1 = destX1 * b4 + ty2;\n                        const rTlY1 = Math.round(tlY1);\n                        const brX1 = (destY1 + destH1) * c4 + tx2;\n                        const rWidth1 = Math.abs(Math.round(brX1) - rTlX1) || 1;\n                        const brY1 = (destX1 + destW1) * b4 + ty2;\n                        const rHeight1 = Math.abs(Math.round(brY1) - rTlY1) || 1;\n                        ctx1.setTransform(0, Math.sign(b4), Math.sign(c4), 0, rTlX1, rTlY1);\n                        ctx1.drawImage(srcImg1, srcX1, srcY1, srcW1, srcH1, 0, 0, rHeight1, rWidth1);\n                        ctx1.setTransform(a1, b4, c4, d5, tx2, ty2);\n                        return [\n                            rHeight1,\n                            rWidth1\n                        ];\n                    }\n                    ctx1.drawImage(srcImg1, srcX1, srcY1, srcW1, srcH1, destX1, destY1, destW1, destH1);\n                    const scaleX1 = Math.hypot(a1, b4);\n                    const scaleY1 = Math.hypot(c4, d5);\n                    return [\n                        scaleX1 * destW1,\n                        scaleY1 * destH1\n                    ];\n                }\n                function compileType3Glyph1(imgData1) {\n                    const { width: width2, height: height1 } = imgData1;\n                    if (width2 > MAX_SIZE_TO_COMPILE1 || height1 > MAX_SIZE_TO_COMPILE1) {\n                        return null;\n                    }\n                    const POINT_TO_PROCESS_LIMIT1 = 1000;\n                    const POINT_TYPES1 = new Uint8Array([\n                        0,\n                        2,\n                        4,\n                        0,\n                        1,\n                        0,\n                        5,\n                        4,\n                        8,\n                        10,\n                        0,\n                        8,\n                        0,\n                        2,\n                        1,\n                        0\n                    ]);\n                    const width11 = width2 + 1;\n                    let points1 = new Uint8Array(width11 * (height1 + 1));\n                    let i1, j1, j01;\n                    const lineSize1 = width2 + 7 & ~7;\n                    let data1 = new Uint8Array(lineSize1 * height1), pos1 = 0;\n                    for (const elem1 of imgData1.data){\n                        let mask1 = 128;\n                        while(mask1 > 0){\n                            data1[pos1++] = elem1 & mask1 ? 0 : 255;\n                            mask1 >>= 1;\n                        }\n                    }\n                    let count1 = 0;\n                    pos1 = 0;\n                    if (data1[pos1] !== 0) {\n                        points1[0] = 1;\n                        ++count1;\n                    }\n                    for(j1 = 1; j1 < width2; j1++){\n                        if (data1[pos1] !== data1[pos1 + 1]) {\n                            points1[j1] = data1[pos1] ? 2 : 1;\n                            ++count1;\n                        }\n                        pos1++;\n                    }\n                    if (data1[pos1] !== 0) {\n                        points1[j1] = 2;\n                        ++count1;\n                    }\n                    for(i1 = 1; i1 < height1; i1++){\n                        pos1 = i1 * lineSize1;\n                        j01 = i1 * width11;\n                        if (data1[pos1 - lineSize1] !== data1[pos1]) {\n                            points1[j01] = data1[pos1] ? 1 : 8;\n                            ++count1;\n                        }\n                        let sum1 = (data1[pos1] ? 4 : 0) + (data1[pos1 - lineSize1] ? 8 : 0);\n                        for(j1 = 1; j1 < width2; j1++){\n                            sum1 = (sum1 >> 2) + (data1[pos1 + 1] ? 4 : 0) + (data1[pos1 - lineSize1 + 1] ? 8 : 0);\n                            if (POINT_TYPES1[sum1]) {\n                                points1[j01 + j1] = POINT_TYPES1[sum1];\n                                ++count1;\n                            }\n                            pos1++;\n                        }\n                        if (data1[pos1 - lineSize1] !== data1[pos1]) {\n                            points1[j01 + j1] = data1[pos1] ? 2 : 4;\n                            ++count1;\n                        }\n                        if (count1 > POINT_TO_PROCESS_LIMIT1) {\n                            return null;\n                        }\n                    }\n                    pos1 = lineSize1 * (height1 - 1);\n                    j01 = i1 * width11;\n                    if (data1[pos1] !== 0) {\n                        points1[j01] = 8;\n                        ++count1;\n                    }\n                    for(j1 = 1; j1 < width2; j1++){\n                        if (data1[pos1] !== data1[pos1 + 1]) {\n                            points1[j01 + j1] = data1[pos1] ? 4 : 8;\n                            ++count1;\n                        }\n                        pos1++;\n                    }\n                    if (data1[pos1] !== 0) {\n                        points1[j01 + j1] = 4;\n                        ++count1;\n                    }\n                    if (count1 > POINT_TO_PROCESS_LIMIT1) {\n                        return null;\n                    }\n                    const steps1 = new Int32Array([\n                        0,\n                        width11,\n                        -1,\n                        0,\n                        -width11,\n                        0,\n                        0,\n                        0,\n                        1\n                    ]);\n                    const path1 = new Path2D();\n                    for(i1 = 0; count1 && i1 <= height1; i1++){\n                        let p5 = i1 * width11;\n                        const end1 = p5 + width2;\n                        while(p5 < end1 && !points1[p5]){\n                            p5++;\n                        }\n                        if (p5 === end1) {\n                            continue;\n                        }\n                        path1.moveTo(p5 % width11, i1);\n                        const p01 = p5;\n                        let type1 = points1[p5];\n                        do {\n                            const step1 = steps1[type1];\n                            do {\n                                p5 += step1;\n                            }while (!points1[p5]);\n                            const pp1 = points1[p5];\n                            if (pp1 !== 5 && pp1 !== 10) {\n                                type1 = pp1;\n                                points1[p5] = 0;\n                            } else {\n                                type1 = pp1 & 0x33 * type1 >> 4;\n                                points1[p5] &= type1 >> 2 | type1 << 2;\n                            }\n                            path1.lineTo(p5 % width11, p5 / width11 | 0);\n                            if (!points1[p5]) {\n                                --count1;\n                            }\n                        }while (p01 !== p5);\n                        --i1;\n                    }\n                    data1 = null;\n                    points1 = null;\n                    const drawOutline1 = function(c4) {\n                        c4.save();\n                        c4.scale(1 / width2, -1 / height1);\n                        c4.translate(0, -height1);\n                        c4.fill(path1);\n                        c4.beginPath();\n                        c4.restore();\n                    };\n                    return drawOutline1;\n                }\n                class CanvasExtraState1 {\n                    constructor(width2, height1){\n                        this.alphaIsShape = false;\n                        this.fontSize = 0;\n                        this.fontSizeScale = 1;\n                        this.textMatrix = _util1.IDENTITY_MATRIX;\n                        this.textMatrixScale = 1;\n                        this.fontMatrix = _util1.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRenderingMode = _util1.TextRenderingMode.FILL;\n                        this.textRise = 0;\n                        this.fillColor = \"#000000\";\n                        this.strokeColor = \"#000000\";\n                        this.patternFill = false;\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.activeSMask = null;\n                        this.transferMaps = \"none\";\n                        this.startNewPathAndClipBox([\n                            0,\n                            0,\n                            width2,\n                            height1\n                        ]);\n                    }\n                    clone() {\n                        const clone1 = Object.create(this);\n                        clone1.clipBox = this.clipBox.slice();\n                        return clone1;\n                    }\n                    setCurrentPoint(x4, y4) {\n                        this.x = x4;\n                        this.y = y4;\n                    }\n                    updatePathMinMax(transform1, x4, y4) {\n                        [x4, y4] = _util1.Util.applyTransform([\n                            x4,\n                            y4\n                        ], transform1);\n                        this.minX = Math.min(this.minX, x4);\n                        this.minY = Math.min(this.minY, y4);\n                        this.maxX = Math.max(this.maxX, x4);\n                        this.maxY = Math.max(this.maxY, y4);\n                    }\n                    updateRectMinMax(transform1, rect3) {\n                        const p12 = _util1.Util.applyTransform(rect3, transform1);\n                        const p22 = _util1.Util.applyTransform(rect3.slice(2), transform1);\n                        this.minX = Math.min(this.minX, p12[0], p22[0]);\n                        this.minY = Math.min(this.minY, p12[1], p22[1]);\n                        this.maxX = Math.max(this.maxX, p12[0], p22[0]);\n                        this.maxY = Math.max(this.maxY, p12[1], p22[1]);\n                    }\n                    updateScalingPathMinMax(transform1, minMax1) {\n                        _util1.Util.scaleMinMax(transform1, minMax1);\n                        this.minX = Math.min(this.minX, minMax1[0]);\n                        this.maxX = Math.max(this.maxX, minMax1[1]);\n                        this.minY = Math.min(this.minY, minMax1[2]);\n                        this.maxY = Math.max(this.maxY, minMax1[3]);\n                    }\n                    updateCurvePathMinMax(transform1, x01, y01, x11, y11, x21, y21, x31, y31, minMax1) {\n                        const box1 = _util1.Util.bezierBoundingBox(x01, y01, x11, y11, x21, y21, x31, y31);\n                        if (minMax1) {\n                            minMax1[0] = Math.min(minMax1[0], box1[0], box1[2]);\n                            minMax1[1] = Math.max(minMax1[1], box1[0], box1[2]);\n                            minMax1[2] = Math.min(minMax1[2], box1[1], box1[3]);\n                            minMax1[3] = Math.max(minMax1[3], box1[1], box1[3]);\n                            return;\n                        }\n                        this.updateRectMinMax(transform1, box1);\n                    }\n                    getPathBoundingBox(pathType1 = _pattern_helper1.PathType.FILL, transform1 = null) {\n                        const box1 = [\n                            this.minX,\n                            this.minY,\n                            this.maxX,\n                            this.maxY\n                        ];\n                        if (pathType1 === _pattern_helper1.PathType.STROKE) {\n                            if (!transform1) {\n                                (0, _util1.unreachable)(\"Stroke bounding box must include transform.\");\n                            }\n                            const scale1 = _util1.Util.singularValueDecompose2dScale(transform1);\n                            const xStrokePad1 = scale1[0] * this.lineWidth / 2;\n                            const yStrokePad1 = scale1[1] * this.lineWidth / 2;\n                            box1[0] -= xStrokePad1;\n                            box1[1] -= yStrokePad1;\n                            box1[2] += xStrokePad1;\n                            box1[3] += yStrokePad1;\n                        }\n                        return box1;\n                    }\n                    updateClipFromPath() {\n                        const intersect1 = _util1.Util.intersect(this.clipBox, this.getPathBoundingBox());\n                        this.startNewPathAndClipBox(intersect1 || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ]);\n                    }\n                    isEmptyClip() {\n                        return this.minX === Infinity;\n                    }\n                    startNewPathAndClipBox(box1) {\n                        this.clipBox = box1;\n                        this.minX = Infinity;\n                        this.minY = Infinity;\n                        this.maxX = 0;\n                        this.maxY = 0;\n                    }\n                    getClippedPathBoundingBox(pathType1 = _pattern_helper1.PathType.FILL, transform1 = null) {\n                        return _util1.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType1, transform1));\n                    }\n                }\n                function putBinaryImageData1(ctx1, imgData1) {\n                    if (typeof ImageData !== \"undefined\" && imgData1 instanceof ImageData) {\n                        ctx1.putImageData(imgData1, 0, 0);\n                        return;\n                    }\n                    const height1 = imgData1.height, width2 = imgData1.width;\n                    const partialChunkHeight1 = height1 % FULL_CHUNK_HEIGHT1;\n                    const fullChunks1 = (height1 - partialChunkHeight1) / FULL_CHUNK_HEIGHT1;\n                    const totalChunks1 = partialChunkHeight1 === 0 ? fullChunks1 : fullChunks1 + 1;\n                    const chunkImgData1 = ctx1.createImageData(width2, FULL_CHUNK_HEIGHT1);\n                    let srcPos1 = 0, destPos1;\n                    const src1 = imgData1.data;\n                    const dest1 = chunkImgData1.data;\n                    let i1, j1, thisChunkHeight1, elemsInThisChunk1;\n                    if (imgData1.kind === _util1.ImageKind.GRAYSCALE_1BPP) {\n                        const srcLength1 = src1.byteLength;\n                        const dest321 = new Uint32Array(dest1.buffer, 0, dest1.byteLength >> 2);\n                        const dest32DataLength1 = dest321.length;\n                        const fullSrcDiff1 = width2 + 7 >> 3;\n                        const white1 = 0xffffffff;\n                        const black1 = _util1.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                        for(i1 = 0; i1 < totalChunks1; i1++){\n                            thisChunkHeight1 = i1 < fullChunks1 ? FULL_CHUNK_HEIGHT1 : partialChunkHeight1;\n                            destPos1 = 0;\n                            for(j1 = 0; j1 < thisChunkHeight1; j1++){\n                                const srcDiff1 = srcLength1 - srcPos1;\n                                let k3 = 0;\n                                const kEnd1 = srcDiff1 > fullSrcDiff1 ? width2 : srcDiff1 * 8 - 7;\n                                const kEndUnrolled1 = kEnd1 & ~7;\n                                let mask1 = 0;\n                                let srcByte1 = 0;\n                                for(; k3 < kEndUnrolled1; k3 += 8){\n                                    srcByte1 = src1[srcPos1++];\n                                    dest321[destPos1++] = srcByte1 & 128 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 64 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 32 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 16 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 8 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 4 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 2 ? white1 : black1;\n                                    dest321[destPos1++] = srcByte1 & 1 ? white1 : black1;\n                                }\n                                for(; k3 < kEnd1; k3++){\n                                    if (mask1 === 0) {\n                                        srcByte1 = src1[srcPos1++];\n                                        mask1 = 128;\n                                    }\n                                    dest321[destPos1++] = srcByte1 & mask1 ? white1 : black1;\n                                    mask1 >>= 1;\n                                }\n                            }\n                            while(destPos1 < dest32DataLength1){\n                                dest321[destPos1++] = 0;\n                            }\n                            ctx1.putImageData(chunkImgData1, 0, i1 * FULL_CHUNK_HEIGHT1);\n                        }\n                    } else if (imgData1.kind === _util1.ImageKind.RGBA_32BPP) {\n                        j1 = 0;\n                        elemsInThisChunk1 = width2 * FULL_CHUNK_HEIGHT1 * 4;\n                        for(i1 = 0; i1 < fullChunks1; i1++){\n                            dest1.set(src1.subarray(srcPos1, srcPos1 + elemsInThisChunk1));\n                            srcPos1 += elemsInThisChunk1;\n                            ctx1.putImageData(chunkImgData1, 0, j1);\n                            j1 += FULL_CHUNK_HEIGHT1;\n                        }\n                        if (i1 < totalChunks1) {\n                            elemsInThisChunk1 = width2 * partialChunkHeight1 * 4;\n                            dest1.set(src1.subarray(srcPos1, srcPos1 + elemsInThisChunk1));\n                            ctx1.putImageData(chunkImgData1, 0, j1);\n                        }\n                    } else if (imgData1.kind === _util1.ImageKind.RGB_24BPP) {\n                        thisChunkHeight1 = FULL_CHUNK_HEIGHT1;\n                        elemsInThisChunk1 = width2 * thisChunkHeight1;\n                        for(i1 = 0; i1 < totalChunks1; i1++){\n                            if (i1 >= fullChunks1) {\n                                thisChunkHeight1 = partialChunkHeight1;\n                                elemsInThisChunk1 = width2 * thisChunkHeight1;\n                            }\n                            destPos1 = 0;\n                            for(j1 = elemsInThisChunk1; j1--;){\n                                dest1[destPos1++] = src1[srcPos1++];\n                                dest1[destPos1++] = src1[srcPos1++];\n                                dest1[destPos1++] = src1[srcPos1++];\n                                dest1[destPos1++] = 255;\n                            }\n                            ctx1.putImageData(chunkImgData1, 0, i1 * FULL_CHUNK_HEIGHT1);\n                        }\n                    } else {\n                        throw new Error(`bad image kind: ${imgData1.kind}`);\n                    }\n                }\n                function putBinaryImageMask1(ctx1, imgData1) {\n                    if (imgData1.bitmap) {\n                        ctx1.drawImage(imgData1.bitmap, 0, 0);\n                        return;\n                    }\n                    const height1 = imgData1.height, width2 = imgData1.width;\n                    const partialChunkHeight1 = height1 % FULL_CHUNK_HEIGHT1;\n                    const fullChunks1 = (height1 - partialChunkHeight1) / FULL_CHUNK_HEIGHT1;\n                    const totalChunks1 = partialChunkHeight1 === 0 ? fullChunks1 : fullChunks1 + 1;\n                    const chunkImgData1 = ctx1.createImageData(width2, FULL_CHUNK_HEIGHT1);\n                    let srcPos1 = 0;\n                    const src1 = imgData1.data;\n                    const dest1 = chunkImgData1.data;\n                    for(let i1 = 0; i1 < totalChunks1; i1++){\n                        const thisChunkHeight1 = i1 < fullChunks1 ? FULL_CHUNK_HEIGHT1 : partialChunkHeight1;\n                        ({ srcPos: srcPos1 } = (0, _image_utils1.convertBlackAndWhiteToRGBA)({\n                            src: src1,\n                            srcPos: srcPos1,\n                            dest: dest1,\n                            width: width2,\n                            height: thisChunkHeight1,\n                            nonBlackColor: 0\n                        }));\n                        ctx1.putImageData(chunkImgData1, 0, i1 * FULL_CHUNK_HEIGHT1);\n                    }\n                }\n                function copyCtxState1(sourceCtx1, destCtx1) {\n                    const properties1 = [\n                        \"strokeStyle\",\n                        \"fillStyle\",\n                        \"fillRule\",\n                        \"globalAlpha\",\n                        \"lineWidth\",\n                        \"lineCap\",\n                        \"lineJoin\",\n                        \"miterLimit\",\n                        \"globalCompositeOperation\",\n                        \"font\",\n                        \"filter\"\n                    ];\n                    for (const property1 of properties1){\n                        if (sourceCtx1[property1] !== undefined) {\n                            destCtx1[property1] = sourceCtx1[property1];\n                        }\n                    }\n                    if (sourceCtx1.setLineDash !== undefined) {\n                        destCtx1.setLineDash(sourceCtx1.getLineDash());\n                        destCtx1.lineDashOffset = sourceCtx1.lineDashOffset;\n                    }\n                }\n                function resetCtxToDefault1(ctx1) {\n                    ctx1.strokeStyle = ctx1.fillStyle = \"#000000\";\n                    ctx1.fillRule = \"nonzero\";\n                    ctx1.globalAlpha = 1;\n                    ctx1.lineWidth = 1;\n                    ctx1.lineCap = \"butt\";\n                    ctx1.lineJoin = \"miter\";\n                    ctx1.miterLimit = 10;\n                    ctx1.globalCompositeOperation = \"source-over\";\n                    ctx1.font = \"10px sans-serif\";\n                    if (ctx1.setLineDash !== undefined) {\n                        ctx1.setLineDash([]);\n                        ctx1.lineDashOffset = 0;\n                    }\n                    if (!_util1.isNodeJS) {\n                        const { filter: filter1 } = ctx1;\n                        if (filter1 !== \"none\" && filter1 !== \"\") {\n                            ctx1.filter = \"none\";\n                        }\n                    }\n                }\n                function composeSMaskBackdrop1(bytes1, r01, g01, b01) {\n                    const length1 = bytes1.length;\n                    for(let i1 = 3; i1 < length1; i1 += 4){\n                        const alpha1 = bytes1[i1];\n                        if (alpha1 === 0) {\n                            bytes1[i1 - 3] = r01;\n                            bytes1[i1 - 2] = g01;\n                            bytes1[i1 - 1] = b01;\n                        } else if (alpha1 < 255) {\n                            const alpha_1 = 255 - alpha1;\n                            bytes1[i1 - 3] = bytes1[i1 - 3] * alpha1 + r01 * alpha_1 >> 8;\n                            bytes1[i1 - 2] = bytes1[i1 - 2] * alpha1 + g01 * alpha_1 >> 8;\n                            bytes1[i1 - 1] = bytes1[i1 - 1] * alpha1 + b01 * alpha_1 >> 8;\n                        }\n                    }\n                }\n                function composeSMaskAlpha1(maskData1, layerData1, transferMap1) {\n                    const length1 = maskData1.length;\n                    const scale1 = 1 / 255;\n                    for(let i1 = 3; i1 < length1; i1 += 4){\n                        const alpha1 = transferMap1 ? transferMap1[maskData1[i1]] : maskData1[i1];\n                        layerData1[i1] = layerData1[i1] * alpha1 * scale1 | 0;\n                    }\n                }\n                function composeSMaskLuminosity1(maskData1, layerData1, transferMap1) {\n                    const length1 = maskData1.length;\n                    for(let i1 = 3; i1 < length1; i1 += 4){\n                        const y4 = maskData1[i1 - 3] * 77 + maskData1[i1 - 2] * 152 + maskData1[i1 - 1] * 28;\n                        layerData1[i1] = transferMap1 ? layerData1[i1] * transferMap1[y4 >> 8] >> 8 : layerData1[i1] * y4 >> 16;\n                    }\n                }\n                function genericComposeSMask1(maskCtx1, layerCtx1, width2, height1, subtype1, backdrop1, transferMap1, layerOffsetX1, layerOffsetY1, maskOffsetX1, maskOffsetY1) {\n                    const hasBackdrop1 = !!backdrop1;\n                    const r01 = hasBackdrop1 ? backdrop1[0] : 0;\n                    const g01 = hasBackdrop1 ? backdrop1[1] : 0;\n                    const b01 = hasBackdrop1 ? backdrop1[2] : 0;\n                    const composeFn1 = subtype1 === \"Luminosity\" ? composeSMaskLuminosity1 : composeSMaskAlpha1;\n                    const PIXELS_TO_PROCESS1 = 1048576;\n                    const chunkSize1 = Math.min(height1, Math.ceil(PIXELS_TO_PROCESS1 / width2));\n                    for(let row1 = 0; row1 < height1; row1 += chunkSize1){\n                        const chunkHeight1 = Math.min(chunkSize1, height1 - row1);\n                        const maskData1 = maskCtx1.getImageData(layerOffsetX1 - maskOffsetX1, row1 + (layerOffsetY1 - maskOffsetY1), width2, chunkHeight1);\n                        const layerData1 = layerCtx1.getImageData(layerOffsetX1, row1 + layerOffsetY1, width2, chunkHeight1);\n                        if (hasBackdrop1) {\n                            composeSMaskBackdrop1(maskData1.data, r01, g01, b01);\n                        }\n                        composeFn1(maskData1.data, layerData1.data, transferMap1);\n                        layerCtx1.putImageData(layerData1, layerOffsetX1, row1 + layerOffsetY1);\n                    }\n                }\n                function composeSMask1(ctx1, smask1, layerCtx1, layerBox1) {\n                    const layerOffsetX1 = layerBox1[0];\n                    const layerOffsetY1 = layerBox1[1];\n                    const layerWidth1 = layerBox1[2] - layerOffsetX1;\n                    const layerHeight1 = layerBox1[3] - layerOffsetY1;\n                    if (layerWidth1 === 0 || layerHeight1 === 0) {\n                        return;\n                    }\n                    genericComposeSMask1(smask1.context, layerCtx1, layerWidth1, layerHeight1, smask1.subtype, smask1.backdrop, smask1.transferMap, layerOffsetX1, layerOffsetY1, smask1.offsetX, smask1.offsetY);\n                    ctx1.save();\n                    ctx1.globalAlpha = 1;\n                    ctx1.globalCompositeOperation = \"source-over\";\n                    ctx1.setTransform(1, 0, 0, 1, 0, 0);\n                    ctx1.drawImage(layerCtx1.canvas, 0, 0);\n                    ctx1.restore();\n                }\n                function getImageSmoothingEnabled1(transform1, interpolate1) {\n                    const scale1 = _util1.Util.singularValueDecompose2dScale(transform1);\n                    scale1[0] = Math.fround(scale1[0]);\n                    scale1[1] = Math.fround(scale1[1]);\n                    const actualScale1 = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils1.PixelsPerInch.PDF_TO_CSS_UNITS);\n                    if (interpolate1 !== undefined) {\n                        return interpolate1;\n                    } else if (scale1[0] <= actualScale1 || scale1[1] <= actualScale1) {\n                        return true;\n                    }\n                    return false;\n                }\n                const LINE_CAP_STYLES1 = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES1 = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const NORMAL_CLIP1 = {};\n                const EO_CLIP1 = {};\n                class CanvasGraphics1 {\n                    constructor(canvasCtx1, commonObjs1, objs1, canvasFactory1, filterFactory1, { optionalContentConfig: optionalContentConfig1, markedContentStack: markedContentStack1 = null }, annotationCanvasMap1, pageColors1){\n                        this.ctx = canvasCtx1;\n                        this.current = new CanvasExtraState1(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.stateStack = [];\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.res = null;\n                        this.xobjs = null;\n                        this.commonObjs = commonObjs1;\n                        this.objs = objs1;\n                        this.canvasFactory = canvasFactory1;\n                        this.filterFactory = filterFactory1;\n                        this.groupStack = [];\n                        this.processingType3 = null;\n                        this.baseTransform = null;\n                        this.baseTransformStack = [];\n                        this.groupLevel = 0;\n                        this.smaskStack = [];\n                        this.smaskCounter = 0;\n                        this.tempSMask = null;\n                        this.suspendedCtx = null;\n                        this.contentVisible = true;\n                        this.markedContentStack = markedContentStack1 || [];\n                        this.optionalContentConfig = optionalContentConfig1;\n                        this.cachedCanvases = new CachedCanvases1(this.canvasFactory);\n                        this.cachedPatterns = new Map();\n                        this.annotationCanvasMap = annotationCanvasMap1;\n                        this.viewportScale = 1;\n                        this.outputScaleX = 1;\n                        this.outputScaleY = 1;\n                        this.pageColors = pageColors1;\n                        this._cachedScaleForStroking = [\n                            -1,\n                            0\n                        ];\n                        this._cachedGetSinglePixelWidth = null;\n                        this._cachedBitmapsMap = new Map();\n                    }\n                    getObject(data1, fallback1 = null) {\n                        if (typeof data1 === \"string\") {\n                            return data1.startsWith(\"g_\") ? this.commonObjs.get(data1) : this.objs.get(data1);\n                        }\n                        return fallback1;\n                    }\n                    beginDrawing({ transform: transform1, viewport: viewport1, transparency: transparency1 = false, background: background1 = null }) {\n                        const width2 = this.ctx.canvas.width;\n                        const height1 = this.ctx.canvas.height;\n                        const savedFillStyle1 = this.ctx.fillStyle;\n                        this.ctx.fillStyle = background1 || \"#ffffff\";\n                        this.ctx.fillRect(0, 0, width2, height1);\n                        this.ctx.fillStyle = savedFillStyle1;\n                        if (transparency1) {\n                            const transparentCanvas1 = this.cachedCanvases.getCanvas(\"transparent\", width2, height1);\n                            this.compositeCtx = this.ctx;\n                            this.transparentCanvas = transparentCanvas1.canvas;\n                            this.ctx = transparentCanvas1.context;\n                            this.ctx.save();\n                            this.ctx.transform(...(0, _display_utils1.getCurrentTransform)(this.compositeCtx));\n                        }\n                        this.ctx.save();\n                        resetCtxToDefault1(this.ctx);\n                        if (transform1) {\n                            this.ctx.transform(...transform1);\n                            this.outputScaleX = transform1[0];\n                            this.outputScaleY = transform1[0];\n                        }\n                        this.ctx.transform(...viewport1.transform);\n                        this.viewportScale = viewport1.scale;\n                        this.baseTransform = (0, _display_utils1.getCurrentTransform)(this.ctx);\n                    }\n                    executeOperatorList(operatorList1, executionStartIdx1, continueCallback1, stepper1) {\n                        const argsArray1 = operatorList1.argsArray;\n                        const fnArray1 = operatorList1.fnArray;\n                        let i1 = executionStartIdx1 || 0;\n                        const argsArrayLen1 = argsArray1.length;\n                        if (argsArrayLen1 === i1) {\n                            return i1;\n                        }\n                        const chunkOperations1 = argsArrayLen1 - i1 > EXECUTION_STEPS1 && typeof continueCallback1 === \"function\";\n                        const endTime1 = chunkOperations1 ? Date.now() + EXECUTION_TIME1 : 0;\n                        let steps1 = 0;\n                        const commonObjs1 = this.commonObjs;\n                        const objs1 = this.objs;\n                        let fnId1;\n                        while(true){\n                            if (stepper1 !== undefined && i1 === stepper1.nextBreakPoint) {\n                                stepper1.breakIt(i1, continueCallback1);\n                                return i1;\n                            }\n                            fnId1 = fnArray1[i1];\n                            if (fnId1 !== _util1.OPS.dependency) {\n                                this[fnId1].apply(this, argsArray1[i1]);\n                            } else {\n                                for (const depObjId1 of argsArray1[i1]){\n                                    const objsPool1 = depObjId1.startsWith(\"g_\") ? commonObjs1 : objs1;\n                                    if (!objsPool1.has(depObjId1)) {\n                                        objsPool1.get(depObjId1, continueCallback1);\n                                        return i1;\n                                    }\n                                }\n                            }\n                            i1++;\n                            if (i1 === argsArrayLen1) {\n                                return i1;\n                            }\n                            if (chunkOperations1 && ++steps1 > EXECUTION_STEPS1) {\n                                if (Date.now() > endTime1) {\n                                    continueCallback1();\n                                    return i1;\n                                }\n                                steps1 = 0;\n                            }\n                        }\n                    }\n                    #restoreInitialState() {\n                        while(this.stateStack.length || this.inSMaskMode){\n                            this.restore();\n                        }\n                        this.ctx.restore();\n                        if (this.transparentCanvas) {\n                            this.ctx = this.compositeCtx;\n                            this.ctx.save();\n                            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n                            this.ctx.restore();\n                            this.transparentCanvas = null;\n                        }\n                    }\n                    endDrawing() {\n                        this.#restoreInitialState();\n                        this.cachedCanvases.clear();\n                        this.cachedPatterns.clear();\n                        for (const cache1 of this._cachedBitmapsMap.values()){\n                            for (const canvas1 of cache1.values()){\n                                if (typeof HTMLCanvasElement !== \"undefined\" && canvas1 instanceof HTMLCanvasElement) {\n                                    canvas1.width = canvas1.height = 0;\n                                }\n                            }\n                            cache1.clear();\n                        }\n                        this._cachedBitmapsMap.clear();\n                        this.#drawFilter();\n                    }\n                    #drawFilter() {\n                        if (this.pageColors) {\n                            const hcmFilterId1 = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n                            if (hcmFilterId1 !== \"none\") {\n                                const savedFilter1 = this.ctx.filter;\n                                this.ctx.filter = hcmFilterId1;\n                                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                                this.ctx.filter = savedFilter1;\n                            }\n                        }\n                    }\n                    _scaleImage(img1, inverseTransform1) {\n                        const width2 = img1.width;\n                        const height1 = img1.height;\n                        let widthScale1 = Math.max(Math.hypot(inverseTransform1[0], inverseTransform1[1]), 1);\n                        let heightScale1 = Math.max(Math.hypot(inverseTransform1[2], inverseTransform1[3]), 1);\n                        let paintWidth1 = width2, paintHeight1 = height1;\n                        let tmpCanvasId1 = \"prescale1\";\n                        let tmpCanvas1, tmpCtx1;\n                        while(widthScale1 > 2 && paintWidth1 > 1 || heightScale1 > 2 && paintHeight1 > 1){\n                            let newWidth1 = paintWidth1, newHeight1 = paintHeight1;\n                            if (widthScale1 > 2 && paintWidth1 > 1) {\n                                newWidth1 = paintWidth1 >= 16384 ? Math.floor(paintWidth1 / 2) - 1 || 1 : Math.ceil(paintWidth1 / 2);\n                                widthScale1 /= paintWidth1 / newWidth1;\n                            }\n                            if (heightScale1 > 2 && paintHeight1 > 1) {\n                                newHeight1 = paintHeight1 >= 16384 ? Math.floor(paintHeight1 / 2) - 1 || 1 : Math.ceil(paintHeight1) / 2;\n                                heightScale1 /= paintHeight1 / newHeight1;\n                            }\n                            tmpCanvas1 = this.cachedCanvases.getCanvas(tmpCanvasId1, newWidth1, newHeight1);\n                            tmpCtx1 = tmpCanvas1.context;\n                            tmpCtx1.clearRect(0, 0, newWidth1, newHeight1);\n                            tmpCtx1.drawImage(img1, 0, 0, paintWidth1, paintHeight1, 0, 0, newWidth1, newHeight1);\n                            img1 = tmpCanvas1.canvas;\n                            paintWidth1 = newWidth1;\n                            paintHeight1 = newHeight1;\n                            tmpCanvasId1 = tmpCanvasId1 === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n                        }\n                        return {\n                            img: img1,\n                            paintWidth: paintWidth1,\n                            paintHeight: paintHeight1\n                        };\n                    }\n                    _createMaskCanvas(img1) {\n                        const ctx1 = this.ctx;\n                        const { width: width2, height: height1 } = img1;\n                        const fillColor1 = this.current.fillColor;\n                        const isPatternFill1 = this.current.patternFill;\n                        const currentTransform1 = (0, _display_utils1.getCurrentTransform)(ctx1);\n                        let cache1, cacheKey1, scaled1, maskCanvas1;\n                        if ((img1.bitmap || img1.data) && img1.count > 1) {\n                            const mainKey1 = img1.bitmap || img1.data.buffer;\n                            cacheKey1 = JSON.stringify(isPatternFill1 ? currentTransform1 : [\n                                currentTransform1.slice(0, 4),\n                                fillColor1\n                            ]);\n                            cache1 = this._cachedBitmapsMap.get(mainKey1);\n                            if (!cache1) {\n                                cache1 = new Map();\n                                this._cachedBitmapsMap.set(mainKey1, cache1);\n                            }\n                            const cachedImage1 = cache1.get(cacheKey1);\n                            if (cachedImage1 && !isPatternFill1) {\n                                const offsetX1 = Math.round(Math.min(currentTransform1[0], currentTransform1[2]) + currentTransform1[4]);\n                                const offsetY1 = Math.round(Math.min(currentTransform1[1], currentTransform1[3]) + currentTransform1[5]);\n                                return {\n                                    canvas: cachedImage1,\n                                    offsetX: offsetX1,\n                                    offsetY: offsetY1\n                                };\n                            }\n                            scaled1 = cachedImage1;\n                        }\n                        if (!scaled1) {\n                            maskCanvas1 = this.cachedCanvases.getCanvas(\"maskCanvas\", width2, height1);\n                            putBinaryImageMask1(maskCanvas1.context, img1);\n                        }\n                        let maskToCanvas1 = _util1.Util.transform(currentTransform1, [\n                            1 / width2,\n                            0,\n                            0,\n                            -1 / height1,\n                            0,\n                            0\n                        ]);\n                        maskToCanvas1 = _util1.Util.transform(maskToCanvas1, [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            -height1\n                        ]);\n                        const cord11 = _util1.Util.applyTransform([\n                            0,\n                            0\n                        ], maskToCanvas1);\n                        const cord21 = _util1.Util.applyTransform([\n                            width2,\n                            height1\n                        ], maskToCanvas1);\n                        const rect3 = _util1.Util.normalizeRect([\n                            cord11[0],\n                            cord11[1],\n                            cord21[0],\n                            cord21[1]\n                        ]);\n                        const drawnWidth1 = Math.round(rect3[2] - rect3[0]) || 1;\n                        const drawnHeight1 = Math.round(rect3[3] - rect3[1]) || 1;\n                        const fillCanvas1 = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth1, drawnHeight1);\n                        const fillCtx1 = fillCanvas1.context;\n                        const offsetX1 = Math.min(cord11[0], cord21[0]);\n                        const offsetY1 = Math.min(cord11[1], cord21[1]);\n                        fillCtx1.translate(-offsetX1, -offsetY1);\n                        fillCtx1.transform(...maskToCanvas1);\n                        if (!scaled1) {\n                            scaled1 = this._scaleImage(maskCanvas1.canvas, (0, _display_utils1.getCurrentTransformInverse)(fillCtx1));\n                            scaled1 = scaled1.img;\n                            if (cache1 && isPatternFill1) {\n                                cache1.set(cacheKey1, scaled1);\n                            }\n                        }\n                        fillCtx1.imageSmoothingEnabled = getImageSmoothingEnabled1((0, _display_utils1.getCurrentTransform)(fillCtx1), img1.interpolate);\n                        drawImageAtIntegerCoords1(fillCtx1, scaled1, 0, 0, scaled1.width, scaled1.height, 0, 0, width2, height1);\n                        fillCtx1.globalCompositeOperation = \"source-in\";\n                        const inverse1 = _util1.Util.transform((0, _display_utils1.getCurrentTransformInverse)(fillCtx1), [\n                            1,\n                            0,\n                            0,\n                            1,\n                            -offsetX1,\n                            -offsetY1\n                        ]);\n                        fillCtx1.fillStyle = isPatternFill1 ? fillColor1.getPattern(ctx1, this, inverse1, _pattern_helper1.PathType.FILL) : fillColor1;\n                        fillCtx1.fillRect(0, 0, width2, height1);\n                        if (cache1 && !isPatternFill1) {\n                            this.cachedCanvases.delete(\"fillCanvas\");\n                            cache1.set(cacheKey1, fillCanvas1.canvas);\n                        }\n                        return {\n                            canvas: fillCanvas1.canvas,\n                            offsetX: Math.round(offsetX1),\n                            offsetY: Math.round(offsetY1)\n                        };\n                    }\n                    setLineWidth(width2) {\n                        if (width2 !== this.current.lineWidth) {\n                            this._cachedScaleForStroking[0] = -1;\n                        }\n                        this.current.lineWidth = width2;\n                        this.ctx.lineWidth = width2;\n                    }\n                    setLineCap(style1) {\n                        this.ctx.lineCap = LINE_CAP_STYLES1[style1];\n                    }\n                    setLineJoin(style1) {\n                        this.ctx.lineJoin = LINE_JOIN_STYLES1[style1];\n                    }\n                    setMiterLimit(limit1) {\n                        this.ctx.miterLimit = limit1;\n                    }\n                    setDash(dashArray1, dashPhase1) {\n                        const ctx1 = this.ctx;\n                        if (ctx1.setLineDash !== undefined) {\n                            ctx1.setLineDash(dashArray1);\n                            ctx1.lineDashOffset = dashPhase1;\n                        }\n                    }\n                    setRenderingIntent(intent1) {}\n                    setFlatness(flatness1) {}\n                    setGState(states1) {\n                        for (const [key1, value1] of states1){\n                            switch(key1){\n                                case \"LW\":\n                                    this.setLineWidth(value1);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value1);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value1);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value1);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value1[0], value1[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value1);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value1);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value1[0], value1[1]);\n                                    break;\n                                case \"CA\":\n                                    this.current.strokeAlpha = value1;\n                                    break;\n                                case \"ca\":\n                                    this.current.fillAlpha = value1;\n                                    this.ctx.globalAlpha = value1;\n                                    break;\n                                case \"BM\":\n                                    this.ctx.globalCompositeOperation = value1;\n                                    break;\n                                case \"SMask\":\n                                    this.current.activeSMask = value1 ? this.tempSMask : null;\n                                    this.tempSMask = null;\n                                    this.checkSMaskState();\n                                    break;\n                                case \"TR\":\n                                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value1);\n                                    break;\n                            }\n                        }\n                    }\n                    get inSMaskMode() {\n                        return !!this.suspendedCtx;\n                    }\n                    checkSMaskState() {\n                        const inSMaskMode1 = this.inSMaskMode;\n                        if (this.current.activeSMask && !inSMaskMode1) {\n                            this.beginSMaskMode();\n                        } else if (!this.current.activeSMask && inSMaskMode1) {\n                            this.endSMaskMode();\n                        }\n                    }\n                    beginSMaskMode() {\n                        if (this.inSMaskMode) {\n                            throw new Error(\"beginSMaskMode called while already in smask mode\");\n                        }\n                        const drawnWidth1 = this.ctx.canvas.width;\n                        const drawnHeight1 = this.ctx.canvas.height;\n                        const cacheId1 = \"smaskGroupAt\" + this.groupLevel;\n                        const scratchCanvas1 = this.cachedCanvases.getCanvas(cacheId1, drawnWidth1, drawnHeight1);\n                        this.suspendedCtx = this.ctx;\n                        this.ctx = scratchCanvas1.context;\n                        const ctx1 = this.ctx;\n                        ctx1.setTransform(...(0, _display_utils1.getCurrentTransform)(this.suspendedCtx));\n                        copyCtxState1(this.suspendedCtx, ctx1);\n                        mirrorContextOperations1(ctx1, this.suspendedCtx);\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                    }\n                    endSMaskMode() {\n                        if (!this.inSMaskMode) {\n                            throw new Error(\"endSMaskMode called while not in smask mode\");\n                        }\n                        this.ctx._removeMirroring();\n                        copyCtxState1(this.ctx, this.suspendedCtx);\n                        this.ctx = this.suspendedCtx;\n                        this.suspendedCtx = null;\n                    }\n                    compose(dirtyBox1) {\n                        if (!this.current.activeSMask) {\n                            return;\n                        }\n                        if (!dirtyBox1) {\n                            dirtyBox1 = [\n                                0,\n                                0,\n                                this.ctx.canvas.width,\n                                this.ctx.canvas.height\n                            ];\n                        } else {\n                            dirtyBox1[0] = Math.floor(dirtyBox1[0]);\n                            dirtyBox1[1] = Math.floor(dirtyBox1[1]);\n                            dirtyBox1[2] = Math.ceil(dirtyBox1[2]);\n                            dirtyBox1[3] = Math.ceil(dirtyBox1[3]);\n                        }\n                        const smask1 = this.current.activeSMask;\n                        const suspendedCtx1 = this.suspendedCtx;\n                        composeSMask1(suspendedCtx1, smask1, this.ctx, dirtyBox1);\n                        this.ctx.save();\n                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.ctx.restore();\n                    }\n                    save() {\n                        if (this.inSMaskMode) {\n                            copyCtxState1(this.ctx, this.suspendedCtx);\n                            this.suspendedCtx.save();\n                        } else {\n                            this.ctx.save();\n                        }\n                        const old1 = this.current;\n                        this.stateStack.push(old1);\n                        this.current = old1.clone();\n                    }\n                    restore() {\n                        if (this.stateStack.length === 0 && this.inSMaskMode) {\n                            this.endSMaskMode();\n                        }\n                        if (this.stateStack.length !== 0) {\n                            this.current = this.stateStack.pop();\n                            if (this.inSMaskMode) {\n                                this.suspendedCtx.restore();\n                                copyCtxState1(this.suspendedCtx, this.ctx);\n                            } else {\n                                this.ctx.restore();\n                            }\n                            this.checkSMaskState();\n                            this.pendingClip = null;\n                            this._cachedScaleForStroking[0] = -1;\n                            this._cachedGetSinglePixelWidth = null;\n                        }\n                    }\n                    transform(a1, b4, c4, d5, e1, f1) {\n                        this.ctx.transform(a1, b4, c4, d5, e1, f1);\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                    }\n                    constructPath(ops1, args1, minMax1) {\n                        const ctx1 = this.ctx;\n                        const current1 = this.current;\n                        let x4 = current1.x, y4 = current1.y;\n                        let startX1, startY1;\n                        const currentTransform1 = (0, _display_utils1.getCurrentTransform)(ctx1);\n                        const isScalingMatrix1 = currentTransform1[0] === 0 && currentTransform1[3] === 0 || currentTransform1[1] === 0 && currentTransform1[2] === 0;\n                        const minMaxForBezier1 = isScalingMatrix1 ? minMax1.slice(0) : null;\n                        for(let i1 = 0, j1 = 0, ii1 = ops1.length; i1 < ii1; i1++){\n                            switch(ops1[i1] | 0){\n                                case _util1.OPS.rectangle:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    const width2 = args1[j1++];\n                                    const height1 = args1[j1++];\n                                    const xw1 = x4 + width2;\n                                    const yh1 = y4 + height1;\n                                    ctx1.moveTo(x4, y4);\n                                    if (width2 === 0 || height1 === 0) {\n                                        ctx1.lineTo(xw1, yh1);\n                                    } else {\n                                        ctx1.lineTo(xw1, y4);\n                                        ctx1.lineTo(xw1, yh1);\n                                        ctx1.lineTo(x4, yh1);\n                                    }\n                                    if (!isScalingMatrix1) {\n                                        current1.updateRectMinMax(currentTransform1, [\n                                            x4,\n                                            y4,\n                                            xw1,\n                                            yh1\n                                        ]);\n                                    }\n                                    ctx1.closePath();\n                                    break;\n                                case _util1.OPS.moveTo:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    ctx1.moveTo(x4, y4);\n                                    if (!isScalingMatrix1) {\n                                        current1.updatePathMinMax(currentTransform1, x4, y4);\n                                    }\n                                    break;\n                                case _util1.OPS.lineTo:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    ctx1.lineTo(x4, y4);\n                                    if (!isScalingMatrix1) {\n                                        current1.updatePathMinMax(currentTransform1, x4, y4);\n                                    }\n                                    break;\n                                case _util1.OPS.curveTo:\n                                    startX1 = x4;\n                                    startY1 = y4;\n                                    x4 = args1[j1 + 4];\n                                    y4 = args1[j1 + 5];\n                                    ctx1.bezierCurveTo(args1[j1], args1[j1 + 1], args1[j1 + 2], args1[j1 + 3], x4, y4);\n                                    current1.updateCurvePathMinMax(currentTransform1, startX1, startY1, args1[j1], args1[j1 + 1], args1[j1 + 2], args1[j1 + 3], x4, y4, minMaxForBezier1);\n                                    j1 += 6;\n                                    break;\n                                case _util1.OPS.curveTo2:\n                                    startX1 = x4;\n                                    startY1 = y4;\n                                    ctx1.bezierCurveTo(x4, y4, args1[j1], args1[j1 + 1], args1[j1 + 2], args1[j1 + 3]);\n                                    current1.updateCurvePathMinMax(currentTransform1, startX1, startY1, x4, y4, args1[j1], args1[j1 + 1], args1[j1 + 2], args1[j1 + 3], minMaxForBezier1);\n                                    x4 = args1[j1 + 2];\n                                    y4 = args1[j1 + 3];\n                                    j1 += 4;\n                                    break;\n                                case _util1.OPS.curveTo3:\n                                    startX1 = x4;\n                                    startY1 = y4;\n                                    x4 = args1[j1 + 2];\n                                    y4 = args1[j1 + 3];\n                                    ctx1.bezierCurveTo(args1[j1], args1[j1 + 1], x4, y4, x4, y4);\n                                    current1.updateCurvePathMinMax(currentTransform1, startX1, startY1, args1[j1], args1[j1 + 1], x4, y4, x4, y4, minMaxForBezier1);\n                                    j1 += 4;\n                                    break;\n                                case _util1.OPS.closePath:\n                                    ctx1.closePath();\n                                    break;\n                            }\n                        }\n                        if (isScalingMatrix1) {\n                            current1.updateScalingPathMinMax(currentTransform1, minMaxForBezier1);\n                        }\n                        current1.setCurrentPoint(x4, y4);\n                    }\n                    closePath() {\n                        this.ctx.closePath();\n                    }\n                    stroke(consumePath1 = true) {\n                        const ctx1 = this.ctx;\n                        const strokeColor1 = this.current.strokeColor;\n                        ctx1.globalAlpha = this.current.strokeAlpha;\n                        if (this.contentVisible) {\n                            if (typeof strokeColor1 === \"object\" && strokeColor1?.getPattern) {\n                                ctx1.save();\n                                ctx1.strokeStyle = strokeColor1.getPattern(ctx1, this, (0, _display_utils1.getCurrentTransformInverse)(ctx1), _pattern_helper1.PathType.STROKE);\n                                this.rescaleAndStroke(false);\n                                ctx1.restore();\n                            } else {\n                                this.rescaleAndStroke(true);\n                            }\n                        }\n                        if (consumePath1) {\n                            this.consumePath(this.current.getClippedPathBoundingBox());\n                        }\n                        ctx1.globalAlpha = this.current.fillAlpha;\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    fill(consumePath1 = true) {\n                        const ctx1 = this.ctx;\n                        const fillColor1 = this.current.fillColor;\n                        const isPatternFill1 = this.current.patternFill;\n                        let needRestore1 = false;\n                        if (isPatternFill1) {\n                            ctx1.save();\n                            ctx1.fillStyle = fillColor1.getPattern(ctx1, this, (0, _display_utils1.getCurrentTransformInverse)(ctx1), _pattern_helper1.PathType.FILL);\n                            needRestore1 = true;\n                        }\n                        const intersect1 = this.current.getClippedPathBoundingBox();\n                        if (this.contentVisible && intersect1 !== null) {\n                            if (this.pendingEOFill) {\n                                ctx1.fill(\"evenodd\");\n                                this.pendingEOFill = false;\n                            } else {\n                                ctx1.fill();\n                            }\n                        }\n                        if (needRestore1) {\n                            ctx1.restore();\n                        }\n                        if (consumePath1) {\n                            this.consumePath(intersect1);\n                        }\n                    }\n                    eoFill() {\n                        this.pendingEOFill = true;\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.fill(false);\n                        this.stroke(false);\n                        this.consumePath();\n                    }\n                    eoFillStroke() {\n                        this.pendingEOFill = true;\n                        this.fillStroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.pendingEOFill = true;\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    endPath() {\n                        this.consumePath();\n                    }\n                    clip() {\n                        this.pendingClip = NORMAL_CLIP1;\n                    }\n                    eoClip() {\n                        this.pendingClip = EO_CLIP1;\n                    }\n                    beginText() {\n                        this.current.textMatrix = _util1.IDENTITY_MATRIX;\n                        this.current.textMatrixScale = 1;\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    endText() {\n                        const paths1 = this.pendingTextPaths;\n                        const ctx1 = this.ctx;\n                        if (paths1 === undefined) {\n                            ctx1.beginPath();\n                            return;\n                        }\n                        ctx1.save();\n                        ctx1.beginPath();\n                        for (const path1 of paths1){\n                            ctx1.setTransform(...path1.transform);\n                            ctx1.translate(path1.x, path1.y);\n                            path1.addToPath(ctx1, path1.fontSize);\n                        }\n                        ctx1.restore();\n                        ctx1.clip();\n                        ctx1.beginPath();\n                        delete this.pendingTextPaths;\n                    }\n                    setCharSpacing(spacing1) {\n                        this.current.charSpacing = spacing1;\n                    }\n                    setWordSpacing(spacing1) {\n                        this.current.wordSpacing = spacing1;\n                    }\n                    setHScale(scale1) {\n                        this.current.textHScale = scale1 / 100;\n                    }\n                    setLeading(leading1) {\n                        this.current.leading = -leading1;\n                    }\n                    setFont(fontRefName1, size1) {\n                        const fontObj1 = this.commonObjs.get(fontRefName1);\n                        const current1 = this.current;\n                        if (!fontObj1) {\n                            throw new Error(`Can't find font for ${fontRefName1}`);\n                        }\n                        current1.fontMatrix = fontObj1.fontMatrix || _util1.FONT_IDENTITY_MATRIX;\n                        if (current1.fontMatrix[0] === 0 || current1.fontMatrix[3] === 0) {\n                            (0, _util1.warn)(\"Invalid font matrix for font \" + fontRefName1);\n                        }\n                        if (size1 < 0) {\n                            size1 = -size1;\n                            current1.fontDirection = -1;\n                        } else {\n                            current1.fontDirection = 1;\n                        }\n                        this.current.font = fontObj1;\n                        this.current.fontSize = size1;\n                        if (fontObj1.isType3Font) {\n                            return;\n                        }\n                        const name1 = fontObj1.loadedName || \"sans-serif\";\n                        const typeface1 = fontObj1.systemFontInfo?.css || `\"${name1}\", ${fontObj1.fallbackName}`;\n                        let bold1 = \"normal\";\n                        if (fontObj1.black) {\n                            bold1 = \"900\";\n                        } else if (fontObj1.bold) {\n                            bold1 = \"bold\";\n                        }\n                        const italic1 = fontObj1.italic ? \"italic\" : \"normal\";\n                        let browserFontSize1 = size1;\n                        if (size1 < MIN_FONT_SIZE1) {\n                            browserFontSize1 = MIN_FONT_SIZE1;\n                        } else if (size1 > MAX_FONT_SIZE1) {\n                            browserFontSize1 = MAX_FONT_SIZE1;\n                        }\n                        this.current.fontSizeScale = size1 / browserFontSize1;\n                        this.ctx.font = `${italic1} ${bold1} ${browserFontSize1}px ${typeface1}`;\n                    }\n                    setTextRenderingMode(mode1) {\n                        this.current.textRenderingMode = mode1;\n                    }\n                    setTextRise(rise1) {\n                        this.current.textRise = rise1;\n                    }\n                    moveText(x4, y4) {\n                        this.current.x = this.current.lineX += x4;\n                        this.current.y = this.current.lineY += y4;\n                    }\n                    setLeadingMoveText(x4, y4) {\n                        this.setLeading(-y4);\n                        this.moveText(x4, y4);\n                    }\n                    setTextMatrix(a1, b4, c4, d5, e1, f1) {\n                        this.current.textMatrix = [\n                            a1,\n                            b4,\n                            c4,\n                            d5,\n                            e1,\n                            f1\n                        ];\n                        this.current.textMatrixScale = Math.hypot(a1, b4);\n                        this.current.x = this.current.lineX = 0;\n                        this.current.y = this.current.lineY = 0;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    paintChar(character1, x4, y4, patternTransform1) {\n                        const ctx1 = this.ctx;\n                        const current1 = this.current;\n                        const font1 = current1.font;\n                        const textRenderingMode1 = current1.textRenderingMode;\n                        const fontSize1 = current1.fontSize / current1.fontSizeScale;\n                        const fillStrokeMode1 = textRenderingMode1 & _util1.TextRenderingMode.FILL_STROKE_MASK;\n                        const isAddToPathSet1 = !!(textRenderingMode1 & _util1.TextRenderingMode.ADD_TO_PATH_FLAG);\n                        const patternFill1 = current1.patternFill && !font1.missingFile;\n                        let addToPath1;\n                        if (font1.disableFontFace || isAddToPathSet1 || patternFill1) {\n                            addToPath1 = font1.getPathGenerator(this.commonObjs, character1);\n                        }\n                        if (font1.disableFontFace || patternFill1) {\n                            ctx1.save();\n                            ctx1.translate(x4, y4);\n                            ctx1.beginPath();\n                            addToPath1(ctx1, fontSize1);\n                            if (patternTransform1) {\n                                ctx1.setTransform(...patternTransform1);\n                            }\n                            if (fillStrokeMode1 === _util1.TextRenderingMode.FILL || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                                ctx1.fill();\n                            }\n                            if (fillStrokeMode1 === _util1.TextRenderingMode.STROKE || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                                ctx1.stroke();\n                            }\n                            ctx1.restore();\n                        } else {\n                            if (fillStrokeMode1 === _util1.TextRenderingMode.FILL || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                                ctx1.fillText(character1, x4, y4);\n                            }\n                            if (fillStrokeMode1 === _util1.TextRenderingMode.STROKE || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                                ctx1.strokeText(character1, x4, y4);\n                            }\n                        }\n                        if (isAddToPathSet1) {\n                            const paths1 = this.pendingTextPaths ||= [];\n                            paths1.push({\n                                transform: (0, _display_utils1.getCurrentTransform)(ctx1),\n                                x: x4,\n                                y: y4,\n                                fontSize: fontSize1,\n                                addToPath: addToPath1\n                            });\n                        }\n                    }\n                    get isFontSubpixelAAEnabled() {\n                        const { context: ctx1 } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n                        ctx1.scale(1.5, 1);\n                        ctx1.fillText(\"I\", 0, 10);\n                        const data1 = ctx1.getImageData(0, 0, 10, 10).data;\n                        let enabled1 = false;\n                        for(let i1 = 3; i1 < data1.length; i1 += 4){\n                            if (data1[i1] > 0 && data1[i1] < 255) {\n                                enabled1 = true;\n                                break;\n                            }\n                        }\n                        return (0, _util1.shadow)(this, \"isFontSubpixelAAEnabled\", enabled1);\n                    }\n                    showText(glyphs1) {\n                        const current1 = this.current;\n                        const font1 = current1.font;\n                        if (font1.isType3Font) {\n                            return this.showType3Text(glyphs1);\n                        }\n                        const fontSize1 = current1.fontSize;\n                        if (fontSize1 === 0) {\n                            return undefined;\n                        }\n                        const ctx1 = this.ctx;\n                        const fontSizeScale1 = current1.fontSizeScale;\n                        const charSpacing1 = current1.charSpacing;\n                        const wordSpacing1 = current1.wordSpacing;\n                        const fontDirection1 = current1.fontDirection;\n                        const textHScale1 = current1.textHScale * fontDirection1;\n                        const glyphsLength1 = glyphs1.length;\n                        const vertical1 = font1.vertical;\n                        const spacingDir1 = vertical1 ? 1 : -1;\n                        const defaultVMetrics1 = font1.defaultVMetrics;\n                        const widthAdvanceScale1 = fontSize1 * current1.fontMatrix[0];\n                        const simpleFillText1 = current1.textRenderingMode === _util1.TextRenderingMode.FILL && !font1.disableFontFace && !current1.patternFill;\n                        ctx1.save();\n                        ctx1.transform(...current1.textMatrix);\n                        ctx1.translate(current1.x, current1.y + current1.textRise);\n                        if (fontDirection1 > 0) {\n                            ctx1.scale(textHScale1, -1);\n                        } else {\n                            ctx1.scale(textHScale1, 1);\n                        }\n                        let patternTransform1;\n                        if (current1.patternFill) {\n                            ctx1.save();\n                            const pattern1 = current1.fillColor.getPattern(ctx1, this, (0, _display_utils1.getCurrentTransformInverse)(ctx1), _pattern_helper1.PathType.FILL);\n                            patternTransform1 = (0, _display_utils1.getCurrentTransform)(ctx1);\n                            ctx1.restore();\n                            ctx1.fillStyle = pattern1;\n                        }\n                        let lineWidth1 = current1.lineWidth;\n                        const scale1 = current1.textMatrixScale;\n                        if (scale1 === 0 || lineWidth1 === 0) {\n                            const fillStrokeMode1 = current1.textRenderingMode & _util1.TextRenderingMode.FILL_STROKE_MASK;\n                            if (fillStrokeMode1 === _util1.TextRenderingMode.STROKE || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                                lineWidth1 = this.getSinglePixelWidth();\n                            }\n                        } else {\n                            lineWidth1 /= scale1;\n                        }\n                        if (fontSizeScale1 !== 1.0) {\n                            ctx1.scale(fontSizeScale1, fontSizeScale1);\n                            lineWidth1 /= fontSizeScale1;\n                        }\n                        ctx1.lineWidth = lineWidth1;\n                        if (font1.isInvalidPDFjsFont) {\n                            const chars1 = [];\n                            let width2 = 0;\n                            for (const glyph1 of glyphs1){\n                                chars1.push(glyph1.unicode);\n                                width2 += glyph1.width;\n                            }\n                            ctx1.fillText(chars1.join(\"\"), 0, 0);\n                            current1.x += width2 * widthAdvanceScale1 * textHScale1;\n                            ctx1.restore();\n                            this.compose();\n                            return undefined;\n                        }\n                        let x4 = 0, i1;\n                        for(i1 = 0; i1 < glyphsLength1; ++i1){\n                            const glyph1 = glyphs1[i1];\n                            if (typeof glyph1 === \"number\") {\n                                x4 += spacingDir1 * glyph1 * fontSize1 / 1000;\n                                continue;\n                            }\n                            let restoreNeeded1 = false;\n                            const spacing1 = (glyph1.isSpace ? wordSpacing1 : 0) + charSpacing1;\n                            const character1 = glyph1.fontChar;\n                            const accent1 = glyph1.accent;\n                            let scaledX1, scaledY1;\n                            let width2 = glyph1.width;\n                            if (vertical1) {\n                                const vmetric1 = glyph1.vmetric || defaultVMetrics1;\n                                const vx1 = -(glyph1.vmetric ? vmetric1[1] : width2 * 0.5) * widthAdvanceScale1;\n                                const vy1 = vmetric1[2] * widthAdvanceScale1;\n                                width2 = vmetric1 ? -vmetric1[0] : width2;\n                                scaledX1 = vx1 / fontSizeScale1;\n                                scaledY1 = (x4 + vy1) / fontSizeScale1;\n                            } else {\n                                scaledX1 = x4 / fontSizeScale1;\n                                scaledY1 = 0;\n                            }\n                            if (font1.remeasure && width2 > 0) {\n                                const measuredWidth1 = ctx1.measureText(character1).width * 1000 / fontSize1 * fontSizeScale1;\n                                if (width2 < measuredWidth1 && this.isFontSubpixelAAEnabled) {\n                                    const characterScaleX1 = width2 / measuredWidth1;\n                                    restoreNeeded1 = true;\n                                    ctx1.save();\n                                    ctx1.scale(characterScaleX1, 1);\n                                    scaledX1 /= characterScaleX1;\n                                } else if (width2 !== measuredWidth1) {\n                                    scaledX1 += (width2 - measuredWidth1) / 2000 * fontSize1 / fontSizeScale1;\n                                }\n                            }\n                            if (this.contentVisible && (glyph1.isInFont || font1.missingFile)) {\n                                if (simpleFillText1 && !accent1) {\n                                    ctx1.fillText(character1, scaledX1, scaledY1);\n                                } else {\n                                    this.paintChar(character1, scaledX1, scaledY1, patternTransform1);\n                                    if (accent1) {\n                                        const scaledAccentX1 = scaledX1 + fontSize1 * accent1.offset.x / fontSizeScale1;\n                                        const scaledAccentY1 = scaledY1 - fontSize1 * accent1.offset.y / fontSizeScale1;\n                                        this.paintChar(accent1.fontChar, scaledAccentX1, scaledAccentY1, patternTransform1);\n                                    }\n                                }\n                            }\n                            const charWidth1 = vertical1 ? width2 * widthAdvanceScale1 - spacing1 * fontDirection1 : width2 * widthAdvanceScale1 + spacing1 * fontDirection1;\n                            x4 += charWidth1;\n                            if (restoreNeeded1) {\n                                ctx1.restore();\n                            }\n                        }\n                        if (vertical1) {\n                            current1.y -= x4;\n                        } else {\n                            current1.x += x4 * textHScale1;\n                        }\n                        ctx1.restore();\n                        this.compose();\n                        return undefined;\n                    }\n                    showType3Text(glyphs1) {\n                        const ctx1 = this.ctx;\n                        const current1 = this.current;\n                        const font1 = current1.font;\n                        const fontSize1 = current1.fontSize;\n                        const fontDirection1 = current1.fontDirection;\n                        const spacingDir1 = font1.vertical ? 1 : -1;\n                        const charSpacing1 = current1.charSpacing;\n                        const wordSpacing1 = current1.wordSpacing;\n                        const textHScale1 = current1.textHScale * fontDirection1;\n                        const fontMatrix1 = current1.fontMatrix || _util1.FONT_IDENTITY_MATRIX;\n                        const glyphsLength1 = glyphs1.length;\n                        const isTextInvisible1 = current1.textRenderingMode === _util1.TextRenderingMode.INVISIBLE;\n                        let i1, glyph1, width2, spacingLength1;\n                        if (isTextInvisible1 || fontSize1 === 0) {\n                            return;\n                        }\n                        this._cachedScaleForStroking[0] = -1;\n                        this._cachedGetSinglePixelWidth = null;\n                        ctx1.save();\n                        ctx1.transform(...current1.textMatrix);\n                        ctx1.translate(current1.x, current1.y);\n                        ctx1.scale(textHScale1, fontDirection1);\n                        for(i1 = 0; i1 < glyphsLength1; ++i1){\n                            glyph1 = glyphs1[i1];\n                            if (typeof glyph1 === \"number\") {\n                                spacingLength1 = spacingDir1 * glyph1 * fontSize1 / 1000;\n                                this.ctx.translate(spacingLength1, 0);\n                                current1.x += spacingLength1 * textHScale1;\n                                continue;\n                            }\n                            const spacing1 = (glyph1.isSpace ? wordSpacing1 : 0) + charSpacing1;\n                            const operatorList1 = font1.charProcOperatorList[glyph1.operatorListId];\n                            if (!operatorList1) {\n                                (0, _util1.warn)(`Type3 character \"${glyph1.operatorListId}\" is not available.`);\n                                continue;\n                            }\n                            if (this.contentVisible) {\n                                this.processingType3 = glyph1;\n                                this.save();\n                                ctx1.scale(fontSize1, fontSize1);\n                                ctx1.transform(...fontMatrix1);\n                                this.executeOperatorList(operatorList1);\n                                this.restore();\n                            }\n                            const transformed1 = _util1.Util.applyTransform([\n                                glyph1.width,\n                                0\n                            ], fontMatrix1);\n                            width2 = transformed1[0] * fontSize1 + spacing1;\n                            ctx1.translate(width2, 0);\n                            current1.x += width2 * textHScale1;\n                        }\n                        ctx1.restore();\n                        this.processingType3 = null;\n                    }\n                    setCharWidth(xWidth1, yWidth1) {}\n                    setCharWidthAndBounds(xWidth1, yWidth1, llx1, lly1, urx1, ury1) {\n                        this.ctx.rect(llx1, lly1, urx1 - llx1, ury1 - lly1);\n                        this.ctx.clip();\n                        this.endPath();\n                    }\n                    getColorN_Pattern(IR1) {\n                        let pattern1;\n                        if (IR1[0] === \"TilingPattern\") {\n                            const color1 = IR1[1];\n                            const baseTransform1 = this.baseTransform || (0, _display_utils1.getCurrentTransform)(this.ctx);\n                            const canvasGraphicsFactory1 = {\n                                createCanvasGraphics: (ctx1)=>{\n                                    return new CanvasGraphics1(ctx1, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                                        optionalContentConfig: this.optionalContentConfig,\n                                        markedContentStack: this.markedContentStack\n                                    });\n                                }\n                            };\n                            pattern1 = new _pattern_helper1.TilingPattern(IR1, color1, this.ctx, canvasGraphicsFactory1, baseTransform1);\n                        } else {\n                            pattern1 = this._getPattern(IR1[1], IR1[2]);\n                        }\n                        return pattern1;\n                    }\n                    setStrokeColorN() {\n                        this.current.strokeColor = this.getColorN_Pattern(arguments);\n                    }\n                    setFillColorN() {\n                        this.current.fillColor = this.getColorN_Pattern(arguments);\n                        this.current.patternFill = true;\n                    }\n                    setStrokeRGBColor(r1, g1, b4) {\n                        const color1 = _util1.Util.makeHexColor(r1, g1, b4);\n                        this.ctx.strokeStyle = color1;\n                        this.current.strokeColor = color1;\n                    }\n                    setFillRGBColor(r1, g1, b4) {\n                        const color1 = _util1.Util.makeHexColor(r1, g1, b4);\n                        this.ctx.fillStyle = color1;\n                        this.current.fillColor = color1;\n                        this.current.patternFill = false;\n                    }\n                    _getPattern(objId1, matrix1 = null) {\n                        let pattern1;\n                        if (this.cachedPatterns.has(objId1)) {\n                            pattern1 = this.cachedPatterns.get(objId1);\n                        } else {\n                            pattern1 = (0, _pattern_helper1.getShadingPattern)(this.getObject(objId1));\n                            this.cachedPatterns.set(objId1, pattern1);\n                        }\n                        if (matrix1) {\n                            pattern1.matrix = matrix1;\n                        }\n                        return pattern1;\n                    }\n                    shadingFill(objId1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx1 = this.ctx;\n                        this.save();\n                        const pattern1 = this._getPattern(objId1);\n                        ctx1.fillStyle = pattern1.getPattern(ctx1, this, (0, _display_utils1.getCurrentTransformInverse)(ctx1), _pattern_helper1.PathType.SHADING);\n                        const inv1 = (0, _display_utils1.getCurrentTransformInverse)(ctx1);\n                        if (inv1) {\n                            const { width: width2, height: height1 } = ctx1.canvas;\n                            const [x01, y01, x11, y11] = _util1.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                width2,\n                                height1\n                            ], inv1);\n                            this.ctx.fillRect(x01, y01, x11 - x01, y11 - y01);\n                        } else {\n                            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n                        }\n                        this.compose(this.current.getClippedPathBoundingBox());\n                        this.restore();\n                    }\n                    beginInlineImage() {\n                        (0, _util1.unreachable)(\"Should not call beginInlineImage\");\n                    }\n                    beginImageData() {\n                        (0, _util1.unreachable)(\"Should not call beginImageData\");\n                    }\n                    paintFormXObjectBegin(matrix1, bbox1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        this.baseTransformStack.push(this.baseTransform);\n                        if (Array.isArray(matrix1) && matrix1.length === 6) {\n                            this.transform(...matrix1);\n                        }\n                        this.baseTransform = (0, _display_utils1.getCurrentTransform)(this.ctx);\n                        if (bbox1) {\n                            const width2 = bbox1[2] - bbox1[0];\n                            const height1 = bbox1[3] - bbox1[1];\n                            this.ctx.rect(bbox1[0], bbox1[1], width2, height1);\n                            this.current.updateRectMinMax((0, _display_utils1.getCurrentTransform)(this.ctx), bbox1);\n                            this.clip();\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.restore();\n                        this.baseTransform = this.baseTransformStack.pop();\n                    }\n                    beginGroup(group1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.save();\n                        if (this.inSMaskMode) {\n                            this.endSMaskMode();\n                            this.current.activeSMask = null;\n                        }\n                        const currentCtx1 = this.ctx;\n                        if (!group1.isolated) {\n                            (0, _util1.info)(\"TODO: Support non-isolated groups.\");\n                        }\n                        if (group1.knockout) {\n                            (0, _util1.warn)(\"Knockout groups not supported.\");\n                        }\n                        const currentTransform1 = (0, _display_utils1.getCurrentTransform)(currentCtx1);\n                        if (group1.matrix) {\n                            currentCtx1.transform(...group1.matrix);\n                        }\n                        if (!group1.bbox) {\n                            throw new Error(\"Bounding box is required.\");\n                        }\n                        let bounds1 = _util1.Util.getAxialAlignedBoundingBox(group1.bbox, (0, _display_utils1.getCurrentTransform)(currentCtx1));\n                        const canvasBounds1 = [\n                            0,\n                            0,\n                            currentCtx1.canvas.width,\n                            currentCtx1.canvas.height\n                        ];\n                        bounds1 = _util1.Util.intersect(bounds1, canvasBounds1) || [\n                            0,\n                            0,\n                            0,\n                            0\n                        ];\n                        const offsetX1 = Math.floor(bounds1[0]);\n                        const offsetY1 = Math.floor(bounds1[1]);\n                        let drawnWidth1 = Math.max(Math.ceil(bounds1[2]) - offsetX1, 1);\n                        let drawnHeight1 = Math.max(Math.ceil(bounds1[3]) - offsetY1, 1);\n                        let scaleX1 = 1, scaleY1 = 1;\n                        if (drawnWidth1 > MAX_GROUP_SIZE1) {\n                            scaleX1 = drawnWidth1 / MAX_GROUP_SIZE1;\n                            drawnWidth1 = MAX_GROUP_SIZE1;\n                        }\n                        if (drawnHeight1 > MAX_GROUP_SIZE1) {\n                            scaleY1 = drawnHeight1 / MAX_GROUP_SIZE1;\n                            drawnHeight1 = MAX_GROUP_SIZE1;\n                        }\n                        this.current.startNewPathAndClipBox([\n                            0,\n                            0,\n                            drawnWidth1,\n                            drawnHeight1\n                        ]);\n                        let cacheId1 = \"groupAt\" + this.groupLevel;\n                        if (group1.smask) {\n                            cacheId1 += \"_smask_\" + this.smaskCounter++ % 2;\n                        }\n                        const scratchCanvas1 = this.cachedCanvases.getCanvas(cacheId1, drawnWidth1, drawnHeight1);\n                        const groupCtx1 = scratchCanvas1.context;\n                        groupCtx1.scale(1 / scaleX1, 1 / scaleY1);\n                        groupCtx1.translate(-offsetX1, -offsetY1);\n                        groupCtx1.transform(...currentTransform1);\n                        if (group1.smask) {\n                            this.smaskStack.push({\n                                canvas: scratchCanvas1.canvas,\n                                context: groupCtx1,\n                                offsetX: offsetX1,\n                                offsetY: offsetY1,\n                                scaleX: scaleX1,\n                                scaleY: scaleY1,\n                                subtype: group1.smask.subtype,\n                                backdrop: group1.smask.backdrop,\n                                transferMap: group1.smask.transferMap || null,\n                                startTransformInverse: null\n                            });\n                        } else {\n                            currentCtx1.setTransform(1, 0, 0, 1, 0, 0);\n                            currentCtx1.translate(offsetX1, offsetY1);\n                            currentCtx1.scale(scaleX1, scaleY1);\n                            currentCtx1.save();\n                        }\n                        copyCtxState1(currentCtx1, groupCtx1);\n                        this.ctx = groupCtx1;\n                        this.setGState([\n                            [\n                                \"BM\",\n                                \"source-over\"\n                            ],\n                            [\n                                \"ca\",\n                                1\n                            ],\n                            [\n                                \"CA\",\n                                1\n                            ]\n                        ]);\n                        this.groupStack.push(currentCtx1);\n                        this.groupLevel++;\n                    }\n                    endGroup(group1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.groupLevel--;\n                        const groupCtx1 = this.ctx;\n                        const ctx1 = this.groupStack.pop();\n                        this.ctx = ctx1;\n                        this.ctx.imageSmoothingEnabled = false;\n                        if (group1.smask) {\n                            this.tempSMask = this.smaskStack.pop();\n                            this.restore();\n                        } else {\n                            this.ctx.restore();\n                            const currentMtx1 = (0, _display_utils1.getCurrentTransform)(this.ctx);\n                            this.restore();\n                            this.ctx.save();\n                            this.ctx.setTransform(...currentMtx1);\n                            const dirtyBox1 = _util1.Util.getAxialAlignedBoundingBox([\n                                0,\n                                0,\n                                groupCtx1.canvas.width,\n                                groupCtx1.canvas.height\n                            ], currentMtx1);\n                            this.ctx.drawImage(groupCtx1.canvas, 0, 0);\n                            this.ctx.restore();\n                            this.compose(dirtyBox1);\n                        }\n                    }\n                    beginAnnotation(id1, rect3, transform1, matrix1, hasOwnCanvas1) {\n                        this.#restoreInitialState();\n                        resetCtxToDefault1(this.ctx);\n                        this.ctx.save();\n                        this.save();\n                        if (this.baseTransform) {\n                            this.ctx.setTransform(...this.baseTransform);\n                        }\n                        if (Array.isArray(rect3) && rect3.length === 4) {\n                            const width2 = rect3[2] - rect3[0];\n                            const height1 = rect3[3] - rect3[1];\n                            if (hasOwnCanvas1 && this.annotationCanvasMap) {\n                                transform1 = transform1.slice();\n                                transform1[4] -= rect3[0];\n                                transform1[5] -= rect3[1];\n                                rect3 = rect3.slice();\n                                rect3[0] = rect3[1] = 0;\n                                rect3[2] = width2;\n                                rect3[3] = height1;\n                                const [scaleX1, scaleY1] = _util1.Util.singularValueDecompose2dScale((0, _display_utils1.getCurrentTransform)(this.ctx));\n                                const { viewportScale: viewportScale1 } = this;\n                                const canvasWidth1 = Math.ceil(width2 * this.outputScaleX * viewportScale1);\n                                const canvasHeight1 = Math.ceil(height1 * this.outputScaleY * viewportScale1);\n                                this.annotationCanvas = this.canvasFactory.create(canvasWidth1, canvasHeight1);\n                                const { canvas: canvas1, context: context1 } = this.annotationCanvas;\n                                this.annotationCanvasMap.set(id1, canvas1);\n                                this.annotationCanvas.savedCtx = this.ctx;\n                                this.ctx = context1;\n                                this.ctx.save();\n                                this.ctx.setTransform(scaleX1, 0, 0, -scaleY1, 0, height1 * scaleY1);\n                                resetCtxToDefault1(this.ctx);\n                            } else {\n                                resetCtxToDefault1(this.ctx);\n                                this.ctx.rect(rect3[0], rect3[1], width2, height1);\n                                this.ctx.clip();\n                                this.endPath();\n                            }\n                        }\n                        this.current = new CanvasExtraState1(this.ctx.canvas.width, this.ctx.canvas.height);\n                        this.transform(...transform1);\n                        this.transform(...matrix1);\n                    }\n                    endAnnotation() {\n                        if (this.annotationCanvas) {\n                            this.ctx.restore();\n                            this.#drawFilter();\n                            this.ctx = this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas.savedCtx;\n                            delete this.annotationCanvas;\n                        }\n                    }\n                    paintImageMaskXObject(img1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const count1 = img1.count;\n                        img1 = this.getObject(img1.data, img1);\n                        img1.count = count1;\n                        const ctx1 = this.ctx;\n                        const glyph1 = this.processingType3;\n                        if (glyph1) {\n                            if (glyph1.compiled === undefined) {\n                                glyph1.compiled = compileType3Glyph1(img1);\n                            }\n                            if (glyph1.compiled) {\n                                glyph1.compiled(ctx1);\n                                return;\n                            }\n                        }\n                        const mask1 = this._createMaskCanvas(img1);\n                        const maskCanvas1 = mask1.canvas;\n                        ctx1.save();\n                        ctx1.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx1.drawImage(maskCanvas1, mask1.offsetX, mask1.offsetY);\n                        ctx1.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectRepeat(img1, scaleX1, skewX1 = 0, skewY1 = 0, scaleY1, positions1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        img1 = this.getObject(img1.data, img1);\n                        const ctx1 = this.ctx;\n                        ctx1.save();\n                        const currentTransform1 = (0, _display_utils1.getCurrentTransform)(ctx1);\n                        ctx1.transform(scaleX1, skewX1, skewY1, scaleY1, 0, 0);\n                        const mask1 = this._createMaskCanvas(img1);\n                        ctx1.setTransform(1, 0, 0, 1, mask1.offsetX - currentTransform1[4], mask1.offsetY - currentTransform1[5]);\n                        for(let i1 = 0, ii1 = positions1.length; i1 < ii1; i1 += 2){\n                            const trans1 = _util1.Util.transform(currentTransform1, [\n                                scaleX1,\n                                skewX1,\n                                skewY1,\n                                scaleY1,\n                                positions1[i1],\n                                positions1[i1 + 1]\n                            ]);\n                            const [x4, y4] = _util1.Util.applyTransform([\n                                0,\n                                0\n                            ], trans1);\n                            ctx1.drawImage(mask1.canvas, x4, y4);\n                        }\n                        ctx1.restore();\n                        this.compose();\n                    }\n                    paintImageMaskXObjectGroup(images1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx1 = this.ctx;\n                        const fillColor1 = this.current.fillColor;\n                        const isPatternFill1 = this.current.patternFill;\n                        for (const image1 of images1){\n                            const { data: data1, width: width2, height: height1, transform: transform1 } = image1;\n                            const maskCanvas1 = this.cachedCanvases.getCanvas(\"maskCanvas\", width2, height1);\n                            const maskCtx1 = maskCanvas1.context;\n                            maskCtx1.save();\n                            const img1 = this.getObject(data1, image1);\n                            putBinaryImageMask1(maskCtx1, img1);\n                            maskCtx1.globalCompositeOperation = \"source-in\";\n                            maskCtx1.fillStyle = isPatternFill1 ? fillColor1.getPattern(maskCtx1, this, (0, _display_utils1.getCurrentTransformInverse)(ctx1), _pattern_helper1.PathType.FILL) : fillColor1;\n                            maskCtx1.fillRect(0, 0, width2, height1);\n                            maskCtx1.restore();\n                            ctx1.save();\n                            ctx1.transform(...transform1);\n                            ctx1.scale(1, -1);\n                            drawImageAtIntegerCoords1(ctx1, maskCanvas1.canvas, 0, 0, width2, height1, 0, -1, 1, 1);\n                            ctx1.restore();\n                        }\n                        this.compose();\n                    }\n                    paintImageXObject(objId1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData1 = this.getObject(objId1);\n                        if (!imgData1) {\n                            (0, _util1.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData1);\n                    }\n                    paintImageXObjectRepeat(objId1, scaleX1, scaleY1, positions1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const imgData1 = this.getObject(objId1);\n                        if (!imgData1) {\n                            (0, _util1.warn)(\"Dependent image isn't ready yet\");\n                            return;\n                        }\n                        const width2 = imgData1.width;\n                        const height1 = imgData1.height;\n                        const map1 = [];\n                        for(let i1 = 0, ii1 = positions1.length; i1 < ii1; i1 += 2){\n                            map1.push({\n                                transform: [\n                                    scaleX1,\n                                    0,\n                                    0,\n                                    scaleY1,\n                                    positions1[i1],\n                                    positions1[i1 + 1]\n                                ],\n                                x: 0,\n                                y: 0,\n                                w: width2,\n                                h: height1\n                            });\n                        }\n                        this.paintInlineImageXObjectGroup(imgData1, map1);\n                    }\n                    applyTransferMapsToCanvas(ctx1) {\n                        if (this.current.transferMaps !== \"none\") {\n                            ctx1.filter = this.current.transferMaps;\n                            ctx1.drawImage(ctx1.canvas, 0, 0);\n                            ctx1.filter = \"none\";\n                        }\n                        return ctx1.canvas;\n                    }\n                    applyTransferMapsToBitmap(imgData1) {\n                        if (this.current.transferMaps === \"none\") {\n                            return imgData1.bitmap;\n                        }\n                        const { bitmap: bitmap1, width: width2, height: height1 } = imgData1;\n                        const tmpCanvas1 = this.cachedCanvases.getCanvas(\"inlineImage\", width2, height1);\n                        const tmpCtx1 = tmpCanvas1.context;\n                        tmpCtx1.filter = this.current.transferMaps;\n                        tmpCtx1.drawImage(bitmap1, 0, 0);\n                        tmpCtx1.filter = \"none\";\n                        return tmpCanvas1.canvas;\n                    }\n                    paintInlineImageXObject(imgData1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const width2 = imgData1.width;\n                        const height1 = imgData1.height;\n                        const ctx1 = this.ctx;\n                        this.save();\n                        if (!_util1.isNodeJS) {\n                            const { filter: filter1 } = ctx1;\n                            if (filter1 !== \"none\" && filter1 !== \"\") {\n                                ctx1.filter = \"none\";\n                            }\n                        }\n                        ctx1.scale(1 / width2, -1 / height1);\n                        let imgToPaint1;\n                        if (imgData1.bitmap) {\n                            imgToPaint1 = this.applyTransferMapsToBitmap(imgData1);\n                        } else if (typeof HTMLElement === \"function\" && imgData1 instanceof HTMLElement || !imgData1.data) {\n                            imgToPaint1 = imgData1;\n                        } else {\n                            const tmpCanvas1 = this.cachedCanvases.getCanvas(\"inlineImage\", width2, height1);\n                            const tmpCtx1 = tmpCanvas1.context;\n                            putBinaryImageData1(tmpCtx1, imgData1);\n                            imgToPaint1 = this.applyTransferMapsToCanvas(tmpCtx1);\n                        }\n                        const scaled1 = this._scaleImage(imgToPaint1, (0, _display_utils1.getCurrentTransformInverse)(ctx1));\n                        ctx1.imageSmoothingEnabled = getImageSmoothingEnabled1((0, _display_utils1.getCurrentTransform)(ctx1), imgData1.interpolate);\n                        drawImageAtIntegerCoords1(ctx1, scaled1.img, 0, 0, scaled1.paintWidth, scaled1.paintHeight, 0, -height1, width2, height1);\n                        this.compose();\n                        this.restore();\n                    }\n                    paintInlineImageXObjectGroup(imgData1, map1) {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        const ctx1 = this.ctx;\n                        let imgToPaint1;\n                        if (imgData1.bitmap) {\n                            imgToPaint1 = imgData1.bitmap;\n                        } else {\n                            const w1 = imgData1.width;\n                            const h3 = imgData1.height;\n                            const tmpCanvas1 = this.cachedCanvases.getCanvas(\"inlineImage\", w1, h3);\n                            const tmpCtx1 = tmpCanvas1.context;\n                            putBinaryImageData1(tmpCtx1, imgData1);\n                            imgToPaint1 = this.applyTransferMapsToCanvas(tmpCtx1);\n                        }\n                        for (const entry1 of map1){\n                            ctx1.save();\n                            ctx1.transform(...entry1.transform);\n                            ctx1.scale(1, -1);\n                            drawImageAtIntegerCoords1(ctx1, imgToPaint1, entry1.x, entry1.y, entry1.w, entry1.h, 0, -1, 1, 1);\n                            ctx1.restore();\n                        }\n                        this.compose();\n                    }\n                    paintSolidColorImageMask() {\n                        if (!this.contentVisible) {\n                            return;\n                        }\n                        this.ctx.fillRect(0, 0, 1, 1);\n                        this.compose();\n                    }\n                    markPoint(tag1) {}\n                    markPointProps(tag1, properties1) {}\n                    beginMarkedContent(tag1) {\n                        this.markedContentStack.push({\n                            visible: true\n                        });\n                    }\n                    beginMarkedContentProps(tag1, properties1) {\n                        if (tag1 === \"OC\") {\n                            this.markedContentStack.push({\n                                visible: this.optionalContentConfig.isVisible(properties1)\n                            });\n                        } else {\n                            this.markedContentStack.push({\n                                visible: true\n                            });\n                        }\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    endMarkedContent() {\n                        this.markedContentStack.pop();\n                        this.contentVisible = this.isContentVisible();\n                    }\n                    beginCompat() {}\n                    endCompat() {}\n                    consumePath(clipBox1) {\n                        const isEmpty1 = this.current.isEmptyClip();\n                        if (this.pendingClip) {\n                            this.current.updateClipFromPath();\n                        }\n                        if (!this.pendingClip) {\n                            this.compose(clipBox1);\n                        }\n                        const ctx1 = this.ctx;\n                        if (this.pendingClip) {\n                            if (!isEmpty1) {\n                                if (this.pendingClip === EO_CLIP1) {\n                                    ctx1.clip(\"evenodd\");\n                                } else {\n                                    ctx1.clip();\n                                }\n                            }\n                            this.pendingClip = null;\n                        }\n                        this.current.startNewPathAndClipBox(this.current.clipBox);\n                        ctx1.beginPath();\n                    }\n                    getSinglePixelWidth() {\n                        if (!this._cachedGetSinglePixelWidth) {\n                            const m3 = (0, _display_utils1.getCurrentTransform)(this.ctx);\n                            if (m3[1] === 0 && m3[2] === 0) {\n                                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m3[0]), Math.abs(m3[3]));\n                            } else {\n                                const absDet1 = Math.abs(m3[0] * m3[3] - m3[2] * m3[1]);\n                                const normX1 = Math.hypot(m3[0], m3[2]);\n                                const normY1 = Math.hypot(m3[1], m3[3]);\n                                this._cachedGetSinglePixelWidth = Math.max(normX1, normY1) / absDet1;\n                            }\n                        }\n                        return this._cachedGetSinglePixelWidth;\n                    }\n                    getScaleForStroking() {\n                        if (this._cachedScaleForStroking[0] === -1) {\n                            const { lineWidth: lineWidth1 } = this.current;\n                            const { a: a1, b: b4, c: c4, d: d5 } = this.ctx.getTransform();\n                            let scaleX1, scaleY1;\n                            if (b4 === 0 && c4 === 0) {\n                                const normX1 = Math.abs(a1);\n                                const normY1 = Math.abs(d5);\n                                if (normX1 === normY1) {\n                                    if (lineWidth1 === 0) {\n                                        scaleX1 = scaleY1 = 1 / normX1;\n                                    } else {\n                                        const scaledLineWidth1 = normX1 * lineWidth1;\n                                        scaleX1 = scaleY1 = scaledLineWidth1 < 1 ? 1 / scaledLineWidth1 : 1;\n                                    }\n                                } else if (lineWidth1 === 0) {\n                                    scaleX1 = 1 / normX1;\n                                    scaleY1 = 1 / normY1;\n                                } else {\n                                    const scaledXLineWidth1 = normX1 * lineWidth1;\n                                    const scaledYLineWidth1 = normY1 * lineWidth1;\n                                    scaleX1 = scaledXLineWidth1 < 1 ? 1 / scaledXLineWidth1 : 1;\n                                    scaleY1 = scaledYLineWidth1 < 1 ? 1 / scaledYLineWidth1 : 1;\n                                }\n                            } else {\n                                const absDet1 = Math.abs(a1 * d5 - b4 * c4);\n                                const normX1 = Math.hypot(a1, b4);\n                                const normY1 = Math.hypot(c4, d5);\n                                if (lineWidth1 === 0) {\n                                    scaleX1 = normY1 / absDet1;\n                                    scaleY1 = normX1 / absDet1;\n                                } else {\n                                    const baseArea1 = lineWidth1 * absDet1;\n                                    scaleX1 = normY1 > baseArea1 ? normY1 / baseArea1 : 1;\n                                    scaleY1 = normX1 > baseArea1 ? normX1 / baseArea1 : 1;\n                                }\n                            }\n                            this._cachedScaleForStroking[0] = scaleX1;\n                            this._cachedScaleForStroking[1] = scaleY1;\n                        }\n                        return this._cachedScaleForStroking;\n                    }\n                    rescaleAndStroke(saveRestore1) {\n                        const { ctx: ctx1 } = this;\n                        const { lineWidth: lineWidth1 } = this.current;\n                        const [scaleX1, scaleY1] = this.getScaleForStroking();\n                        ctx1.lineWidth = lineWidth1 || 1;\n                        if (scaleX1 === 1 && scaleY1 === 1) {\n                            ctx1.stroke();\n                            return;\n                        }\n                        const dashes1 = ctx1.getLineDash();\n                        if (saveRestore1) {\n                            ctx1.save();\n                        }\n                        ctx1.scale(scaleX1, scaleY1);\n                        if (dashes1.length > 0) {\n                            const scale1 = Math.max(scaleX1, scaleY1);\n                            ctx1.setLineDash(dashes1.map((x4)=>x4 / scale1));\n                            ctx1.lineDashOffset /= scale1;\n                        }\n                        ctx1.stroke();\n                        if (saveRestore1) {\n                            ctx1.restore();\n                        }\n                    }\n                    isContentVisible() {\n                        for(let i1 = this.markedContentStack.length - 1; i1 >= 0; i1--){\n                            if (!this.markedContentStack[i1].visible) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n                exports1.CanvasGraphics = CanvasGraphics1;\n                for(const op1 in _util1.OPS){\n                    if (CanvasGraphics1.prototype[op1] !== undefined) {\n                        CanvasGraphics1.prototype[_util1.OPS[op1]] = CanvasGraphics1.prototype[op1];\n                    }\n                }\n            /***/ },\n            /* 12 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TilingPattern = exports1.PathType = void 0;\n                exports1.getShadingPattern = getShadingPattern1;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                const PathType1 = {\n                    FILL: \"Fill\",\n                    STROKE: \"Stroke\",\n                    SHADING: \"Shading\"\n                };\n                exports1.PathType = PathType1;\n                function applyBoundingBox1(ctx1, bbox1) {\n                    if (!bbox1) {\n                        return;\n                    }\n                    const width2 = bbox1[2] - bbox1[0];\n                    const height1 = bbox1[3] - bbox1[1];\n                    const region1 = new Path2D();\n                    region1.rect(bbox1[0], bbox1[1], width2, height1);\n                    ctx1.clip(region1);\n                }\n                class BaseShadingPattern1 {\n                    constructor(){\n                        if (this.constructor === BaseShadingPattern1) {\n                            (0, _util1.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n                        }\n                    }\n                    getPattern() {\n                        (0, _util1.unreachable)(\"Abstract method `getPattern` called.\");\n                    }\n                }\n                class RadialAxialShadingPattern1 extends BaseShadingPattern1 {\n                    constructor(IR1){\n                        super();\n                        this._type = IR1[1];\n                        this._bbox = IR1[2];\n                        this._colorStops = IR1[3];\n                        this._p0 = IR1[4];\n                        this._p1 = IR1[5];\n                        this._r0 = IR1[6];\n                        this._r1 = IR1[7];\n                        this.matrix = null;\n                    }\n                    _createGradient(ctx1) {\n                        let grad1;\n                        if (this._type === \"axial\") {\n                            grad1 = ctx1.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n                        } else if (this._type === \"radial\") {\n                            grad1 = ctx1.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n                        }\n                        for (const colorStop1 of this._colorStops){\n                            grad1.addColorStop(colorStop1[0], colorStop1[1]);\n                        }\n                        return grad1;\n                    }\n                    getPattern(ctx1, owner1, inverse1, pathType1) {\n                        let pattern1;\n                        if (pathType1 === PathType1.STROKE || pathType1 === PathType1.FILL) {\n                            const ownerBBox1 = owner1.current.getClippedPathBoundingBox(pathType1, (0, _display_utils1.getCurrentTransform)(ctx1)) || [\n                                0,\n                                0,\n                                0,\n                                0\n                            ];\n                            const width2 = Math.ceil(ownerBBox1[2] - ownerBBox1[0]) || 1;\n                            const height1 = Math.ceil(ownerBBox1[3] - ownerBBox1[1]) || 1;\n                            const tmpCanvas1 = owner1.cachedCanvases.getCanvas(\"pattern\", width2, height1, true);\n                            const tmpCtx1 = tmpCanvas1.context;\n                            tmpCtx1.clearRect(0, 0, tmpCtx1.canvas.width, tmpCtx1.canvas.height);\n                            tmpCtx1.beginPath();\n                            tmpCtx1.rect(0, 0, tmpCtx1.canvas.width, tmpCtx1.canvas.height);\n                            tmpCtx1.translate(-ownerBBox1[0], -ownerBBox1[1]);\n                            inverse1 = _util1.Util.transform(inverse1, [\n                                1,\n                                0,\n                                0,\n                                1,\n                                ownerBBox1[0],\n                                ownerBBox1[1]\n                            ]);\n                            tmpCtx1.transform(...owner1.baseTransform);\n                            if (this.matrix) {\n                                tmpCtx1.transform(...this.matrix);\n                            }\n                            applyBoundingBox1(tmpCtx1, this._bbox);\n                            tmpCtx1.fillStyle = this._createGradient(tmpCtx1);\n                            tmpCtx1.fill();\n                            pattern1 = ctx1.createPattern(tmpCanvas1.canvas, \"no-repeat\");\n                            const domMatrix1 = new DOMMatrix(inverse1);\n                            pattern1.setTransform(domMatrix1);\n                        } else {\n                            applyBoundingBox1(ctx1, this._bbox);\n                            pattern1 = this._createGradient(ctx1);\n                        }\n                        return pattern1;\n                    }\n                }\n                function drawTriangle1(data1, context1, p12, p22, p32, c11, c21, c31) {\n                    const coords1 = context1.coords, colors1 = context1.colors;\n                    const bytes1 = data1.data, rowSize1 = data1.width * 4;\n                    let tmp1;\n                    if (coords1[p12 + 1] > coords1[p22 + 1]) {\n                        tmp1 = p12;\n                        p12 = p22;\n                        p22 = tmp1;\n                        tmp1 = c11;\n                        c11 = c21;\n                        c21 = tmp1;\n                    }\n                    if (coords1[p22 + 1] > coords1[p32 + 1]) {\n                        tmp1 = p22;\n                        p22 = p32;\n                        p32 = tmp1;\n                        tmp1 = c21;\n                        c21 = c31;\n                        c31 = tmp1;\n                    }\n                    if (coords1[p12 + 1] > coords1[p22 + 1]) {\n                        tmp1 = p12;\n                        p12 = p22;\n                        p22 = tmp1;\n                        tmp1 = c11;\n                        c11 = c21;\n                        c21 = tmp1;\n                    }\n                    const x11 = (coords1[p12] + context1.offsetX) * context1.scaleX;\n                    const y11 = (coords1[p12 + 1] + context1.offsetY) * context1.scaleY;\n                    const x21 = (coords1[p22] + context1.offsetX) * context1.scaleX;\n                    const y21 = (coords1[p22 + 1] + context1.offsetY) * context1.scaleY;\n                    const x31 = (coords1[p32] + context1.offsetX) * context1.scaleX;\n                    const y31 = (coords1[p32 + 1] + context1.offsetY) * context1.scaleY;\n                    if (y11 >= y31) {\n                        return;\n                    }\n                    const c1r1 = colors1[c11], c1g1 = colors1[c11 + 1], c1b1 = colors1[c11 + 2];\n                    const c2r1 = colors1[c21], c2g1 = colors1[c21 + 1], c2b1 = colors1[c21 + 2];\n                    const c3r1 = colors1[c31], c3g1 = colors1[c31 + 1], c3b1 = colors1[c31 + 2];\n                    const minY1 = Math.round(y11), maxY1 = Math.round(y31);\n                    let xa1, car1, cag1, cab1;\n                    let xb1, cbr1, cbg1, cbb1;\n                    for(let y4 = minY1; y4 <= maxY1; y4++){\n                        if (y4 < y21) {\n                            const k3 = y4 < y11 ? 0 : (y11 - y4) / (y11 - y21);\n                            xa1 = x11 - (x11 - x21) * k3;\n                            car1 = c1r1 - (c1r1 - c2r1) * k3;\n                            cag1 = c1g1 - (c1g1 - c2g1) * k3;\n                            cab1 = c1b1 - (c1b1 - c2b1) * k3;\n                        } else {\n                            let k3;\n                            if (y4 > y31) {\n                                k3 = 1;\n                            } else if (y21 === y31) {\n                                k3 = 0;\n                            } else {\n                                k3 = (y21 - y4) / (y21 - y31);\n                            }\n                            xa1 = x21 - (x21 - x31) * k3;\n                            car1 = c2r1 - (c2r1 - c3r1) * k3;\n                            cag1 = c2g1 - (c2g1 - c3g1) * k3;\n                            cab1 = c2b1 - (c2b1 - c3b1) * k3;\n                        }\n                        let k3;\n                        if (y4 < y11) {\n                            k3 = 0;\n                        } else if (y4 > y31) {\n                            k3 = 1;\n                        } else {\n                            k3 = (y11 - y4) / (y11 - y31);\n                        }\n                        xb1 = x11 - (x11 - x31) * k3;\n                        cbr1 = c1r1 - (c1r1 - c3r1) * k3;\n                        cbg1 = c1g1 - (c1g1 - c3g1) * k3;\n                        cbb1 = c1b1 - (c1b1 - c3b1) * k3;\n                        const x1_1 = Math.round(Math.min(xa1, xb1));\n                        const x2_1 = Math.round(Math.max(xa1, xb1));\n                        let j1 = rowSize1 * y4 + x1_1 * 4;\n                        for(let x4 = x1_1; x4 <= x2_1; x4++){\n                            k3 = (xa1 - x4) / (xa1 - xb1);\n                            if (k3 < 0) {\n                                k3 = 0;\n                            } else if (k3 > 1) {\n                                k3 = 1;\n                            }\n                            bytes1[j1++] = car1 - (car1 - cbr1) * k3 | 0;\n                            bytes1[j1++] = cag1 - (cag1 - cbg1) * k3 | 0;\n                            bytes1[j1++] = cab1 - (cab1 - cbb1) * k3 | 0;\n                            bytes1[j1++] = 255;\n                        }\n                    }\n                }\n                function drawFigure1(data1, figure1, context1) {\n                    const ps1 = figure1.coords;\n                    const cs1 = figure1.colors;\n                    let i1, ii1;\n                    switch(figure1.type){\n                        case \"lattice\":\n                            const verticesPerRow1 = figure1.verticesPerRow;\n                            const rows1 = Math.floor(ps1.length / verticesPerRow1) - 1;\n                            const cols1 = verticesPerRow1 - 1;\n                            for(i1 = 0; i1 < rows1; i1++){\n                                let q1 = i1 * verticesPerRow1;\n                                for(let j1 = 0; j1 < cols1; j1++, q1++){\n                                    drawTriangle1(data1, context1, ps1[q1], ps1[q1 + 1], ps1[q1 + verticesPerRow1], cs1[q1], cs1[q1 + 1], cs1[q1 + verticesPerRow1]);\n                                    drawTriangle1(data1, context1, ps1[q1 + verticesPerRow1 + 1], ps1[q1 + 1], ps1[q1 + verticesPerRow1], cs1[q1 + verticesPerRow1 + 1], cs1[q1 + 1], cs1[q1 + verticesPerRow1]);\n                                }\n                            }\n                            break;\n                        case \"triangles\":\n                            for(i1 = 0, ii1 = ps1.length; i1 < ii1; i1 += 3){\n                                drawTriangle1(data1, context1, ps1[i1], ps1[i1 + 1], ps1[i1 + 2], cs1[i1], cs1[i1 + 1], cs1[i1 + 2]);\n                            }\n                            break;\n                        default:\n                            throw new Error(\"illegal figure\");\n                    }\n                }\n                class MeshShadingPattern1 extends BaseShadingPattern1 {\n                    constructor(IR1){\n                        super();\n                        this._coords = IR1[2];\n                        this._colors = IR1[3];\n                        this._figures = IR1[4];\n                        this._bounds = IR1[5];\n                        this._bbox = IR1[7];\n                        this._background = IR1[8];\n                        this.matrix = null;\n                    }\n                    _createMeshCanvas(combinedScale1, backgroundColor1, cachedCanvases1) {\n                        const EXPECTED_SCALE1 = 1.1;\n                        const MAX_PATTERN_SIZE1 = 3000;\n                        const BORDER_SIZE1 = 2;\n                        const offsetX1 = Math.floor(this._bounds[0]);\n                        const offsetY1 = Math.floor(this._bounds[1]);\n                        const boundsWidth1 = Math.ceil(this._bounds[2]) - offsetX1;\n                        const boundsHeight1 = Math.ceil(this._bounds[3]) - offsetY1;\n                        const width2 = Math.min(Math.ceil(Math.abs(boundsWidth1 * combinedScale1[0] * EXPECTED_SCALE1)), MAX_PATTERN_SIZE1);\n                        const height1 = Math.min(Math.ceil(Math.abs(boundsHeight1 * combinedScale1[1] * EXPECTED_SCALE1)), MAX_PATTERN_SIZE1);\n                        const scaleX1 = boundsWidth1 / width2;\n                        const scaleY1 = boundsHeight1 / height1;\n                        const context1 = {\n                            coords: this._coords,\n                            colors: this._colors,\n                            offsetX: -offsetX1,\n                            offsetY: -offsetY1,\n                            scaleX: 1 / scaleX1,\n                            scaleY: 1 / scaleY1\n                        };\n                        const paddedWidth1 = width2 + BORDER_SIZE1 * 2;\n                        const paddedHeight1 = height1 + BORDER_SIZE1 * 2;\n                        const tmpCanvas1 = cachedCanvases1.getCanvas(\"mesh\", paddedWidth1, paddedHeight1, false);\n                        const tmpCtx1 = tmpCanvas1.context;\n                        const data1 = tmpCtx1.createImageData(width2, height1);\n                        if (backgroundColor1) {\n                            const bytes1 = data1.data;\n                            for(let i1 = 0, ii1 = bytes1.length; i1 < ii1; i1 += 4){\n                                bytes1[i1] = backgroundColor1[0];\n                                bytes1[i1 + 1] = backgroundColor1[1];\n                                bytes1[i1 + 2] = backgroundColor1[2];\n                                bytes1[i1 + 3] = 255;\n                            }\n                        }\n                        for (const figure1 of this._figures){\n                            drawFigure1(data1, figure1, context1);\n                        }\n                        tmpCtx1.putImageData(data1, BORDER_SIZE1, BORDER_SIZE1);\n                        const canvas1 = tmpCanvas1.canvas;\n                        return {\n                            canvas: canvas1,\n                            offsetX: offsetX1 - BORDER_SIZE1 * scaleX1,\n                            offsetY: offsetY1 - BORDER_SIZE1 * scaleY1,\n                            scaleX: scaleX1,\n                            scaleY: scaleY1\n                        };\n                    }\n                    getPattern(ctx1, owner1, inverse1, pathType1) {\n                        applyBoundingBox1(ctx1, this._bbox);\n                        let scale1;\n                        if (pathType1 === PathType1.SHADING) {\n                            scale1 = _util1.Util.singularValueDecompose2dScale((0, _display_utils1.getCurrentTransform)(ctx1));\n                        } else {\n                            scale1 = _util1.Util.singularValueDecompose2dScale(owner1.baseTransform);\n                            if (this.matrix) {\n                                const matrixScale1 = _util1.Util.singularValueDecompose2dScale(this.matrix);\n                                scale1 = [\n                                    scale1[0] * matrixScale1[0],\n                                    scale1[1] * matrixScale1[1]\n                                ];\n                            }\n                        }\n                        const temporaryPatternCanvas1 = this._createMeshCanvas(scale1, pathType1 === PathType1.SHADING ? null : this._background, owner1.cachedCanvases);\n                        if (pathType1 !== PathType1.SHADING) {\n                            ctx1.setTransform(...owner1.baseTransform);\n                            if (this.matrix) {\n                                ctx1.transform(...this.matrix);\n                            }\n                        }\n                        ctx1.translate(temporaryPatternCanvas1.offsetX, temporaryPatternCanvas1.offsetY);\n                        ctx1.scale(temporaryPatternCanvas1.scaleX, temporaryPatternCanvas1.scaleY);\n                        return ctx1.createPattern(temporaryPatternCanvas1.canvas, \"no-repeat\");\n                    }\n                }\n                class DummyShadingPattern1 extends BaseShadingPattern1 {\n                    getPattern() {\n                        return \"hotpink\";\n                    }\n                }\n                function getShadingPattern1(IR1) {\n                    switch(IR1[0]){\n                        case \"RadialAxial\":\n                            return new RadialAxialShadingPattern1(IR1);\n                        case \"Mesh\":\n                            return new MeshShadingPattern1(IR1);\n                        case \"Dummy\":\n                            return new DummyShadingPattern1();\n                    }\n                    throw new Error(`Unknown IR type: ${IR1[0]}`);\n                }\n                const PaintType1 = {\n                    COLORED: 1,\n                    UNCOLORED: 2\n                };\n                class TilingPattern1 {\n                    static{\n                        this.MAX_PATTERN_SIZE = 3000;\n                    }\n                    constructor(IR1, color1, ctx1, canvasGraphicsFactory1, baseTransform1){\n                        this.operatorList = IR1[2];\n                        this.matrix = IR1[3] || [\n                            1,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0\n                        ];\n                        this.bbox = IR1[4];\n                        this.xstep = IR1[5];\n                        this.ystep = IR1[6];\n                        this.paintType = IR1[7];\n                        this.tilingType = IR1[8];\n                        this.color = color1;\n                        this.ctx = ctx1;\n                        this.canvasGraphicsFactory = canvasGraphicsFactory1;\n                        this.baseTransform = baseTransform1;\n                    }\n                    createPatternCanvas(owner1) {\n                        const operatorList1 = this.operatorList;\n                        const bbox1 = this.bbox;\n                        const xstep1 = this.xstep;\n                        const ystep1 = this.ystep;\n                        const paintType1 = this.paintType;\n                        const tilingType1 = this.tilingType;\n                        const color1 = this.color;\n                        const canvasGraphicsFactory1 = this.canvasGraphicsFactory;\n                        (0, _util1.info)(\"TilingType: \" + tilingType1);\n                        const x01 = bbox1[0], y01 = bbox1[1], x11 = bbox1[2], y11 = bbox1[3];\n                        const matrixScale1 = _util1.Util.singularValueDecompose2dScale(this.matrix);\n                        const curMatrixScale1 = _util1.Util.singularValueDecompose2dScale(this.baseTransform);\n                        const combinedScale1 = [\n                            matrixScale1[0] * curMatrixScale1[0],\n                            matrixScale1[1] * curMatrixScale1[1]\n                        ];\n                        const dimx1 = this.getSizeAndScale(xstep1, this.ctx.canvas.width, combinedScale1[0]);\n                        const dimy1 = this.getSizeAndScale(ystep1, this.ctx.canvas.height, combinedScale1[1]);\n                        const tmpCanvas1 = owner1.cachedCanvases.getCanvas(\"pattern\", dimx1.size, dimy1.size, true);\n                        const tmpCtx1 = tmpCanvas1.context;\n                        const graphics1 = canvasGraphicsFactory1.createCanvasGraphics(tmpCtx1);\n                        graphics1.groupLevel = owner1.groupLevel;\n                        this.setFillAndStrokeStyleToContext(graphics1, paintType1, color1);\n                        let adjustedX01 = x01;\n                        let adjustedY01 = y01;\n                        let adjustedX11 = x11;\n                        let adjustedY11 = y11;\n                        if (x01 < 0) {\n                            adjustedX01 = 0;\n                            adjustedX11 += Math.abs(x01);\n                        }\n                        if (y01 < 0) {\n                            adjustedY01 = 0;\n                            adjustedY11 += Math.abs(y01);\n                        }\n                        tmpCtx1.translate(-(dimx1.scale * adjustedX01), -(dimy1.scale * adjustedY01));\n                        graphics1.transform(dimx1.scale, 0, 0, dimy1.scale, 0, 0);\n                        tmpCtx1.save();\n                        this.clipBbox(graphics1, adjustedX01, adjustedY01, adjustedX11, adjustedY11);\n                        graphics1.baseTransform = (0, _display_utils1.getCurrentTransform)(graphics1.ctx);\n                        graphics1.executeOperatorList(operatorList1);\n                        graphics1.endDrawing();\n                        return {\n                            canvas: tmpCanvas1.canvas,\n                            scaleX: dimx1.scale,\n                            scaleY: dimy1.scale,\n                            offsetX: adjustedX01,\n                            offsetY: adjustedY01\n                        };\n                    }\n                    getSizeAndScale(step1, realOutputSize1, scale1) {\n                        step1 = Math.abs(step1);\n                        const maxSize1 = Math.max(TilingPattern1.MAX_PATTERN_SIZE, realOutputSize1);\n                        let size1 = Math.ceil(step1 * scale1);\n                        if (size1 >= maxSize1) {\n                            size1 = maxSize1;\n                        } else {\n                            scale1 = size1 / step1;\n                        }\n                        return {\n                            scale: scale1,\n                            size: size1\n                        };\n                    }\n                    clipBbox(graphics1, x01, y01, x11, y11) {\n                        const bboxWidth1 = x11 - x01;\n                        const bboxHeight1 = y11 - y01;\n                        graphics1.ctx.rect(x01, y01, bboxWidth1, bboxHeight1);\n                        graphics1.current.updateRectMinMax((0, _display_utils1.getCurrentTransform)(graphics1.ctx), [\n                            x01,\n                            y01,\n                            x11,\n                            y11\n                        ]);\n                        graphics1.clip();\n                        graphics1.endPath();\n                    }\n                    setFillAndStrokeStyleToContext(graphics1, paintType1, color1) {\n                        const context1 = graphics1.ctx, current1 = graphics1.current;\n                        switch(paintType1){\n                            case PaintType1.COLORED:\n                                const ctx1 = this.ctx;\n                                context1.fillStyle = ctx1.fillStyle;\n                                context1.strokeStyle = ctx1.strokeStyle;\n                                current1.fillColor = ctx1.fillStyle;\n                                current1.strokeColor = ctx1.strokeStyle;\n                                break;\n                            case PaintType1.UNCOLORED:\n                                const cssColor1 = _util1.Util.makeHexColor(color1[0], color1[1], color1[2]);\n                                context1.fillStyle = cssColor1;\n                                context1.strokeStyle = cssColor1;\n                                current1.fillColor = cssColor1;\n                                current1.strokeColor = cssColor1;\n                                break;\n                            default:\n                                throw new _util1.FormatError(`Unsupported paint type: ${paintType1}`);\n                        }\n                    }\n                    getPattern(ctx1, owner1, inverse1, pathType1) {\n                        let matrix1 = inverse1;\n                        if (pathType1 !== PathType1.SHADING) {\n                            matrix1 = _util1.Util.transform(matrix1, owner1.baseTransform);\n                            if (this.matrix) {\n                                matrix1 = _util1.Util.transform(matrix1, this.matrix);\n                            }\n                        }\n                        const temporaryPatternCanvas1 = this.createPatternCanvas(owner1);\n                        let domMatrix1 = new DOMMatrix(matrix1);\n                        domMatrix1 = domMatrix1.translate(temporaryPatternCanvas1.offsetX, temporaryPatternCanvas1.offsetY);\n                        domMatrix1 = domMatrix1.scale(1 / temporaryPatternCanvas1.scaleX, 1 / temporaryPatternCanvas1.scaleY);\n                        const pattern1 = ctx1.createPattern(temporaryPatternCanvas1.canvas, \"repeat\");\n                        pattern1.setTransform(domMatrix1);\n                        return pattern1;\n                    }\n                }\n                exports1.TilingPattern = TilingPattern1;\n            /***/ },\n            /* 13 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA1;\n                exports1.convertToRGBA = convertToRGBA1;\n                exports1.grayToRGBA = grayToRGBA1;\n                var _util1 = __w_pdfjs_require__1(1);\n                function convertToRGBA1(params1) {\n                    switch(params1.kind){\n                        case _util1.ImageKind.GRAYSCALE_1BPP:\n                            return convertBlackAndWhiteToRGBA1(params1);\n                        case _util1.ImageKind.RGB_24BPP:\n                            return convertRGBToRGBA1(params1);\n                    }\n                    return null;\n                }\n                function convertBlackAndWhiteToRGBA1({ src: src1, srcPos: srcPos1 = 0, dest: dest1, width: width2, height: height1, nonBlackColor: nonBlackColor1 = 0xffffffff, inverseDecode: inverseDecode1 = false }) {\n                    const black1 = _util1.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n                    const [zeroMapping1, oneMapping1] = inverseDecode1 ? [\n                        nonBlackColor1,\n                        black1\n                    ] : [\n                        black1,\n                        nonBlackColor1\n                    ];\n                    const widthInSource1 = width2 >> 3;\n                    const widthRemainder1 = width2 & 7;\n                    const srcLength1 = src1.length;\n                    dest1 = new Uint32Array(dest1.buffer);\n                    let destPos1 = 0;\n                    for(let i1 = 0; i1 < height1; i1++){\n                        for(const max1 = srcPos1 + widthInSource1; srcPos1 < max1; srcPos1++){\n                            const elem1 = srcPos1 < srcLength1 ? src1[srcPos1] : 255;\n                            dest1[destPos1++] = elem1 & 128 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 64 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 32 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 16 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 8 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 4 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 2 ? oneMapping1 : zeroMapping1;\n                            dest1[destPos1++] = elem1 & 1 ? oneMapping1 : zeroMapping1;\n                        }\n                        if (widthRemainder1 === 0) {\n                            continue;\n                        }\n                        const elem1 = srcPos1 < srcLength1 ? src1[srcPos1++] : 255;\n                        for(let j1 = 0; j1 < widthRemainder1; j1++){\n                            dest1[destPos1++] = elem1 & 1 << 7 - j1 ? oneMapping1 : zeroMapping1;\n                        }\n                    }\n                    return {\n                        srcPos: srcPos1,\n                        destPos: destPos1\n                    };\n                }\n                function convertRGBToRGBA1({ src: src1, srcPos: srcPos1 = 0, dest: dest1, destPos: destPos1 = 0, width: width2, height: height1 }) {\n                    let i1 = 0;\n                    const len321 = src1.length >> 2;\n                    const src321 = new Uint32Array(src1.buffer, srcPos1, len321);\n                    if (_util1.FeatureTest.isLittleEndian) {\n                        for(; i1 < len321 - 2; i1 += 3, destPos1 += 4){\n                            const s11 = src321[i1];\n                            const s21 = src321[i1 + 1];\n                            const s31 = src321[i1 + 2];\n                            dest1[destPos1] = s11 | 0xff000000;\n                            dest1[destPos1 + 1] = s11 >>> 24 | s21 << 8 | 0xff000000;\n                            dest1[destPos1 + 2] = s21 >>> 16 | s31 << 16 | 0xff000000;\n                            dest1[destPos1 + 3] = s31 >>> 8 | 0xff000000;\n                        }\n                        for(let j1 = i1 * 4, jj1 = src1.length; j1 < jj1; j1 += 3){\n                            dest1[destPos1++] = src1[j1] | src1[j1 + 1] << 8 | src1[j1 + 2] << 16 | 0xff000000;\n                        }\n                    } else {\n                        for(; i1 < len321 - 2; i1 += 3, destPos1 += 4){\n                            const s11 = src321[i1];\n                            const s21 = src321[i1 + 1];\n                            const s31 = src321[i1 + 2];\n                            dest1[destPos1] = s11 | 0xff;\n                            dest1[destPos1 + 1] = s11 << 24 | s21 >>> 8 | 0xff;\n                            dest1[destPos1 + 2] = s21 << 16 | s31 >>> 16 | 0xff;\n                            dest1[destPos1 + 3] = s31 << 8 | 0xff;\n                        }\n                        for(let j1 = i1 * 4, jj1 = src1.length; j1 < jj1; j1 += 3){\n                            dest1[destPos1++] = src1[j1] << 24 | src1[j1 + 1] << 16 | src1[j1 + 2] << 8 | 0xff;\n                        }\n                    }\n                    return {\n                        srcPos: srcPos1,\n                        destPos: destPos1\n                    };\n                }\n                function grayToRGBA1(src1, dest1) {\n                    if (_util1.FeatureTest.isLittleEndian) {\n                        for(let i1 = 0, ii1 = src1.length; i1 < ii1; i1++){\n                            dest1[i1] = src1[i1] * 0x10101 | 0xff000000;\n                        }\n                    } else {\n                        for(let i1 = 0, ii1 = src1.length; i1 < ii1; i1++){\n                            dest1[i1] = src1[i1] * 0x1010100 | 0x000000ff;\n                        }\n                    }\n                }\n            /***/ },\n            /* 14 */ /***/ (__unused_webpack_module1, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.GlobalWorkerOptions = void 0;\n                const GlobalWorkerOptions1 = Object.create(null);\n                exports1.GlobalWorkerOptions = GlobalWorkerOptions1;\n                GlobalWorkerOptions1.workerPort = null;\n                GlobalWorkerOptions1.workerSrc = \"\";\n            /***/ },\n            /* 15 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.MessageHandler = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                const CallbackKind1 = {\n                    UNKNOWN: 0,\n                    DATA: 1,\n                    ERROR: 2\n                };\n                const StreamKind1 = {\n                    UNKNOWN: 0,\n                    CANCEL: 1,\n                    CANCEL_COMPLETE: 2,\n                    CLOSE: 3,\n                    ENQUEUE: 4,\n                    ERROR: 5,\n                    PULL: 6,\n                    PULL_COMPLETE: 7,\n                    START_COMPLETE: 8\n                };\n                function wrapReason1(reason1) {\n                    if (!(reason1 instanceof Error || typeof reason1 === \"object\" && reason1 !== null)) {\n                        (0, _util1.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n                    }\n                    switch(reason1.name){\n                        case \"AbortException\":\n                            return new _util1.AbortException(reason1.message);\n                        case \"MissingPDFException\":\n                            return new _util1.MissingPDFException(reason1.message);\n                        case \"PasswordException\":\n                            return new _util1.PasswordException(reason1.message, reason1.code);\n                        case \"UnexpectedResponseException\":\n                            return new _util1.UnexpectedResponseException(reason1.message, reason1.status);\n                        case \"UnknownErrorException\":\n                            return new _util1.UnknownErrorException(reason1.message, reason1.details);\n                        default:\n                            return new _util1.UnknownErrorException(reason1.message, reason1.toString());\n                    }\n                }\n                class MessageHandler1 {\n                    constructor(sourceName1, targetName1, comObj1){\n                        this.sourceName = sourceName1;\n                        this.targetName = targetName1;\n                        this.comObj = comObj1;\n                        this.callbackId = 1;\n                        this.streamId = 1;\n                        this.streamSinks = Object.create(null);\n                        this.streamControllers = Object.create(null);\n                        this.callbackCapabilities = Object.create(null);\n                        this.actionHandler = Object.create(null);\n                        this._onComObjOnMessage = (event1)=>{\n                            const data1 = event1.data;\n                            if (data1.targetName !== this.sourceName) {\n                                return;\n                            }\n                            if (data1.stream) {\n                                this.#processStreamMessage(data1);\n                                return;\n                            }\n                            if (data1.callback) {\n                                const callbackId1 = data1.callbackId;\n                                const capability1 = this.callbackCapabilities[callbackId1];\n                                if (!capability1) {\n                                    throw new Error(`Cannot resolve callback ${callbackId1}`);\n                                }\n                                delete this.callbackCapabilities[callbackId1];\n                                if (data1.callback === CallbackKind1.DATA) {\n                                    capability1.resolve(data1.data);\n                                } else if (data1.callback === CallbackKind1.ERROR) {\n                                    capability1.reject(wrapReason1(data1.reason));\n                                } else {\n                                    throw new Error(\"Unexpected callback case\");\n                                }\n                                return;\n                            }\n                            const action1 = this.actionHandler[data1.action];\n                            if (!action1) {\n                                throw new Error(`Unknown action from worker: ${data1.action}`);\n                            }\n                            if (data1.callbackId) {\n                                const cbSourceName1 = this.sourceName;\n                                const cbTargetName1 = data1.sourceName;\n                                new Promise(function(resolve1) {\n                                    resolve1(action1(data1.data));\n                                }).then(function(result1) {\n                                    comObj1.postMessage({\n                                        sourceName: cbSourceName1,\n                                        targetName: cbTargetName1,\n                                        callback: CallbackKind1.DATA,\n                                        callbackId: data1.callbackId,\n                                        data: result1\n                                    });\n                                }, function(reason1) {\n                                    comObj1.postMessage({\n                                        sourceName: cbSourceName1,\n                                        targetName: cbTargetName1,\n                                        callback: CallbackKind1.ERROR,\n                                        callbackId: data1.callbackId,\n                                        reason: wrapReason1(reason1)\n                                    });\n                                });\n                                return;\n                            }\n                            if (data1.streamId) {\n                                this.#createStreamSink(data1);\n                                return;\n                            }\n                            action1(data1.data);\n                        };\n                        comObj1.addEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                    on(actionName1, handler1) {\n                        const ah1 = this.actionHandler;\n                        if (ah1[actionName1]) {\n                            throw new Error(`There is already an actionName called \"${actionName1}\"`);\n                        }\n                        ah1[actionName1] = handler1;\n                    }\n                    send(actionName1, data1, transfers1) {\n                        this.comObj.postMessage({\n                            sourceName: this.sourceName,\n                            targetName: this.targetName,\n                            action: actionName1,\n                            data: data1\n                        }, transfers1);\n                    }\n                    sendWithPromise(actionName1, data1, transfers1) {\n                        const callbackId1 = this.callbackId++;\n                        const capability1 = new _util1.PromiseCapability();\n                        this.callbackCapabilities[callbackId1] = capability1;\n                        try {\n                            this.comObj.postMessage({\n                                sourceName: this.sourceName,\n                                targetName: this.targetName,\n                                action: actionName1,\n                                callbackId: callbackId1,\n                                data: data1\n                            }, transfers1);\n                        } catch (ex1) {\n                            capability1.reject(ex1);\n                        }\n                        return capability1.promise;\n                    }\n                    sendWithStream(actionName1, data1, queueingStrategy1, transfers1) {\n                        const streamId1 = this.streamId++, sourceName1 = this.sourceName, targetName1 = this.targetName, comObj1 = this.comObj;\n                        return new ReadableStream({\n                            start: (controller1)=>{\n                                const startCapability1 = new _util1.PromiseCapability();\n                                this.streamControllers[streamId1] = {\n                                    controller: controller1,\n                                    startCall: startCapability1,\n                                    pullCall: null,\n                                    cancelCall: null,\n                                    isClosed: false\n                                };\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    action: actionName1,\n                                    streamId: streamId1,\n                                    data: data1,\n                                    desiredSize: controller1.desiredSize\n                                }, transfers1);\n                                return startCapability1.promise;\n                            },\n                            pull: (controller1)=>{\n                                const pullCapability1 = new _util1.PromiseCapability();\n                                this.streamControllers[streamId1].pullCall = pullCapability1;\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    stream: StreamKind1.PULL,\n                                    streamId: streamId1,\n                                    desiredSize: controller1.desiredSize\n                                });\n                                return pullCapability1.promise;\n                            },\n                            cancel: (reason1)=>{\n                                (0, _util1.assert)(reason1 instanceof Error, \"cancel must have a valid reason\");\n                                const cancelCapability1 = new _util1.PromiseCapability();\n                                this.streamControllers[streamId1].cancelCall = cancelCapability1;\n                                this.streamControllers[streamId1].isClosed = true;\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    stream: StreamKind1.CANCEL,\n                                    streamId: streamId1,\n                                    reason: wrapReason1(reason1)\n                                });\n                                return cancelCapability1.promise;\n                            }\n                        }, queueingStrategy1);\n                    }\n                    #createStreamSink(data1) {\n                        const streamId1 = data1.streamId, sourceName1 = this.sourceName, targetName1 = data1.sourceName, comObj1 = this.comObj;\n                        const self1 = this, action1 = this.actionHandler[data1.action];\n                        const streamSink1 = {\n                            enqueue (chunk3, size1 = 1, transfers1) {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                const lastDesiredSize1 = this.desiredSize;\n                                this.desiredSize -= size1;\n                                if (lastDesiredSize1 > 0 && this.desiredSize <= 0) {\n                                    this.sinkCapability = new _util1.PromiseCapability();\n                                    this.ready = this.sinkCapability.promise;\n                                }\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    stream: StreamKind1.ENQUEUE,\n                                    streamId: streamId1,\n                                    chunk: chunk3\n                                }, transfers1);\n                            },\n                            close () {\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    stream: StreamKind1.CLOSE,\n                                    streamId: streamId1\n                                });\n                                delete self1.streamSinks[streamId1];\n                            },\n                            error (reason1) {\n                                (0, _util1.assert)(reason1 instanceof Error, \"error must have a valid reason\");\n                                if (this.isCancelled) {\n                                    return;\n                                }\n                                this.isCancelled = true;\n                                comObj1.postMessage({\n                                    sourceName: sourceName1,\n                                    targetName: targetName1,\n                                    stream: StreamKind1.ERROR,\n                                    streamId: streamId1,\n                                    reason: wrapReason1(reason1)\n                                });\n                            },\n                            sinkCapability: new _util1.PromiseCapability(),\n                            onPull: null,\n                            onCancel: null,\n                            isCancelled: false,\n                            desiredSize: data1.desiredSize,\n                            ready: null\n                        };\n                        streamSink1.sinkCapability.resolve();\n                        streamSink1.ready = streamSink1.sinkCapability.promise;\n                        this.streamSinks[streamId1] = streamSink1;\n                        new Promise(function(resolve1) {\n                            resolve1(action1(data1.data, streamSink1));\n                        }).then(function() {\n                            comObj1.postMessage({\n                                sourceName: sourceName1,\n                                targetName: targetName1,\n                                stream: StreamKind1.START_COMPLETE,\n                                streamId: streamId1,\n                                success: true\n                            });\n                        }, function(reason1) {\n                            comObj1.postMessage({\n                                sourceName: sourceName1,\n                                targetName: targetName1,\n                                stream: StreamKind1.START_COMPLETE,\n                                streamId: streamId1,\n                                reason: wrapReason1(reason1)\n                            });\n                        });\n                    }\n                    #processStreamMessage(data1) {\n                        const streamId1 = data1.streamId, sourceName1 = this.sourceName, targetName1 = data1.sourceName, comObj1 = this.comObj;\n                        const streamController1 = this.streamControllers[streamId1], streamSink1 = this.streamSinks[streamId1];\n                        switch(data1.stream){\n                            case StreamKind1.START_COMPLETE:\n                                if (data1.success) {\n                                    streamController1.startCall.resolve();\n                                } else {\n                                    streamController1.startCall.reject(wrapReason1(data1.reason));\n                                }\n                                break;\n                            case StreamKind1.PULL_COMPLETE:\n                                if (data1.success) {\n                                    streamController1.pullCall.resolve();\n                                } else {\n                                    streamController1.pullCall.reject(wrapReason1(data1.reason));\n                                }\n                                break;\n                            case StreamKind1.PULL:\n                                if (!streamSink1) {\n                                    comObj1.postMessage({\n                                        sourceName: sourceName1,\n                                        targetName: targetName1,\n                                        stream: StreamKind1.PULL_COMPLETE,\n                                        streamId: streamId1,\n                                        success: true\n                                    });\n                                    break;\n                                }\n                                if (streamSink1.desiredSize <= 0 && data1.desiredSize > 0) {\n                                    streamSink1.sinkCapability.resolve();\n                                }\n                                streamSink1.desiredSize = data1.desiredSize;\n                                new Promise(function(resolve1) {\n                                    resolve1(streamSink1.onPull?.());\n                                }).then(function() {\n                                    comObj1.postMessage({\n                                        sourceName: sourceName1,\n                                        targetName: targetName1,\n                                        stream: StreamKind1.PULL_COMPLETE,\n                                        streamId: streamId1,\n                                        success: true\n                                    });\n                                }, function(reason1) {\n                                    comObj1.postMessage({\n                                        sourceName: sourceName1,\n                                        targetName: targetName1,\n                                        stream: StreamKind1.PULL_COMPLETE,\n                                        streamId: streamId1,\n                                        reason: wrapReason1(reason1)\n                                    });\n                                });\n                                break;\n                            case StreamKind1.ENQUEUE:\n                                (0, _util1.assert)(streamController1, \"enqueue should have stream controller\");\n                                if (streamController1.isClosed) {\n                                    break;\n                                }\n                                streamController1.controller.enqueue(data1.chunk);\n                                break;\n                            case StreamKind1.CLOSE:\n                                (0, _util1.assert)(streamController1, \"close should have stream controller\");\n                                if (streamController1.isClosed) {\n                                    break;\n                                }\n                                streamController1.isClosed = true;\n                                streamController1.controller.close();\n                                this.#deleteStreamController(streamController1, streamId1);\n                                break;\n                            case StreamKind1.ERROR:\n                                (0, _util1.assert)(streamController1, \"error should have stream controller\");\n                                streamController1.controller.error(wrapReason1(data1.reason));\n                                this.#deleteStreamController(streamController1, streamId1);\n                                break;\n                            case StreamKind1.CANCEL_COMPLETE:\n                                if (data1.success) {\n                                    streamController1.cancelCall.resolve();\n                                } else {\n                                    streamController1.cancelCall.reject(wrapReason1(data1.reason));\n                                }\n                                this.#deleteStreamController(streamController1, streamId1);\n                                break;\n                            case StreamKind1.CANCEL:\n                                if (!streamSink1) {\n                                    break;\n                                }\n                                new Promise(function(resolve1) {\n                                    resolve1(streamSink1.onCancel?.(wrapReason1(data1.reason)));\n                                }).then(function() {\n                                    comObj1.postMessage({\n                                        sourceName: sourceName1,\n                                        targetName: targetName1,\n                                        stream: StreamKind1.CANCEL_COMPLETE,\n                                        streamId: streamId1,\n                                        success: true\n                                    });\n                                }, function(reason1) {\n                                    comObj1.postMessage({\n                                        sourceName: sourceName1,\n                                        targetName: targetName1,\n                                        stream: StreamKind1.CANCEL_COMPLETE,\n                                        streamId: streamId1,\n                                        reason: wrapReason1(reason1)\n                                    });\n                                });\n                                streamSink1.sinkCapability.reject(wrapReason1(data1.reason));\n                                streamSink1.isCancelled = true;\n                                delete this.streamSinks[streamId1];\n                                break;\n                            default:\n                                throw new Error(\"Unexpected stream case\");\n                        }\n                    }\n                    async #deleteStreamController(streamController1, streamId1) {\n                        await Promise.allSettled([\n                            streamController1.startCall?.promise,\n                            streamController1.pullCall?.promise,\n                            streamController1.cancelCall?.promise\n                        ]);\n                        delete this.streamControllers[streamId1];\n                    }\n                    destroy() {\n                        this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n                    }\n                }\n                exports1.MessageHandler = MessageHandler1;\n            /***/ },\n            /* 16 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Metadata = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                class Metadata1 {\n                    #metadataMap;\n                    #data;\n                    constructor({ parsedData: parsedData1, rawData: rawData1 }){\n                        this.#metadataMap = parsedData1;\n                        this.#data = rawData1;\n                    }\n                    getRaw() {\n                        return this.#data;\n                    }\n                    get(name1) {\n                        return this.#metadataMap.get(name1) ?? null;\n                    }\n                    getAll() {\n                        return (0, _util1.objectFromMap)(this.#metadataMap);\n                    }\n                    has(name1) {\n                        return this.#metadataMap.has(name1);\n                    }\n                }\n                exports1.Metadata = Metadata1;\n            /***/ },\n            /* 17 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.OptionalContentConfig = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _murmurhash1 = __w_pdfjs_require__1(8);\n                const INTERNAL1 = Symbol(\"INTERNAL\");\n                class OptionalContentGroup1 {\n                    #visible;\n                    constructor(name1, intent1){\n                        this.#visible = true;\n                        this.name = name1;\n                        this.intent = intent1;\n                    }\n                    get visible() {\n                        return this.#visible;\n                    }\n                    _setVisible(internal1, visible1) {\n                        if (internal1 !== INTERNAL1) {\n                            (0, _util1.unreachable)(\"Internal method `_setVisible` called.\");\n                        }\n                        this.#visible = visible1;\n                    }\n                }\n                class OptionalContentConfig1 {\n                    #cachedGetHash;\n                    #groups;\n                    #initialHash;\n                    #order;\n                    constructor(data1){\n                        this.#cachedGetHash = null;\n                        this.#groups = new Map();\n                        this.#initialHash = null;\n                        this.#order = null;\n                        this.name = null;\n                        this.creator = null;\n                        if (data1 === null) {\n                            return;\n                        }\n                        this.name = data1.name;\n                        this.creator = data1.creator;\n                        this.#order = data1.order;\n                        for (const group1 of data1.groups){\n                            this.#groups.set(group1.id, new OptionalContentGroup1(group1.name, group1.intent));\n                        }\n                        if (data1.baseState === \"OFF\") {\n                            for (const group1 of this.#groups.values()){\n                                group1._setVisible(INTERNAL1, false);\n                            }\n                        }\n                        for (const on1 of data1.on){\n                            this.#groups.get(on1)._setVisible(INTERNAL1, true);\n                        }\n                        for (const off1 of data1.off){\n                            this.#groups.get(off1)._setVisible(INTERNAL1, false);\n                        }\n                        this.#initialHash = this.getHash();\n                    }\n                    #evaluateVisibilityExpression(array1) {\n                        const length1 = array1.length;\n                        if (length1 < 2) {\n                            return true;\n                        }\n                        const operator1 = array1[0];\n                        for(let i1 = 1; i1 < length1; i1++){\n                            const element1 = array1[i1];\n                            let state1;\n                            if (Array.isArray(element1)) {\n                                state1 = this.#evaluateVisibilityExpression(element1);\n                            } else if (this.#groups.has(element1)) {\n                                state1 = this.#groups.get(element1).visible;\n                            } else {\n                                (0, _util1.warn)(`Optional content group not found: ${element1}`);\n                                return true;\n                            }\n                            switch(operator1){\n                                case \"And\":\n                                    if (!state1) {\n                                        return false;\n                                    }\n                                    break;\n                                case \"Or\":\n                                    if (state1) {\n                                        return true;\n                                    }\n                                    break;\n                                case \"Not\":\n                                    return !state1;\n                                default:\n                                    return true;\n                            }\n                        }\n                        return operator1 === \"And\";\n                    }\n                    isVisible(group1) {\n                        if (this.#groups.size === 0) {\n                            return true;\n                        }\n                        if (!group1) {\n                            (0, _util1.warn)(\"Optional content group not defined.\");\n                            return true;\n                        }\n                        if (group1.type === \"OCG\") {\n                            if (!this.#groups.has(group1.id)) {\n                                (0, _util1.warn)(`Optional content group not found: ${group1.id}`);\n                                return true;\n                            }\n                            return this.#groups.get(group1.id).visible;\n                        } else if (group1.type === \"OCMD\") {\n                            if (group1.expression) {\n                                return this.#evaluateVisibilityExpression(group1.expression);\n                            }\n                            if (!group1.policy || group1.policy === \"AnyOn\") {\n                                for (const id1 of group1.ids){\n                                    if (!this.#groups.has(id1)) {\n                                        (0, _util1.warn)(`Optional content group not found: ${id1}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id1).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group1.policy === \"AllOn\") {\n                                for (const id1 of group1.ids){\n                                    if (!this.#groups.has(id1)) {\n                                        (0, _util1.warn)(`Optional content group not found: ${id1}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id1).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            } else if (group1.policy === \"AnyOff\") {\n                                for (const id1 of group1.ids){\n                                    if (!this.#groups.has(id1)) {\n                                        (0, _util1.warn)(`Optional content group not found: ${id1}`);\n                                        return true;\n                                    }\n                                    if (!this.#groups.get(id1).visible) {\n                                        return true;\n                                    }\n                                }\n                                return false;\n                            } else if (group1.policy === \"AllOff\") {\n                                for (const id1 of group1.ids){\n                                    if (!this.#groups.has(id1)) {\n                                        (0, _util1.warn)(`Optional content group not found: ${id1}`);\n                                        return true;\n                                    }\n                                    if (this.#groups.get(id1).visible) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                            (0, _util1.warn)(`Unknown optional content policy ${group1.policy}.`);\n                            return true;\n                        }\n                        (0, _util1.warn)(`Unknown group type ${group1.type}.`);\n                        return true;\n                    }\n                    setVisibility(id1, visible1 = true) {\n                        if (!this.#groups.has(id1)) {\n                            (0, _util1.warn)(`Optional content group not found: ${id1}`);\n                            return;\n                        }\n                        this.#groups.get(id1)._setVisible(INTERNAL1, !!visible1);\n                        this.#cachedGetHash = null;\n                    }\n                    get hasInitialVisibility() {\n                        return this.#initialHash === null || this.getHash() === this.#initialHash;\n                    }\n                    getOrder() {\n                        if (!this.#groups.size) {\n                            return null;\n                        }\n                        if (this.#order) {\n                            return this.#order.slice();\n                        }\n                        return [\n                            ...this.#groups.keys()\n                        ];\n                    }\n                    getGroups() {\n                        return this.#groups.size > 0 ? (0, _util1.objectFromMap)(this.#groups) : null;\n                    }\n                    getGroup(id1) {\n                        return this.#groups.get(id1) || null;\n                    }\n                    getHash() {\n                        if (this.#cachedGetHash !== null) {\n                            return this.#cachedGetHash;\n                        }\n                        const hash1 = new _murmurhash1.MurmurHash3_64();\n                        for (const [id1, group1] of this.#groups){\n                            hash1.update(`${id1}:${group1.visible}`);\n                        }\n                        return this.#cachedGetHash = hash1.hexdigest();\n                    }\n                }\n                exports1.OptionalContentConfig = OptionalContentConfig1;\n            /***/ },\n            /* 18 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFDataTransportStream = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                class PDFDataTransportStream1 {\n                    constructor({ length: length1, initialData: initialData1, progressiveDone: progressiveDone1 = false, contentDispositionFilename: contentDispositionFilename1 = null, disableRange: disableRange1 = false, disableStream: disableStream1 = false }, pdfDataRangeTransport1){\n                        (0, _util1.assert)(pdfDataRangeTransport1, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n                        this._queuedChunks = [];\n                        this._progressiveDone = progressiveDone1;\n                        this._contentDispositionFilename = contentDispositionFilename1;\n                        if (initialData1?.length > 0) {\n                            const buffer1 = initialData1 instanceof Uint8Array && initialData1.byteLength === initialData1.buffer.byteLength ? initialData1.buffer : new Uint8Array(initialData1).buffer;\n                            this._queuedChunks.push(buffer1);\n                        }\n                        this._pdfDataRangeTransport = pdfDataRangeTransport1;\n                        this._isStreamingSupported = !disableStream1;\n                        this._isRangeSupported = !disableRange1;\n                        this._contentLength = length1;\n                        this._fullRequestReader = null;\n                        this._rangeReaders = [];\n                        this._pdfDataRangeTransport.addRangeListener((begin1, chunk3)=>{\n                            this._onReceiveData({\n                                begin: begin1,\n                                chunk: chunk3\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressListener((loaded1, total1)=>{\n                            this._onProgress({\n                                loaded: loaded1,\n                                total: total1\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveReadListener((chunk3)=>{\n                            this._onReceiveData({\n                                chunk: chunk3\n                            });\n                        });\n                        this._pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n                            this._onProgressiveDone();\n                        });\n                        this._pdfDataRangeTransport.transportReady();\n                    }\n                    _onReceiveData({ begin: begin1, chunk: chunk3 }) {\n                        const buffer1 = chunk3 instanceof Uint8Array && chunk3.byteLength === chunk3.buffer.byteLength ? chunk3.buffer : new Uint8Array(chunk3).buffer;\n                        if (begin1 === undefined) {\n                            if (this._fullRequestReader) {\n                                this._fullRequestReader._enqueue(buffer1);\n                            } else {\n                                this._queuedChunks.push(buffer1);\n                            }\n                        } else {\n                            const found1 = this._rangeReaders.some(function(rangeReader1) {\n                                if (rangeReader1._begin !== begin1) {\n                                    return false;\n                                }\n                                rangeReader1._enqueue(buffer1);\n                                return true;\n                            });\n                            (0, _util1.assert)(found1, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n                        }\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    _onProgress(evt1) {\n                        if (evt1.total === undefined) {\n                            this._rangeReaders[0]?.onProgress?.({\n                                loaded: evt1.loaded\n                            });\n                        } else {\n                            this._fullRequestReader?.onProgress?.({\n                                loaded: evt1.loaded,\n                                total: evt1.total\n                            });\n                        }\n                    }\n                    _onProgressiveDone() {\n                        this._fullRequestReader?.progressiveDone();\n                        this._progressiveDone = true;\n                    }\n                    _removeRangeReader(reader1) {\n                        const i1 = this._rangeReaders.indexOf(reader1);\n                        if (i1 >= 0) {\n                            this._rangeReaders.splice(i1, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util1.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n                        const queuedChunks1 = this._queuedChunks;\n                        this._queuedChunks = null;\n                        return new PDFDataTransportStreamReader1(this, queuedChunks1, this._progressiveDone, this._contentDispositionFilename);\n                    }\n                    getRangeReader(begin1, end1) {\n                        if (end1 <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader1 = new PDFDataTransportStreamRangeReader1(this, begin1, end1);\n                        this._pdfDataRangeTransport.requestDataRange(begin1, end1);\n                        this._rangeReaders.push(reader1);\n                        return reader1;\n                    }\n                    cancelAllRequests(reason1) {\n                        this._fullRequestReader?.cancel(reason1);\n                        for (const reader1 of this._rangeReaders.slice(0)){\n                            reader1.cancel(reason1);\n                        }\n                        this._pdfDataRangeTransport.abort();\n                    }\n                }\n                exports1.PDFDataTransportStream = PDFDataTransportStream1;\n                class PDFDataTransportStreamReader1 {\n                    constructor(stream1, queuedChunks1, progressiveDone1 = false, contentDispositionFilename1 = null){\n                        this._stream = stream1;\n                        this._done = progressiveDone1 || false;\n                        this._filename = (0, _display_utils1.isPdfFile)(contentDispositionFilename1) ? contentDispositionFilename1 : null;\n                        this._queuedChunks = queuedChunks1 || [];\n                        this._loaded = 0;\n                        for (const chunk3 of this._queuedChunks){\n                            this._loaded += chunk3.byteLength;\n                        }\n                        this._requests = [];\n                        this._headersReady = Promise.resolve();\n                        stream1._fullRequestReader = this;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk3) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length > 0) {\n                            const requestCapability1 = this._requests.shift();\n                            requestCapability1.resolve({\n                                value: chunk3,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunks.push(chunk3);\n                        }\n                        this._loaded += chunk3.byteLength;\n                    }\n                    get headersReady() {\n                        return this._headersReady;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._stream._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._stream._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._stream._contentLength;\n                    }\n                    async read() {\n                        if (this._queuedChunks.length > 0) {\n                            const chunk3 = this._queuedChunks.shift();\n                            return {\n                                value: chunk3,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability1 = new _util1.PromiseCapability();\n                        this._requests.push(requestCapability1);\n                        return requestCapability1.promise;\n                    }\n                    cancel(reason1) {\n                        this._done = true;\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    progressiveDone() {\n                        if (this._done) {\n                            return;\n                        }\n                        this._done = true;\n                    }\n                }\n                class PDFDataTransportStreamRangeReader1 {\n                    constructor(stream1, begin1, end1){\n                        this._stream = stream1;\n                        this._begin = begin1;\n                        this._end = end1;\n                        this._queuedChunk = null;\n                        this._requests = [];\n                        this._done = false;\n                        this.onProgress = null;\n                    }\n                    _enqueue(chunk3) {\n                        if (this._done) {\n                            return;\n                        }\n                        if (this._requests.length === 0) {\n                            this._queuedChunk = chunk3;\n                        } else {\n                            const requestsCapability1 = this._requests.shift();\n                            requestsCapability1.resolve({\n                                value: chunk3,\n                                done: false\n                            });\n                            for (const requestCapability1 of this._requests){\n                                requestCapability1.resolve({\n                                    value: undefined,\n                                    done: true\n                                });\n                            }\n                            this._requests.length = 0;\n                        }\n                        this._done = true;\n                        this._stream._removeRangeReader(this);\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._queuedChunk) {\n                            const chunk3 = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk3,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability1 = new _util1.PromiseCapability();\n                        this._requests.push(requestCapability1);\n                        return requestCapability1.promise;\n                    }\n                    cancel(reason1) {\n                        this._done = true;\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._stream._removeRangeReader(this);\n                    }\n                }\n            /***/ },\n            /* 19 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFFetchStream = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _network_utils1 = __w_pdfjs_require__1(20);\n                ;\n                function createFetchOptions1(headers1, withCredentials1, abortController1) {\n                    return {\n                        method: \"GET\",\n                        headers: headers1,\n                        signal: abortController1.signal,\n                        mode: \"cors\",\n                        credentials: withCredentials1 ? \"include\" : \"same-origin\",\n                        redirect: \"follow\"\n                    };\n                }\n                function createHeaders1(httpHeaders1) {\n                    const headers1 = new Headers();\n                    for(const property1 in httpHeaders1){\n                        const value1 = httpHeaders1[property1];\n                        if (value1 === undefined) {\n                            continue;\n                        }\n                        headers1.append(property1, value1);\n                    }\n                    return headers1;\n                }\n                function getArrayBuffer1(val1) {\n                    if (val1 instanceof Uint8Array) {\n                        return val1.buffer;\n                    }\n                    if (val1 instanceof ArrayBuffer) {\n                        return val1;\n                    }\n                    (0, _util1.warn)(`getArrayBuffer - unexpected data format: ${val1}`);\n                    return new Uint8Array(val1).buffer;\n                }\n                class PDFFetchStream1 {\n                    constructor(source1){\n                        this.source = source1;\n                        this.isHttp = /^https?:/i.test(source1.url);\n                        this.httpHeaders = this.isHttp && source1.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util1.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFFetchStreamReader1(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin1, end1) {\n                        if (end1 <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const reader1 = new PDFFetchStreamRangeReader1(this, begin1, end1);\n                        this._rangeRequestReaders.push(reader1);\n                        return reader1;\n                    }\n                    cancelAllRequests(reason1) {\n                        this._fullRequestReader?.cancel(reason1);\n                        for (const reader1 of this._rangeRequestReaders.slice(0)){\n                            reader1.cancel(reason1);\n                        }\n                    }\n                }\n                exports1.PDFFetchStream = PDFFetchStream1;\n                class PDFFetchStreamReader1 {\n                    constructor(stream1){\n                        this._stream = stream1;\n                        this._reader = null;\n                        this._loaded = 0;\n                        this._filename = null;\n                        const source1 = stream1.source;\n                        this._withCredentials = source1.withCredentials || false;\n                        this._contentLength = source1.length;\n                        this._headersCapability = new _util1.PromiseCapability();\n                        this._disableRange = source1.disableRange || false;\n                        this._rangeChunkSize = source1.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._abortController = new AbortController();\n                        this._isStreamingSupported = !source1.disableStream;\n                        this._isRangeSupported = !source1.disableRange;\n                        this._headers = createHeaders1(this._stream.httpHeaders);\n                        const url1 = source1.url;\n                        fetch(url1, createFetchOptions1(this._headers, this._withCredentials, this._abortController)).then((response1)=>{\n                            if (!(0, _network_utils1.validateResponseStatus)(response1.status)) {\n                                throw (0, _network_utils1.createResponseStatusError)(response1.status, url1);\n                            }\n                            this._reader = response1.body.getReader();\n                            this._headersCapability.resolve();\n                            const getResponseHeader1 = (name1)=>{\n                                return response1.headers.get(name1);\n                            };\n                            const { allowRangeRequests: allowRangeRequests1, suggestedLength: suggestedLength1 } = (0, _network_utils1.validateRangeRequestCapabilities)({\n                                getResponseHeader: getResponseHeader1,\n                                isHttp: this._stream.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests1;\n                            this._contentLength = suggestedLength1 || this._contentLength;\n                            this._filename = (0, _network_utils1.extractFilenameFromHeader)(getResponseHeader1);\n                            if (!this._isStreamingSupported && this._isRangeSupported) {\n                                this.cancel(new _util1.AbortException(\"Streaming is disabled.\"));\n                            }\n                        }).catch(this._headersCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._headersCapability.promise;\n                        const { value: value1, done: done1 } = await this._reader.read();\n                        if (done1) {\n                            return {\n                                value: value1,\n                                done: done1\n                            };\n                        }\n                        this._loaded += value1.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        return {\n                            value: getArrayBuffer1(value1),\n                            done: false\n                        };\n                    }\n                    cancel(reason1) {\n                        this._reader?.cancel(reason1);\n                        this._abortController.abort();\n                    }\n                }\n                class PDFFetchStreamRangeReader1 {\n                    constructor(stream1, begin1, end1){\n                        this._stream = stream1;\n                        this._reader = null;\n                        this._loaded = 0;\n                        const source1 = stream1.source;\n                        this._withCredentials = source1.withCredentials || false;\n                        this._readCapability = new _util1.PromiseCapability();\n                        this._isStreamingSupported = !source1.disableStream;\n                        this._abortController = new AbortController();\n                        this._headers = createHeaders1(this._stream.httpHeaders);\n                        this._headers.append(\"Range\", `bytes=${begin1}-${end1 - 1}`);\n                        const url1 = source1.url;\n                        fetch(url1, createFetchOptions1(this._headers, this._withCredentials, this._abortController)).then((response1)=>{\n                            if (!(0, _network_utils1.validateResponseStatus)(response1.status)) {\n                                throw (0, _network_utils1.createResponseStatusError)(response1.status, url1);\n                            }\n                            this._readCapability.resolve();\n                            this._reader = response1.body.getReader();\n                        }).catch(this._readCapability.reject);\n                        this.onProgress = null;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        const { value: value1, done: done1 } = await this._reader.read();\n                        if (done1) {\n                            return {\n                                value: value1,\n                                done: done1\n                            };\n                        }\n                        this._loaded += value1.byteLength;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        return {\n                            value: getArrayBuffer1(value1),\n                            done: false\n                        };\n                    }\n                    cancel(reason1) {\n                        this._reader?.cancel(reason1);\n                        this._abortController.abort();\n                    }\n                }\n            /***/ },\n            /* 20 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.createResponseStatusError = createResponseStatusError1;\n                exports1.extractFilenameFromHeader = extractFilenameFromHeader1;\n                exports1.validateRangeRequestCapabilities = validateRangeRequestCapabilities1;\n                exports1.validateResponseStatus = validateResponseStatus1;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _content_disposition1 = __w_pdfjs_require__1(21);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                function validateRangeRequestCapabilities1({ getResponseHeader: getResponseHeader1, isHttp: isHttp1, rangeChunkSize: rangeChunkSize1, disableRange: disableRange1 }) {\n                    const returnValues1 = {\n                        allowRangeRequests: false,\n                        suggestedLength: undefined\n                    };\n                    const length1 = parseInt(getResponseHeader1(\"Content-Length\"), 10);\n                    if (!Number.isInteger(length1)) {\n                        return returnValues1;\n                    }\n                    returnValues1.suggestedLength = length1;\n                    if (length1 <= 2 * rangeChunkSize1) {\n                        return returnValues1;\n                    }\n                    if (disableRange1 || !isHttp1) {\n                        return returnValues1;\n                    }\n                    if (getResponseHeader1(\"Accept-Ranges\") !== \"bytes\") {\n                        return returnValues1;\n                    }\n                    const contentEncoding1 = getResponseHeader1(\"Content-Encoding\") || \"identity\";\n                    if (contentEncoding1 !== \"identity\") {\n                        return returnValues1;\n                    }\n                    returnValues1.allowRangeRequests = true;\n                    return returnValues1;\n                }\n                function extractFilenameFromHeader1(getResponseHeader1) {\n                    const contentDisposition1 = getResponseHeader1(\"Content-Disposition\");\n                    if (contentDisposition1) {\n                        let filename1 = (0, _content_disposition1.getFilenameFromContentDispositionHeader)(contentDisposition1);\n                        if (filename1.includes(\"%\")) {\n                            try {\n                                filename1 = decodeURIComponent(filename1);\n                            } catch  {}\n                        }\n                        if ((0, _display_utils1.isPdfFile)(filename1)) {\n                            return filename1;\n                        }\n                    }\n                    return null;\n                }\n                function createResponseStatusError1(status1, url1) {\n                    if (status1 === 404 || status1 === 0 && url1.startsWith(\"file:\")) {\n                        return new _util1.MissingPDFException('Missing PDF \"' + url1 + '\".');\n                    }\n                    return new _util1.UnexpectedResponseException(`Unexpected server response (${status1}) while retrieving PDF \"${url1}\".`, status1);\n                }\n                function validateResponseStatus1(status1) {\n                    return status1 === 200 || status1 === 206;\n                }\n            /***/ },\n            /* 21 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader1;\n                var _util1 = __w_pdfjs_require__1(1);\n                function getFilenameFromContentDispositionHeader1(contentDisposition1) {\n                    let needsEncodingFixup1 = true;\n                    let tmp1 = toParamRegExp1(\"filename\\\\*\", \"i\").exec(contentDisposition1);\n                    if (tmp1) {\n                        tmp1 = tmp1[1];\n                        let filename1 = rfc2616unquote1(tmp1);\n                        filename1 = unescape(filename1);\n                        filename1 = rfc5987decode1(filename1);\n                        filename1 = rfc2047decode1(filename1);\n                        return fixupEncoding1(filename1);\n                    }\n                    tmp1 = rfc2231getparam1(contentDisposition1);\n                    if (tmp1) {\n                        const filename1 = rfc2047decode1(tmp1);\n                        return fixupEncoding1(filename1);\n                    }\n                    tmp1 = toParamRegExp1(\"filename\", \"i\").exec(contentDisposition1);\n                    if (tmp1) {\n                        tmp1 = tmp1[1];\n                        let filename1 = rfc2616unquote1(tmp1);\n                        filename1 = rfc2047decode1(filename1);\n                        return fixupEncoding1(filename1);\n                    }\n                    function toParamRegExp1(attributePattern1, flags1) {\n                        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern1 + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags1);\n                    }\n                    function textdecode1(encoding1, value1) {\n                        if (encoding1) {\n                            if (!/^[\\x00-\\xFF]+$/.test(value1)) {\n                                return value1;\n                            }\n                            try {\n                                const decoder1 = new TextDecoder(encoding1, {\n                                    fatal: true\n                                });\n                                const buffer1 = (0, _util1.stringToBytes)(value1);\n                                value1 = decoder1.decode(buffer1);\n                                needsEncodingFixup1 = false;\n                            } catch  {}\n                        }\n                        return value1;\n                    }\n                    function fixupEncoding1(value1) {\n                        if (needsEncodingFixup1 && /[\\x80-\\xff]/.test(value1)) {\n                            value1 = textdecode1(\"utf-8\", value1);\n                            if (needsEncodingFixup1) {\n                                value1 = textdecode1(\"iso-8859-1\", value1);\n                            }\n                        }\n                        return value1;\n                    }\n                    function rfc2231getparam1(contentDispositionStr1) {\n                        const matches1 = [];\n                        let match1;\n                        const iter1 = toParamRegExp1(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n                        while((match1 = iter1.exec(contentDispositionStr1)) !== null){\n                            let [, n1, quot1, part1] = match1;\n                            n1 = parseInt(n1, 10);\n                            if (n1 in matches1) {\n                                if (n1 === 0) {\n                                    break;\n                                }\n                                continue;\n                            }\n                            matches1[n1] = [\n                                quot1,\n                                part1\n                            ];\n                        }\n                        const parts1 = [];\n                        for(let n1 = 0; n1 < matches1.length; ++n1){\n                            if (!(n1 in matches1)) {\n                                break;\n                            }\n                            let [quot1, part1] = matches1[n1];\n                            part1 = rfc2616unquote1(part1);\n                            if (quot1) {\n                                part1 = unescape(part1);\n                                if (n1 === 0) {\n                                    part1 = rfc5987decode1(part1);\n                                }\n                            }\n                            parts1.push(part1);\n                        }\n                        return parts1.join(\"\");\n                    }\n                    function rfc2616unquote1(value1) {\n                        if (value1.startsWith('\"')) {\n                            const parts1 = value1.slice(1).split('\\\\\"');\n                            for(let i1 = 0; i1 < parts1.length; ++i1){\n                                const quotindex1 = parts1[i1].indexOf('\"');\n                                if (quotindex1 !== -1) {\n                                    parts1[i1] = parts1[i1].slice(0, quotindex1);\n                                    parts1.length = i1 + 1;\n                                }\n                                parts1[i1] = parts1[i1].replaceAll(/\\\\(.)/g, \"$1\");\n                            }\n                            value1 = parts1.join('\"');\n                        }\n                        return value1;\n                    }\n                    function rfc5987decode1(extvalue1) {\n                        const encodingend1 = extvalue1.indexOf(\"'\");\n                        if (encodingend1 === -1) {\n                            return extvalue1;\n                        }\n                        const encoding1 = extvalue1.slice(0, encodingend1);\n                        const langvalue1 = extvalue1.slice(encodingend1 + 1);\n                        const value1 = langvalue1.replace(/^[^']*'/, \"\");\n                        return textdecode1(encoding1, value1);\n                    }\n                    function rfc2047decode1(value1) {\n                        if (!value1.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value1)) {\n                            return value1;\n                        }\n                        return value1.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches1, charset1, encoding1, text1) {\n                            if (encoding1 === \"q\" || encoding1 === \"Q\") {\n                                text1 = text1.replaceAll(\"_\", \" \");\n                                text1 = text1.replaceAll(/=([0-9a-fA-F]{2})/g, function(match1, hex1) {\n                                    return String.fromCharCode(parseInt(hex1, 16));\n                                });\n                                return textdecode1(charset1, text1);\n                            }\n                            try {\n                                text1 = atob(text1);\n                            } catch  {}\n                            return textdecode1(charset1, text1);\n                        });\n                    }\n                    return \"\";\n                }\n            /***/ },\n            /* 22 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNetworkStream = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _network_utils1 = __w_pdfjs_require__1(20);\n                ;\n                const OK_RESPONSE1 = 200;\n                const PARTIAL_CONTENT_RESPONSE1 = 206;\n                function getArrayBuffer1(xhr1) {\n                    const data1 = xhr1.response;\n                    if (typeof data1 !== \"string\") {\n                        return data1;\n                    }\n                    return (0, _util1.stringToBytes)(data1).buffer;\n                }\n                class NetworkManager1 {\n                    constructor(url1, args1 = {}){\n                        this.url = url1;\n                        this.isHttp = /^https?:/i.test(url1);\n                        this.httpHeaders = this.isHttp && args1.httpHeaders || Object.create(null);\n                        this.withCredentials = args1.withCredentials || false;\n                        this.currXhrId = 0;\n                        this.pendingRequests = Object.create(null);\n                    }\n                    requestRange(begin1, end1, listeners1) {\n                        const args1 = {\n                            begin: begin1,\n                            end: end1\n                        };\n                        for(const prop1 in listeners1){\n                            args1[prop1] = listeners1[prop1];\n                        }\n                        return this.request(args1);\n                    }\n                    requestFull(listeners1) {\n                        return this.request(listeners1);\n                    }\n                    request(args1) {\n                        const xhr1 = new XMLHttpRequest();\n                        const xhrId1 = this.currXhrId++;\n                        const pendingRequest1 = this.pendingRequests[xhrId1] = {\n                            xhr: xhr1\n                        };\n                        xhr1.open(\"GET\", this.url);\n                        xhr1.withCredentials = this.withCredentials;\n                        for(const property1 in this.httpHeaders){\n                            const value1 = this.httpHeaders[property1];\n                            if (value1 === undefined) {\n                                continue;\n                            }\n                            xhr1.setRequestHeader(property1, value1);\n                        }\n                        if (this.isHttp && \"begin\" in args1 && \"end\" in args1) {\n                            xhr1.setRequestHeader(\"Range\", `bytes=${args1.begin}-${args1.end - 1}`);\n                            pendingRequest1.expectedStatus = PARTIAL_CONTENT_RESPONSE1;\n                        } else {\n                            pendingRequest1.expectedStatus = OK_RESPONSE1;\n                        }\n                        xhr1.responseType = \"arraybuffer\";\n                        if (args1.onError) {\n                            xhr1.onerror = function(evt1) {\n                                args1.onError(xhr1.status);\n                            };\n                        }\n                        xhr1.onreadystatechange = this.onStateChange.bind(this, xhrId1);\n                        xhr1.onprogress = this.onProgress.bind(this, xhrId1);\n                        pendingRequest1.onHeadersReceived = args1.onHeadersReceived;\n                        pendingRequest1.onDone = args1.onDone;\n                        pendingRequest1.onError = args1.onError;\n                        pendingRequest1.onProgress = args1.onProgress;\n                        xhr1.send(null);\n                        return xhrId1;\n                    }\n                    onProgress(xhrId1, evt1) {\n                        const pendingRequest1 = this.pendingRequests[xhrId1];\n                        if (!pendingRequest1) {\n                            return;\n                        }\n                        pendingRequest1.onProgress?.(evt1);\n                    }\n                    onStateChange(xhrId1, evt1) {\n                        const pendingRequest1 = this.pendingRequests[xhrId1];\n                        if (!pendingRequest1) {\n                            return;\n                        }\n                        const xhr1 = pendingRequest1.xhr;\n                        if (xhr1.readyState >= 2 && pendingRequest1.onHeadersReceived) {\n                            pendingRequest1.onHeadersReceived();\n                            delete pendingRequest1.onHeadersReceived;\n                        }\n                        if (xhr1.readyState !== 4) {\n                            return;\n                        }\n                        if (!(xhrId1 in this.pendingRequests)) {\n                            return;\n                        }\n                        delete this.pendingRequests[xhrId1];\n                        if (xhr1.status === 0 && this.isHttp) {\n                            pendingRequest1.onError?.(xhr1.status);\n                            return;\n                        }\n                        const xhrStatus1 = xhr1.status || OK_RESPONSE1;\n                        const ok_response_on_range_request1 = xhrStatus1 === OK_RESPONSE1 && pendingRequest1.expectedStatus === PARTIAL_CONTENT_RESPONSE1;\n                        if (!ok_response_on_range_request1 && xhrStatus1 !== pendingRequest1.expectedStatus) {\n                            pendingRequest1.onError?.(xhr1.status);\n                            return;\n                        }\n                        const chunk3 = getArrayBuffer1(xhr1);\n                        if (xhrStatus1 === PARTIAL_CONTENT_RESPONSE1) {\n                            const rangeHeader1 = xhr1.getResponseHeader(\"Content-Range\");\n                            const matches1 = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader1);\n                            pendingRequest1.onDone({\n                                begin: parseInt(matches1[1], 10),\n                                chunk: chunk3\n                            });\n                        } else if (chunk3) {\n                            pendingRequest1.onDone({\n                                begin: 0,\n                                chunk: chunk3\n                            });\n                        } else {\n                            pendingRequest1.onError?.(xhr1.status);\n                        }\n                    }\n                    getRequestXhr(xhrId1) {\n                        return this.pendingRequests[xhrId1].xhr;\n                    }\n                    isPendingRequest(xhrId1) {\n                        return xhrId1 in this.pendingRequests;\n                    }\n                    abortRequest(xhrId1) {\n                        const xhr1 = this.pendingRequests[xhrId1].xhr;\n                        delete this.pendingRequests[xhrId1];\n                        xhr1.abort();\n                    }\n                }\n                class PDFNetworkStream1 {\n                    constructor(source1){\n                        this._source = source1;\n                        this._manager = new NetworkManager1(source1.url, {\n                            httpHeaders: source1.httpHeaders,\n                            withCredentials: source1.withCredentials\n                        });\n                        this._rangeChunkSize = source1.rangeChunkSize;\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    _onRangeRequestReaderClosed(reader1) {\n                        const i1 = this._rangeRequestReaders.indexOf(reader1);\n                        if (i1 >= 0) {\n                            this._rangeRequestReaders.splice(i1, 1);\n                        }\n                    }\n                    getFullReader() {\n                        (0, _util1.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = new PDFNetworkStreamFullRequestReader1(this._manager, this._source);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(begin1, end1) {\n                        const reader1 = new PDFNetworkStreamRangeRequestReader1(this._manager, begin1, end1);\n                        reader1.onClosed = this._onRangeRequestReaderClosed.bind(this);\n                        this._rangeRequestReaders.push(reader1);\n                        return reader1;\n                    }\n                    cancelAllRequests(reason1) {\n                        this._fullRequestReader?.cancel(reason1);\n                        for (const reader1 of this._rangeRequestReaders.slice(0)){\n                            reader1.cancel(reason1);\n                        }\n                    }\n                }\n                exports1.PDFNetworkStream = PDFNetworkStream1;\n                class PDFNetworkStreamFullRequestReader1 {\n                    constructor(manager1, source1){\n                        this._manager = manager1;\n                        const args1 = {\n                            onHeadersReceived: this._onHeadersReceived.bind(this),\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = source1.url;\n                        this._fullRequestId = manager1.requestFull(args1);\n                        this._headersReceivedCapability = new _util1.PromiseCapability();\n                        this._disableRange = source1.disableRange || false;\n                        this._contentLength = source1.length;\n                        this._rangeChunkSize = source1.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = false;\n                        this._isRangeSupported = false;\n                        this._cachedChunks = [];\n                        this._requests = [];\n                        this._done = false;\n                        this._storedError = undefined;\n                        this._filename = null;\n                        this.onProgress = null;\n                    }\n                    _onHeadersReceived() {\n                        const fullRequestXhrId1 = this._fullRequestId;\n                        const fullRequestXhr1 = this._manager.getRequestXhr(fullRequestXhrId1);\n                        const getResponseHeader1 = (name1)=>{\n                            return fullRequestXhr1.getResponseHeader(name1);\n                        };\n                        const { allowRangeRequests: allowRangeRequests1, suggestedLength: suggestedLength1 } = (0, _network_utils1.validateRangeRequestCapabilities)({\n                            getResponseHeader: getResponseHeader1,\n                            isHttp: this._manager.isHttp,\n                            rangeChunkSize: this._rangeChunkSize,\n                            disableRange: this._disableRange\n                        });\n                        if (allowRangeRequests1) {\n                            this._isRangeSupported = true;\n                        }\n                        this._contentLength = suggestedLength1 || this._contentLength;\n                        this._filename = (0, _network_utils1.extractFilenameFromHeader)(getResponseHeader1);\n                        if (this._isRangeSupported) {\n                            this._manager.abortRequest(fullRequestXhrId1);\n                        }\n                        this._headersReceivedCapability.resolve();\n                    }\n                    _onDone(data1) {\n                        if (data1) {\n                            if (this._requests.length > 0) {\n                                const requestCapability1 = this._requests.shift();\n                                requestCapability1.resolve({\n                                    value: data1.chunk,\n                                    done: false\n                                });\n                            } else {\n                                this._cachedChunks.push(data1.chunk);\n                            }\n                        }\n                        this._done = true;\n                        if (this._cachedChunks.length > 0) {\n                            return;\n                        }\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                    }\n                    _onError(status1) {\n                        this._storedError = (0, _network_utils1.createResponseStatusError)(status1, this._url);\n                        this._headersReceivedCapability.reject(this._storedError);\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._cachedChunks.length = 0;\n                    }\n                    _onProgress(evt1) {\n                        this.onProgress?.({\n                            loaded: evt1.loaded,\n                            total: evt1.lengthComputable ? evt1.total : this._contentLength\n                        });\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get headersReady() {\n                        return this._headersReceivedCapability.promise;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._cachedChunks.length > 0) {\n                            const chunk3 = this._cachedChunks.shift();\n                            return {\n                                value: chunk3,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability1 = new _util1.PromiseCapability();\n                        this._requests.push(requestCapability1);\n                        return requestCapability1.promise;\n                    }\n                    cancel(reason1) {\n                        this._done = true;\n                        this._headersReceivedCapability.reject(reason1);\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._fullRequestId)) {\n                            this._manager.abortRequest(this._fullRequestId);\n                        }\n                        this._fullRequestReader = null;\n                    }\n                }\n                class PDFNetworkStreamRangeRequestReader1 {\n                    constructor(manager1, begin1, end1){\n                        this._manager = manager1;\n                        const args1 = {\n                            onDone: this._onDone.bind(this),\n                            onError: this._onError.bind(this),\n                            onProgress: this._onProgress.bind(this)\n                        };\n                        this._url = manager1.url;\n                        this._requestId = manager1.requestRange(begin1, end1, args1);\n                        this._requests = [];\n                        this._queuedChunk = null;\n                        this._done = false;\n                        this._storedError = undefined;\n                        this.onProgress = null;\n                        this.onClosed = null;\n                    }\n                    _close() {\n                        this.onClosed?.(this);\n                    }\n                    _onDone(data1) {\n                        const chunk3 = data1.chunk;\n                        if (this._requests.length > 0) {\n                            const requestCapability1 = this._requests.shift();\n                            requestCapability1.resolve({\n                                value: chunk3,\n                                done: false\n                            });\n                        } else {\n                            this._queuedChunk = chunk3;\n                        }\n                        this._done = true;\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        this._close();\n                    }\n                    _onError(status1) {\n                        this._storedError = (0, _network_utils1.createResponseStatusError)(status1, this._url);\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.reject(this._storedError);\n                        }\n                        this._requests.length = 0;\n                        this._queuedChunk = null;\n                    }\n                    _onProgress(evt1) {\n                        if (!this.isStreamingSupported) {\n                            this.onProgress?.({\n                                loaded: evt1.loaded\n                            });\n                        }\n                    }\n                    get isStreamingSupported() {\n                        return false;\n                    }\n                    async read() {\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        if (this._queuedChunk !== null) {\n                            const chunk3 = this._queuedChunk;\n                            this._queuedChunk = null;\n                            return {\n                                value: chunk3,\n                                done: false\n                            };\n                        }\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        const requestCapability1 = new _util1.PromiseCapability();\n                        this._requests.push(requestCapability1);\n                        return requestCapability1.promise;\n                    }\n                    cancel(reason1) {\n                        this._done = true;\n                        for (const requestCapability1 of this._requests){\n                            requestCapability1.resolve({\n                                value: undefined,\n                                done: true\n                            });\n                        }\n                        this._requests.length = 0;\n                        if (this._manager.isPendingRequest(this._requestId)) {\n                            this._manager.abortRequest(this._requestId);\n                        }\n                        this._close();\n                    }\n                }\n            /***/ },\n            /* 23 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.PDFNodeStream = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _network_utils1 = __w_pdfjs_require__1(20);\n                ;\n                const fileUriRegex1 = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n                function parseUrl1(sourceUrl1) {\n                    const url1 = __webpack_require__(/*! url */ \"url\");\n                    const parsedUrl1 = url1.parse(sourceUrl1);\n                    if (parsedUrl1.protocol === \"file:\" || parsedUrl1.host) {\n                        return parsedUrl1;\n                    }\n                    if (/^[a-z]:[/\\\\]/i.test(sourceUrl1)) {\n                        return url1.parse(`file:///${sourceUrl1}`);\n                    }\n                    if (!parsedUrl1.host) {\n                        parsedUrl1.protocol = \"file:\";\n                    }\n                    return parsedUrl1;\n                }\n                class PDFNodeStream1 {\n                    constructor(source1){\n                        this.source = source1;\n                        this.url = parseUrl1(source1.url);\n                        this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n                        this.isFsUrl = this.url.protocol === \"file:\";\n                        this.httpHeaders = this.isHttp && source1.httpHeaders || {};\n                        this._fullRequestReader = null;\n                        this._rangeRequestReaders = [];\n                    }\n                    get _progressiveDataLength() {\n                        return this._fullRequestReader?._loaded ?? 0;\n                    }\n                    getFullReader() {\n                        (0, _util1.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n                        this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader1(this) : new PDFNodeStreamFullReader1(this);\n                        return this._fullRequestReader;\n                    }\n                    getRangeReader(start1, end1) {\n                        if (end1 <= this._progressiveDataLength) {\n                            return null;\n                        }\n                        const rangeReader1 = this.isFsUrl ? new PDFNodeStreamFsRangeReader1(this, start1, end1) : new PDFNodeStreamRangeReader1(this, start1, end1);\n                        this._rangeRequestReaders.push(rangeReader1);\n                        return rangeReader1;\n                    }\n                    cancelAllRequests(reason1) {\n                        this._fullRequestReader?.cancel(reason1);\n                        for (const reader1 of this._rangeRequestReaders.slice(0)){\n                            reader1.cancel(reason1);\n                        }\n                    }\n                }\n                exports1.PDFNodeStream = PDFNodeStream1;\n                class BaseFullReader1 {\n                    constructor(stream1){\n                        this._url = stream1.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        const source1 = stream1.source;\n                        this._contentLength = source1.length;\n                        this._loaded = 0;\n                        this._filename = null;\n                        this._disableRange = source1.disableRange || false;\n                        this._rangeChunkSize = source1.rangeChunkSize;\n                        if (!this._rangeChunkSize && !this._disableRange) {\n                            this._disableRange = true;\n                        }\n                        this._isStreamingSupported = !source1.disableStream;\n                        this._isRangeSupported = !source1.disableRange;\n                        this._readableStream = null;\n                        this._readCapability = new _util1.PromiseCapability();\n                        this._headersCapability = new _util1.PromiseCapability();\n                    }\n                    get headersReady() {\n                        return this._headersCapability.promise;\n                    }\n                    get filename() {\n                        return this._filename;\n                    }\n                    get contentLength() {\n                        return this._contentLength;\n                    }\n                    get isRangeSupported() {\n                        return this._isRangeSupported;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk3 = this._readableStream.read();\n                        if (chunk3 === null) {\n                            this._readCapability = new _util1.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk3.length;\n                        this.onProgress?.({\n                            loaded: this._loaded,\n                            total: this._contentLength\n                        });\n                        const buffer1 = new Uint8Array(chunk3).buffer;\n                        return {\n                            value: buffer1,\n                            done: false\n                        };\n                    }\n                    cancel(reason1) {\n                        if (!this._readableStream) {\n                            this._error(reason1);\n                            return;\n                        }\n                        this._readableStream.destroy(reason1);\n                    }\n                    _error(reason1) {\n                        this._storedError = reason1;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream1) {\n                        this._readableStream = readableStream1;\n                        readableStream1.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream1.on(\"end\", ()=>{\n                            readableStream1.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream1.on(\"error\", (reason1)=>{\n                            this._error(reason1);\n                        });\n                        if (!this._isStreamingSupported && this._isRangeSupported) {\n                            this._error(new _util1.AbortException(\"streaming is disabled\"));\n                        }\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                class BaseRangeReader1 {\n                    constructor(stream1){\n                        this._url = stream1.url;\n                        this._done = false;\n                        this._storedError = null;\n                        this.onProgress = null;\n                        this._loaded = 0;\n                        this._readableStream = null;\n                        this._readCapability = new _util1.PromiseCapability();\n                        const source1 = stream1.source;\n                        this._isStreamingSupported = !source1.disableStream;\n                    }\n                    get isStreamingSupported() {\n                        return this._isStreamingSupported;\n                    }\n                    async read() {\n                        await this._readCapability.promise;\n                        if (this._done) {\n                            return {\n                                value: undefined,\n                                done: true\n                            };\n                        }\n                        if (this._storedError) {\n                            throw this._storedError;\n                        }\n                        const chunk3 = this._readableStream.read();\n                        if (chunk3 === null) {\n                            this._readCapability = new _util1.PromiseCapability();\n                            return this.read();\n                        }\n                        this._loaded += chunk3.length;\n                        this.onProgress?.({\n                            loaded: this._loaded\n                        });\n                        const buffer1 = new Uint8Array(chunk3).buffer;\n                        return {\n                            value: buffer1,\n                            done: false\n                        };\n                    }\n                    cancel(reason1) {\n                        if (!this._readableStream) {\n                            this._error(reason1);\n                            return;\n                        }\n                        this._readableStream.destroy(reason1);\n                    }\n                    _error(reason1) {\n                        this._storedError = reason1;\n                        this._readCapability.resolve();\n                    }\n                    _setReadableStream(readableStream1) {\n                        this._readableStream = readableStream1;\n                        readableStream1.on(\"readable\", ()=>{\n                            this._readCapability.resolve();\n                        });\n                        readableStream1.on(\"end\", ()=>{\n                            readableStream1.destroy();\n                            this._done = true;\n                            this._readCapability.resolve();\n                        });\n                        readableStream1.on(\"error\", (reason1)=>{\n                            this._error(reason1);\n                        });\n                        if (this._storedError) {\n                            this._readableStream.destroy(this._storedError);\n                        }\n                    }\n                }\n                function createRequestOptions1(parsedUrl1, headers1) {\n                    return {\n                        protocol: parsedUrl1.protocol,\n                        auth: parsedUrl1.auth,\n                        host: parsedUrl1.hostname,\n                        port: parsedUrl1.port,\n                        path: parsedUrl1.path,\n                        method: \"GET\",\n                        headers: headers1\n                    };\n                }\n                class PDFNodeStreamFullReader1 extends BaseFullReader1 {\n                    constructor(stream1){\n                        super(stream1);\n                        const handleResponse1 = (response1)=>{\n                            if (response1.statusCode === 404) {\n                                const error1 = new _util1.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error1;\n                                this._headersCapability.reject(error1);\n                                return;\n                            }\n                            this._headersCapability.resolve();\n                            this._setReadableStream(response1);\n                            const getResponseHeader1 = (name1)=>{\n                                return this._readableStream.headers[name1.toLowerCase()];\n                            };\n                            const { allowRangeRequests: allowRangeRequests1, suggestedLength: suggestedLength1 } = (0, _network_utils1.validateRangeRequestCapabilities)({\n                                getResponseHeader: getResponseHeader1,\n                                isHttp: stream1.isHttp,\n                                rangeChunkSize: this._rangeChunkSize,\n                                disableRange: this._disableRange\n                            });\n                            this._isRangeSupported = allowRangeRequests1;\n                            this._contentLength = suggestedLength1 || this._contentLength;\n                            this._filename = (0, _network_utils1.extractFilenameFromHeader)(getResponseHeader1);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http1 = __webpack_require__(/*! http */ \"http\");\n                            this._request = http1.request(createRequestOptions1(this._url, stream1.httpHeaders), handleResponse1);\n                        } else {\n                            const https1 = __webpack_require__(/*! https */ \"https\");\n                            this._request = https1.request(createRequestOptions1(this._url, stream1.httpHeaders), handleResponse1);\n                        }\n                        this._request.on(\"error\", (reason1)=>{\n                            this._storedError = reason1;\n                            this._headersCapability.reject(reason1);\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamRangeReader1 extends BaseRangeReader1 {\n                    constructor(stream1, start1, end1){\n                        super(stream1);\n                        this._httpHeaders = {};\n                        for(const property1 in stream1.httpHeaders){\n                            const value1 = stream1.httpHeaders[property1];\n                            if (value1 === undefined) {\n                                continue;\n                            }\n                            this._httpHeaders[property1] = value1;\n                        }\n                        this._httpHeaders.Range = `bytes=${start1}-${end1 - 1}`;\n                        const handleResponse1 = (response1)=>{\n                            if (response1.statusCode === 404) {\n                                const error1 = new _util1.MissingPDFException(`Missing PDF \"${this._url}\".`);\n                                this._storedError = error1;\n                                return;\n                            }\n                            this._setReadableStream(response1);\n                        };\n                        this._request = null;\n                        if (this._url.protocol === \"http:\") {\n                            const http1 = __webpack_require__(/*! http */ \"http\");\n                            this._request = http1.request(createRequestOptions1(this._url, this._httpHeaders), handleResponse1);\n                        } else {\n                            const https1 = __webpack_require__(/*! https */ \"https\");\n                            this._request = https1.request(createRequestOptions1(this._url, this._httpHeaders), handleResponse1);\n                        }\n                        this._request.on(\"error\", (reason1)=>{\n                            this._storedError = reason1;\n                        });\n                        this._request.end();\n                    }\n                }\n                class PDFNodeStreamFsFullReader1 extends BaseFullReader1 {\n                    constructor(stream1){\n                        super(stream1);\n                        let path1 = decodeURIComponent(this._url.path);\n                        if (fileUriRegex1.test(this._url.href)) {\n                            path1 = path1.replace(/^\\//, \"\");\n                        }\n                        const fs1 = __webpack_require__(/*! fs */ \"fs\");\n                        fs1.lstat(path1, (error1, stat1)=>{\n                            if (error1) {\n                                if (error1.code === \"ENOENT\") {\n                                    error1 = new _util1.MissingPDFException(`Missing PDF \"${path1}\".`);\n                                }\n                                this._storedError = error1;\n                                this._headersCapability.reject(error1);\n                                return;\n                            }\n                            this._contentLength = stat1.size;\n                            this._setReadableStream(fs1.createReadStream(path1));\n                            this._headersCapability.resolve();\n                        });\n                    }\n                }\n                class PDFNodeStreamFsRangeReader1 extends BaseRangeReader1 {\n                    constructor(stream1, start1, end1){\n                        super(stream1);\n                        let path1 = decodeURIComponent(this._url.path);\n                        if (fileUriRegex1.test(this._url.href)) {\n                            path1 = path1.replace(/^\\//, \"\");\n                        }\n                        const fs1 = __webpack_require__(/*! fs */ \"fs\");\n                        this._setReadableStream(fs1.createReadStream(path1, {\n                            start: start1,\n                            end: end1 - 1\n                        }));\n                    }\n                }\n            /***/ },\n            /* 24 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SVGGraphics = void 0;\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _util1 = __w_pdfjs_require__1(1);\n                ;\n                const SVG_DEFAULTS1 = {\n                    fontStyle: \"normal\",\n                    fontWeight: \"normal\",\n                    fillColor: \"#000000\"\n                };\n                const XML_NS1 = \"http://www.w3.org/XML/1998/namespace\";\n                const XLINK_NS1 = \"http://www.w3.org/1999/xlink\";\n                const LINE_CAP_STYLES1 = [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ];\n                const LINE_JOIN_STYLES1 = [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ];\n                const createObjectURL1 = function(data1, contentType1 = \"\", forceDataSchema1 = false) {\n                    if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema1) {\n                        return URL.createObjectURL(new Blob([\n                            data1\n                        ], {\n                            type: contentType1\n                        }));\n                    }\n                    const digits1 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n                    let buffer1 = `data:${contentType1};base64,`;\n                    for(let i1 = 0, ii1 = data1.length; i1 < ii1; i1 += 3){\n                        const b11 = data1[i1] & 0xff;\n                        const b21 = data1[i1 + 1] & 0xff;\n                        const b31 = data1[i1 + 2] & 0xff;\n                        const d11 = b11 >> 2, d21 = (b11 & 3) << 4 | b21 >> 4;\n                        const d31 = i1 + 1 < ii1 ? (b21 & 0xf) << 2 | b31 >> 6 : 64;\n                        const d41 = i1 + 2 < ii1 ? b31 & 0x3f : 64;\n                        buffer1 += digits1[d11] + digits1[d21] + digits1[d31] + digits1[d41];\n                    }\n                    return buffer1;\n                };\n                const convertImgDataToPng1 = function() {\n                    const PNG_HEADER1 = new Uint8Array([\n                        0x89,\n                        0x50,\n                        0x4e,\n                        0x47,\n                        0x0d,\n                        0x0a,\n                        0x1a,\n                        0x0a\n                    ]);\n                    const CHUNK_WRAPPER_SIZE1 = 12;\n                    const crcTable1 = new Int32Array(256);\n                    for(let i1 = 0; i1 < 256; i1++){\n                        let c4 = i1;\n                        for(let h3 = 0; h3 < 8; h3++){\n                            c4 = c4 & 1 ? 0xedb88320 ^ c4 >> 1 & 0x7fffffff : c4 >> 1 & 0x7fffffff;\n                        }\n                        crcTable1[i1] = c4;\n                    }\n                    function crc321(data1, start1, end1) {\n                        let crc1 = -1;\n                        for(let i1 = start1; i1 < end1; i1++){\n                            const a1 = (crc1 ^ data1[i1]) & 0xff;\n                            const b4 = crcTable1[a1];\n                            crc1 = crc1 >>> 8 ^ b4;\n                        }\n                        return crc1 ^ -1;\n                    }\n                    function writePngChunk1(type1, body1, data1, offset1) {\n                        let p5 = offset1;\n                        const len1 = body1.length;\n                        data1[p5] = len1 >> 24 & 0xff;\n                        data1[p5 + 1] = len1 >> 16 & 0xff;\n                        data1[p5 + 2] = len1 >> 8 & 0xff;\n                        data1[p5 + 3] = len1 & 0xff;\n                        p5 += 4;\n                        data1[p5] = type1.charCodeAt(0) & 0xff;\n                        data1[p5 + 1] = type1.charCodeAt(1) & 0xff;\n                        data1[p5 + 2] = type1.charCodeAt(2) & 0xff;\n                        data1[p5 + 3] = type1.charCodeAt(3) & 0xff;\n                        p5 += 4;\n                        data1.set(body1, p5);\n                        p5 += body1.length;\n                        const crc1 = crc321(data1, offset1 + 4, p5);\n                        data1[p5] = crc1 >> 24 & 0xff;\n                        data1[p5 + 1] = crc1 >> 16 & 0xff;\n                        data1[p5 + 2] = crc1 >> 8 & 0xff;\n                        data1[p5 + 3] = crc1 & 0xff;\n                    }\n                    function adler321(data1, start1, end1) {\n                        let a1 = 1;\n                        let b4 = 0;\n                        for(let i1 = start1; i1 < end1; ++i1){\n                            a1 = (a1 + (data1[i1] & 0xff)) % 65521;\n                            b4 = (b4 + a1) % 65521;\n                        }\n                        return b4 << 16 | a1;\n                    }\n                    function deflateSync1(literals1) {\n                        if (!_util1.isNodeJS) {\n                            return deflateSyncUncompressed1(literals1);\n                        }\n                        try {\n                            const input1 = parseInt(process.versions.node) >= 8 ? literals1 : Buffer.from(literals1);\n                            const output1 = (__webpack_require__(/*! zlib */ \"zlib\").deflateSync)(input1, {\n                                level: 9\n                            });\n                            return output1 instanceof Uint8Array ? output1 : new Uint8Array(output1);\n                        } catch (e1) {\n                            (0, _util1.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e1);\n                        }\n                        return deflateSyncUncompressed1(literals1);\n                    }\n                    function deflateSyncUncompressed1(literals1) {\n                        let len1 = literals1.length;\n                        const maxBlockLength1 = 0xffff;\n                        const deflateBlocks1 = Math.ceil(len1 / maxBlockLength1);\n                        const idat1 = new Uint8Array(2 + len1 + deflateBlocks1 * 5 + 4);\n                        let pi1 = 0;\n                        idat1[pi1++] = 0x78;\n                        idat1[pi1++] = 0x9c;\n                        let pos1 = 0;\n                        while(len1 > maxBlockLength1){\n                            idat1[pi1++] = 0x00;\n                            idat1[pi1++] = 0xff;\n                            idat1[pi1++] = 0xff;\n                            idat1[pi1++] = 0x00;\n                            idat1[pi1++] = 0x00;\n                            idat1.set(literals1.subarray(pos1, pos1 + maxBlockLength1), pi1);\n                            pi1 += maxBlockLength1;\n                            pos1 += maxBlockLength1;\n                            len1 -= maxBlockLength1;\n                        }\n                        idat1[pi1++] = 0x01;\n                        idat1[pi1++] = len1 & 0xff;\n                        idat1[pi1++] = len1 >> 8 & 0xff;\n                        idat1[pi1++] = ~len1 & 0xffff & 0xff;\n                        idat1[pi1++] = (~len1 & 0xffff) >> 8 & 0xff;\n                        idat1.set(literals1.subarray(pos1), pi1);\n                        pi1 += literals1.length - pos1;\n                        const adler1 = adler321(literals1, 0, literals1.length);\n                        idat1[pi1++] = adler1 >> 24 & 0xff;\n                        idat1[pi1++] = adler1 >> 16 & 0xff;\n                        idat1[pi1++] = adler1 >> 8 & 0xff;\n                        idat1[pi1++] = adler1 & 0xff;\n                        return idat1;\n                    }\n                    function encode1(imgData1, kind1, forceDataSchema1, isMask1) {\n                        const width2 = imgData1.width;\n                        const height1 = imgData1.height;\n                        let bitDepth1, colorType1, lineSize1;\n                        const bytes1 = imgData1.data;\n                        switch(kind1){\n                            case _util1.ImageKind.GRAYSCALE_1BPP:\n                                colorType1 = 0;\n                                bitDepth1 = 1;\n                                lineSize1 = width2 + 7 >> 3;\n                                break;\n                            case _util1.ImageKind.RGB_24BPP:\n                                colorType1 = 2;\n                                bitDepth1 = 8;\n                                lineSize1 = width2 * 3;\n                                break;\n                            case _util1.ImageKind.RGBA_32BPP:\n                                colorType1 = 6;\n                                bitDepth1 = 8;\n                                lineSize1 = width2 * 4;\n                                break;\n                            default:\n                                throw new Error(\"invalid format\");\n                        }\n                        const literals1 = new Uint8Array((1 + lineSize1) * height1);\n                        let offsetLiterals1 = 0, offsetBytes1 = 0;\n                        for(let y4 = 0; y4 < height1; ++y4){\n                            literals1[offsetLiterals1++] = 0;\n                            literals1.set(bytes1.subarray(offsetBytes1, offsetBytes1 + lineSize1), offsetLiterals1);\n                            offsetBytes1 += lineSize1;\n                            offsetLiterals1 += lineSize1;\n                        }\n                        if (kind1 === _util1.ImageKind.GRAYSCALE_1BPP && isMask1) {\n                            offsetLiterals1 = 0;\n                            for(let y4 = 0; y4 < height1; y4++){\n                                offsetLiterals1++;\n                                for(let i1 = 0; i1 < lineSize1; i1++){\n                                    literals1[offsetLiterals1++] ^= 0xff;\n                                }\n                            }\n                        }\n                        const ihdr1 = new Uint8Array([\n                            width2 >> 24 & 0xff,\n                            width2 >> 16 & 0xff,\n                            width2 >> 8 & 0xff,\n                            width2 & 0xff,\n                            height1 >> 24 & 0xff,\n                            height1 >> 16 & 0xff,\n                            height1 >> 8 & 0xff,\n                            height1 & 0xff,\n                            bitDepth1,\n                            colorType1,\n                            0x00,\n                            0x00,\n                            0x00\n                        ]);\n                        const idat1 = deflateSync1(literals1);\n                        const pngLength1 = PNG_HEADER1.length + CHUNK_WRAPPER_SIZE1 * 3 + ihdr1.length + idat1.length;\n                        const data1 = new Uint8Array(pngLength1);\n                        let offset1 = 0;\n                        data1.set(PNG_HEADER1, offset1);\n                        offset1 += PNG_HEADER1.length;\n                        writePngChunk1(\"IHDR\", ihdr1, data1, offset1);\n                        offset1 += CHUNK_WRAPPER_SIZE1 + ihdr1.length;\n                        writePngChunk1(\"IDATA\", idat1, data1, offset1);\n                        offset1 += CHUNK_WRAPPER_SIZE1 + idat1.length;\n                        writePngChunk1(\"IEND\", new Uint8Array(0), data1, offset1);\n                        return createObjectURL1(data1, \"image/png\", forceDataSchema1);\n                    }\n                    return function convertImgDataToPng1(imgData1, forceDataSchema1, isMask1) {\n                        const kind1 = imgData1.kind === undefined ? _util1.ImageKind.GRAYSCALE_1BPP : imgData1.kind;\n                        return encode1(imgData1, kind1, forceDataSchema1, isMask1);\n                    };\n                }();\n                class SVGExtraState1 {\n                    constructor(){\n                        this.fontSizeScale = 1;\n                        this.fontWeight = SVG_DEFAULTS1.fontWeight;\n                        this.fontSize = 0;\n                        this.textMatrix = _util1.IDENTITY_MATRIX;\n                        this.fontMatrix = _util1.FONT_IDENTITY_MATRIX;\n                        this.leading = 0;\n                        this.textRenderingMode = _util1.TextRenderingMode.FILL;\n                        this.textMatrixScale = 1;\n                        this.x = 0;\n                        this.y = 0;\n                        this.lineX = 0;\n                        this.lineY = 0;\n                        this.charSpacing = 0;\n                        this.wordSpacing = 0;\n                        this.textHScale = 1;\n                        this.textRise = 0;\n                        this.fillColor = SVG_DEFAULTS1.fillColor;\n                        this.strokeColor = \"#000000\";\n                        this.fillAlpha = 1;\n                        this.strokeAlpha = 1;\n                        this.lineWidth = 1;\n                        this.lineJoin = \"\";\n                        this.lineCap = \"\";\n                        this.miterLimit = 0;\n                        this.dashArray = [];\n                        this.dashPhase = 0;\n                        this.dependencies = [];\n                        this.activeClipUrl = null;\n                        this.clipGroup = null;\n                        this.maskId = \"\";\n                    }\n                    clone() {\n                        return Object.create(this);\n                    }\n                    setCurrentPoint(x4, y4) {\n                        this.x = x4;\n                        this.y = y4;\n                    }\n                }\n                function opListToTree1(opList1) {\n                    let opTree1 = [];\n                    const tmp1 = [];\n                    for (const opListElement1 of opList1){\n                        if (opListElement1.fn === \"save\") {\n                            opTree1.push({\n                                fnId: 92,\n                                fn: \"group\",\n                                items: []\n                            });\n                            tmp1.push(opTree1);\n                            opTree1 = opTree1.at(-1).items;\n                            continue;\n                        }\n                        if (opListElement1.fn === \"restore\") {\n                            opTree1 = tmp1.pop();\n                        } else {\n                            opTree1.push(opListElement1);\n                        }\n                    }\n                    return opTree1;\n                }\n                function pf1(value1) {\n                    if (Number.isInteger(value1)) {\n                        return value1.toString();\n                    }\n                    const s4 = value1.toFixed(10);\n                    let i1 = s4.length - 1;\n                    if (s4[i1] !== \"0\") {\n                        return s4;\n                    }\n                    do {\n                        i1--;\n                    }while (s4[i1] === \"0\");\n                    return s4.substring(0, s4[i1] === \".\" ? i1 : i1 + 1);\n                }\n                function pm1(m3) {\n                    if (m3[4] === 0 && m3[5] === 0) {\n                        if (m3[1] === 0 && m3[2] === 0) {\n                            if (m3[0] === 1 && m3[3] === 1) {\n                                return \"\";\n                            }\n                            return `scale(${pf1(m3[0])} ${pf1(m3[3])})`;\n                        }\n                        if (m3[0] === m3[3] && m3[1] === -m3[2]) {\n                            const a1 = Math.acos(m3[0]) * 180 / Math.PI;\n                            return `rotate(${pf1(a1)})`;\n                        }\n                    } else if (m3[0] === 1 && m3[1] === 0 && m3[2] === 0 && m3[3] === 1) {\n                        return `translate(${pf1(m3[4])} ${pf1(m3[5])})`;\n                    }\n                    return `matrix(${pf1(m3[0])} ${pf1(m3[1])} ${pf1(m3[2])} ${pf1(m3[3])} ${pf1(m3[4])} ` + `${pf1(m3[5])})`;\n                }\n                let clipCount1 = 0;\n                let maskCount1 = 0;\n                let shadingCount1 = 0;\n                class SVGGraphics1 {\n                    constructor(commonObjs1, objs1, forceDataSchema1 = false){\n                        (0, _display_utils1.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n                        this.svgFactory = new _display_utils1.DOMSVGFactory();\n                        this.current = new SVGExtraState1();\n                        this.transformMatrix = _util1.IDENTITY_MATRIX;\n                        this.transformStack = [];\n                        this.extraStack = [];\n                        this.commonObjs = commonObjs1;\n                        this.objs = objs1;\n                        this.pendingClip = null;\n                        this.pendingEOFill = false;\n                        this.embedFonts = false;\n                        this.embeddedFonts = Object.create(null);\n                        this.cssStyle = null;\n                        this.forceDataSchema = !!forceDataSchema1;\n                        this._operatorIdMapping = [];\n                        for(const op1 in _util1.OPS){\n                            this._operatorIdMapping[_util1.OPS[op1]] = op1;\n                        }\n                    }\n                    getObject(data1, fallback1 = null) {\n                        if (typeof data1 === \"string\") {\n                            return data1.startsWith(\"g_\") ? this.commonObjs.get(data1) : this.objs.get(data1);\n                        }\n                        return fallback1;\n                    }\n                    save() {\n                        this.transformStack.push(this.transformMatrix);\n                        const old1 = this.current;\n                        this.extraStack.push(old1);\n                        this.current = old1.clone();\n                    }\n                    restore() {\n                        this.transformMatrix = this.transformStack.pop();\n                        this.current = this.extraStack.pop();\n                        this.pendingClip = null;\n                        this.tgrp = null;\n                    }\n                    group(items1) {\n                        this.save();\n                        this.executeOpTree(items1);\n                        this.restore();\n                    }\n                    loadDependencies(operatorList1) {\n                        const fnArray1 = operatorList1.fnArray;\n                        const argsArray1 = operatorList1.argsArray;\n                        for(let i1 = 0, ii1 = fnArray1.length; i1 < ii1; i1++){\n                            if (fnArray1[i1] !== _util1.OPS.dependency) {\n                                continue;\n                            }\n                            for (const obj1 of argsArray1[i1]){\n                                const objsPool1 = obj1.startsWith(\"g_\") ? this.commonObjs : this.objs;\n                                const promise1 = new Promise((resolve1)=>{\n                                    objsPool1.get(obj1, resolve1);\n                                });\n                                this.current.dependencies.push(promise1);\n                            }\n                        }\n                        return Promise.all(this.current.dependencies);\n                    }\n                    transform(a1, b4, c4, d5, e1, f1) {\n                        const transformMatrix1 = [\n                            a1,\n                            b4,\n                            c4,\n                            d5,\n                            e1,\n                            f1\n                        ];\n                        this.transformMatrix = _util1.Util.transform(this.transformMatrix, transformMatrix1);\n                        this.tgrp = null;\n                    }\n                    getSVG(operatorList1, viewport1) {\n                        this.viewport = viewport1;\n                        const svgElement1 = this._initialize(viewport1);\n                        return this.loadDependencies(operatorList1).then(()=>{\n                            this.transformMatrix = _util1.IDENTITY_MATRIX;\n                            this.executeOpTree(this.convertOpList(operatorList1));\n                            return svgElement1;\n                        });\n                    }\n                    convertOpList(operatorList1) {\n                        const operatorIdMapping1 = this._operatorIdMapping;\n                        const argsArray1 = operatorList1.argsArray;\n                        const fnArray1 = operatorList1.fnArray;\n                        const opList1 = [];\n                        for(let i1 = 0, ii1 = fnArray1.length; i1 < ii1; i1++){\n                            const fnId1 = fnArray1[i1];\n                            opList1.push({\n                                fnId: fnId1,\n                                fn: operatorIdMapping1[fnId1],\n                                args: argsArray1[i1]\n                            });\n                        }\n                        return opListToTree1(opList1);\n                    }\n                    executeOpTree(opTree1) {\n                        for (const opTreeElement1 of opTree1){\n                            const fn1 = opTreeElement1.fn;\n                            const fnId1 = opTreeElement1.fnId;\n                            const args1 = opTreeElement1.args;\n                            switch(fnId1 | 0){\n                                case _util1.OPS.beginText:\n                                    this.beginText();\n                                    break;\n                                case _util1.OPS.dependency:\n                                    break;\n                                case _util1.OPS.setLeading:\n                                    this.setLeading(args1);\n                                    break;\n                                case _util1.OPS.setLeadingMoveText:\n                                    this.setLeadingMoveText(args1[0], args1[1]);\n                                    break;\n                                case _util1.OPS.setFont:\n                                    this.setFont(args1);\n                                    break;\n                                case _util1.OPS.showText:\n                                    this.showText(args1[0]);\n                                    break;\n                                case _util1.OPS.showSpacedText:\n                                    this.showText(args1[0]);\n                                    break;\n                                case _util1.OPS.endText:\n                                    this.endText();\n                                    break;\n                                case _util1.OPS.moveText:\n                                    this.moveText(args1[0], args1[1]);\n                                    break;\n                                case _util1.OPS.setCharSpacing:\n                                    this.setCharSpacing(args1[0]);\n                                    break;\n                                case _util1.OPS.setWordSpacing:\n                                    this.setWordSpacing(args1[0]);\n                                    break;\n                                case _util1.OPS.setHScale:\n                                    this.setHScale(args1[0]);\n                                    break;\n                                case _util1.OPS.setTextMatrix:\n                                    this.setTextMatrix(args1[0], args1[1], args1[2], args1[3], args1[4], args1[5]);\n                                    break;\n                                case _util1.OPS.setTextRise:\n                                    this.setTextRise(args1[0]);\n                                    break;\n                                case _util1.OPS.setTextRenderingMode:\n                                    this.setTextRenderingMode(args1[0]);\n                                    break;\n                                case _util1.OPS.setLineWidth:\n                                    this.setLineWidth(args1[0]);\n                                    break;\n                                case _util1.OPS.setLineJoin:\n                                    this.setLineJoin(args1[0]);\n                                    break;\n                                case _util1.OPS.setLineCap:\n                                    this.setLineCap(args1[0]);\n                                    break;\n                                case _util1.OPS.setMiterLimit:\n                                    this.setMiterLimit(args1[0]);\n                                    break;\n                                case _util1.OPS.setFillRGBColor:\n                                    this.setFillRGBColor(args1[0], args1[1], args1[2]);\n                                    break;\n                                case _util1.OPS.setStrokeRGBColor:\n                                    this.setStrokeRGBColor(args1[0], args1[1], args1[2]);\n                                    break;\n                                case _util1.OPS.setStrokeColorN:\n                                    this.setStrokeColorN(args1);\n                                    break;\n                                case _util1.OPS.setFillColorN:\n                                    this.setFillColorN(args1);\n                                    break;\n                                case _util1.OPS.shadingFill:\n                                    this.shadingFill(args1[0]);\n                                    break;\n                                case _util1.OPS.setDash:\n                                    this.setDash(args1[0], args1[1]);\n                                    break;\n                                case _util1.OPS.setRenderingIntent:\n                                    this.setRenderingIntent(args1[0]);\n                                    break;\n                                case _util1.OPS.setFlatness:\n                                    this.setFlatness(args1[0]);\n                                    break;\n                                case _util1.OPS.setGState:\n                                    this.setGState(args1[0]);\n                                    break;\n                                case _util1.OPS.fill:\n                                    this.fill();\n                                    break;\n                                case _util1.OPS.eoFill:\n                                    this.eoFill();\n                                    break;\n                                case _util1.OPS.stroke:\n                                    this.stroke();\n                                    break;\n                                case _util1.OPS.fillStroke:\n                                    this.fillStroke();\n                                    break;\n                                case _util1.OPS.eoFillStroke:\n                                    this.eoFillStroke();\n                                    break;\n                                case _util1.OPS.clip:\n                                    this.clip(\"nonzero\");\n                                    break;\n                                case _util1.OPS.eoClip:\n                                    this.clip(\"evenodd\");\n                                    break;\n                                case _util1.OPS.paintSolidColorImageMask:\n                                    this.paintSolidColorImageMask();\n                                    break;\n                                case _util1.OPS.paintImageXObject:\n                                    this.paintImageXObject(args1[0]);\n                                    break;\n                                case _util1.OPS.paintInlineImageXObject:\n                                    this.paintInlineImageXObject(args1[0]);\n                                    break;\n                                case _util1.OPS.paintImageMaskXObject:\n                                    this.paintImageMaskXObject(args1[0]);\n                                    break;\n                                case _util1.OPS.paintFormXObjectBegin:\n                                    this.paintFormXObjectBegin(args1[0], args1[1]);\n                                    break;\n                                case _util1.OPS.paintFormXObjectEnd:\n                                    this.paintFormXObjectEnd();\n                                    break;\n                                case _util1.OPS.closePath:\n                                    this.closePath();\n                                    break;\n                                case _util1.OPS.closeStroke:\n                                    this.closeStroke();\n                                    break;\n                                case _util1.OPS.closeFillStroke:\n                                    this.closeFillStroke();\n                                    break;\n                                case _util1.OPS.closeEOFillStroke:\n                                    this.closeEOFillStroke();\n                                    break;\n                                case _util1.OPS.nextLine:\n                                    this.nextLine();\n                                    break;\n                                case _util1.OPS.transform:\n                                    this.transform(args1[0], args1[1], args1[2], args1[3], args1[4], args1[5]);\n                                    break;\n                                case _util1.OPS.constructPath:\n                                    this.constructPath(args1[0], args1[1]);\n                                    break;\n                                case _util1.OPS.endPath:\n                                    this.endPath();\n                                    break;\n                                case 92:\n                                    this.group(opTreeElement1.items);\n                                    break;\n                                default:\n                                    (0, _util1.warn)(`Unimplemented operator ${fn1}`);\n                                    break;\n                            }\n                        }\n                    }\n                    setWordSpacing(wordSpacing1) {\n                        this.current.wordSpacing = wordSpacing1;\n                    }\n                    setCharSpacing(charSpacing1) {\n                        this.current.charSpacing = charSpacing1;\n                    }\n                    nextLine() {\n                        this.moveText(0, this.current.leading);\n                    }\n                    setTextMatrix(a1, b4, c4, d5, e1, f1) {\n                        const current1 = this.current;\n                        current1.textMatrix = current1.lineMatrix = [\n                            a1,\n                            b4,\n                            c4,\n                            d5,\n                            e1,\n                            f1\n                        ];\n                        current1.textMatrixScale = Math.hypot(a1, b4);\n                        current1.x = current1.lineX = 0;\n                        current1.y = current1.lineY = 0;\n                        current1.xcoords = [];\n                        current1.ycoords = [];\n                        current1.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current1.tspan.setAttributeNS(null, \"font-family\", current1.fontFamily);\n                        current1.tspan.setAttributeNS(null, \"font-size\", `${pf1(current1.fontSize)}px`);\n                        current1.tspan.setAttributeNS(null, \"y\", pf1(-current1.y));\n                        current1.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current1.txtElement.append(current1.tspan);\n                    }\n                    beginText() {\n                        const current1 = this.current;\n                        current1.x = current1.lineX = 0;\n                        current1.y = current1.lineY = 0;\n                        current1.textMatrix = _util1.IDENTITY_MATRIX;\n                        current1.lineMatrix = _util1.IDENTITY_MATRIX;\n                        current1.textMatrixScale = 1;\n                        current1.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current1.txtElement = this.svgFactory.createElement(\"svg:text\");\n                        current1.txtgrp = this.svgFactory.createElement(\"svg:g\");\n                        current1.xcoords = [];\n                        current1.ycoords = [];\n                    }\n                    moveText(x4, y4) {\n                        const current1 = this.current;\n                        current1.x = current1.lineX += x4;\n                        current1.y = current1.lineY += y4;\n                        current1.xcoords = [];\n                        current1.ycoords = [];\n                        current1.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current1.tspan.setAttributeNS(null, \"font-family\", current1.fontFamily);\n                        current1.tspan.setAttributeNS(null, \"font-size\", `${pf1(current1.fontSize)}px`);\n                        current1.tspan.setAttributeNS(null, \"y\", pf1(-current1.y));\n                    }\n                    showText(glyphs1) {\n                        const current1 = this.current;\n                        const font1 = current1.font;\n                        const fontSize1 = current1.fontSize;\n                        if (fontSize1 === 0) {\n                            return;\n                        }\n                        const fontSizeScale1 = current1.fontSizeScale;\n                        const charSpacing1 = current1.charSpacing;\n                        const wordSpacing1 = current1.wordSpacing;\n                        const fontDirection1 = current1.fontDirection;\n                        const textHScale1 = current1.textHScale * fontDirection1;\n                        const vertical1 = font1.vertical;\n                        const spacingDir1 = vertical1 ? 1 : -1;\n                        const defaultVMetrics1 = font1.defaultVMetrics;\n                        const widthAdvanceScale1 = fontSize1 * current1.fontMatrix[0];\n                        let x4 = 0;\n                        for (const glyph1 of glyphs1){\n                            if (glyph1 === null) {\n                                x4 += fontDirection1 * wordSpacing1;\n                                continue;\n                            } else if (typeof glyph1 === \"number\") {\n                                x4 += spacingDir1 * glyph1 * fontSize1 / 1000;\n                                continue;\n                            }\n                            const spacing1 = (glyph1.isSpace ? wordSpacing1 : 0) + charSpacing1;\n                            const character1 = glyph1.fontChar;\n                            let scaledX1, scaledY1;\n                            let width2 = glyph1.width;\n                            if (vertical1) {\n                                let vx1;\n                                const vmetric1 = glyph1.vmetric || defaultVMetrics1;\n                                vx1 = glyph1.vmetric ? vmetric1[1] : width2 * 0.5;\n                                vx1 = -vx1 * widthAdvanceScale1;\n                                const vy1 = vmetric1[2] * widthAdvanceScale1;\n                                width2 = vmetric1 ? -vmetric1[0] : width2;\n                                scaledX1 = vx1 / fontSizeScale1;\n                                scaledY1 = (x4 + vy1) / fontSizeScale1;\n                            } else {\n                                scaledX1 = x4 / fontSizeScale1;\n                                scaledY1 = 0;\n                            }\n                            if (glyph1.isInFont || font1.missingFile) {\n                                current1.xcoords.push(current1.x + scaledX1);\n                                if (vertical1) {\n                                    current1.ycoords.push(-current1.y + scaledY1);\n                                }\n                                current1.tspan.textContent += character1;\n                            } else {}\n                            const charWidth1 = vertical1 ? width2 * widthAdvanceScale1 - spacing1 * fontDirection1 : width2 * widthAdvanceScale1 + spacing1 * fontDirection1;\n                            x4 += charWidth1;\n                        }\n                        current1.tspan.setAttributeNS(null, \"x\", current1.xcoords.map(pf1).join(\" \"));\n                        if (vertical1) {\n                            current1.tspan.setAttributeNS(null, \"y\", current1.ycoords.map(pf1).join(\" \"));\n                        } else {\n                            current1.tspan.setAttributeNS(null, \"y\", pf1(-current1.y));\n                        }\n                        if (vertical1) {\n                            current1.y -= x4;\n                        } else {\n                            current1.x += x4 * textHScale1;\n                        }\n                        current1.tspan.setAttributeNS(null, \"font-family\", current1.fontFamily);\n                        current1.tspan.setAttributeNS(null, \"font-size\", `${pf1(current1.fontSize)}px`);\n                        if (current1.fontStyle !== SVG_DEFAULTS1.fontStyle) {\n                            current1.tspan.setAttributeNS(null, \"font-style\", current1.fontStyle);\n                        }\n                        if (current1.fontWeight !== SVG_DEFAULTS1.fontWeight) {\n                            current1.tspan.setAttributeNS(null, \"font-weight\", current1.fontWeight);\n                        }\n                        const fillStrokeMode1 = current1.textRenderingMode & _util1.TextRenderingMode.FILL_STROKE_MASK;\n                        if (fillStrokeMode1 === _util1.TextRenderingMode.FILL || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                            if (current1.fillColor !== SVG_DEFAULTS1.fillColor) {\n                                current1.tspan.setAttributeNS(null, \"fill\", current1.fillColor);\n                            }\n                            if (current1.fillAlpha < 1) {\n                                current1.tspan.setAttributeNS(null, \"fill-opacity\", current1.fillAlpha);\n                            }\n                        } else if (current1.textRenderingMode === _util1.TextRenderingMode.ADD_TO_PATH) {\n                            current1.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n                        } else {\n                            current1.tspan.setAttributeNS(null, \"fill\", \"none\");\n                        }\n                        if (fillStrokeMode1 === _util1.TextRenderingMode.STROKE || fillStrokeMode1 === _util1.TextRenderingMode.FILL_STROKE) {\n                            const lineWidthScale1 = 1 / (current1.textMatrixScale || 1);\n                            this._setStrokeAttributes(current1.tspan, lineWidthScale1);\n                        }\n                        let textMatrix1 = current1.textMatrix;\n                        if (current1.textRise !== 0) {\n                            textMatrix1 = textMatrix1.slice();\n                            textMatrix1[5] += current1.textRise;\n                        }\n                        current1.txtElement.setAttributeNS(null, \"transform\", `${pm1(textMatrix1)} scale(${pf1(textHScale1)}, -1)`);\n                        current1.txtElement.setAttributeNS(XML_NS1, \"xml:space\", \"preserve\");\n                        current1.txtElement.append(current1.tspan);\n                        current1.txtgrp.append(current1.txtElement);\n                        this._ensureTransformGroup().append(current1.txtElement);\n                    }\n                    setLeadingMoveText(x4, y4) {\n                        this.setLeading(-y4);\n                        this.moveText(x4, y4);\n                    }\n                    addFontStyle(fontObj1) {\n                        if (!fontObj1.data) {\n                            throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n                        }\n                        if (!this.cssStyle) {\n                            this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n                            this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n                            this.defs.append(this.cssStyle);\n                        }\n                        const url1 = createObjectURL1(fontObj1.data, fontObj1.mimetype, this.forceDataSchema);\n                        this.cssStyle.textContent += `@font-face { font-family: \"${fontObj1.loadedName}\";` + ` src: url(${url1}); }\\n`;\n                    }\n                    setFont(details1) {\n                        const current1 = this.current;\n                        const fontObj1 = this.commonObjs.get(details1[0]);\n                        let size1 = details1[1];\n                        current1.font = fontObj1;\n                        if (this.embedFonts && !fontObj1.missingFile && !this.embeddedFonts[fontObj1.loadedName]) {\n                            this.addFontStyle(fontObj1);\n                            this.embeddedFonts[fontObj1.loadedName] = fontObj1;\n                        }\n                        current1.fontMatrix = fontObj1.fontMatrix || _util1.FONT_IDENTITY_MATRIX;\n                        let bold1 = \"normal\";\n                        if (fontObj1.black) {\n                            bold1 = \"900\";\n                        } else if (fontObj1.bold) {\n                            bold1 = \"bold\";\n                        }\n                        const italic1 = fontObj1.italic ? \"italic\" : \"normal\";\n                        if (size1 < 0) {\n                            size1 = -size1;\n                            current1.fontDirection = -1;\n                        } else {\n                            current1.fontDirection = 1;\n                        }\n                        current1.fontSize = size1;\n                        current1.fontFamily = fontObj1.loadedName;\n                        current1.fontWeight = bold1;\n                        current1.fontStyle = italic1;\n                        current1.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        current1.tspan.setAttributeNS(null, \"y\", pf1(-current1.y));\n                        current1.xcoords = [];\n                        current1.ycoords = [];\n                    }\n                    endText() {\n                        const current1 = this.current;\n                        if (current1.textRenderingMode & _util1.TextRenderingMode.ADD_TO_PATH_FLAG && current1.txtElement?.hasChildNodes()) {\n                            current1.element = current1.txtElement;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    setLineWidth(width2) {\n                        if (width2 > 0) {\n                            this.current.lineWidth = width2;\n                        }\n                    }\n                    setLineCap(style1) {\n                        this.current.lineCap = LINE_CAP_STYLES1[style1];\n                    }\n                    setLineJoin(style1) {\n                        this.current.lineJoin = LINE_JOIN_STYLES1[style1];\n                    }\n                    setMiterLimit(limit1) {\n                        this.current.miterLimit = limit1;\n                    }\n                    setStrokeAlpha(strokeAlpha1) {\n                        this.current.strokeAlpha = strokeAlpha1;\n                    }\n                    setStrokeRGBColor(r1, g1, b4) {\n                        this.current.strokeColor = _util1.Util.makeHexColor(r1, g1, b4);\n                    }\n                    setFillAlpha(fillAlpha1) {\n                        this.current.fillAlpha = fillAlpha1;\n                    }\n                    setFillRGBColor(r1, g1, b4) {\n                        this.current.fillColor = _util1.Util.makeHexColor(r1, g1, b4);\n                        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n                        this.current.xcoords = [];\n                        this.current.ycoords = [];\n                    }\n                    setStrokeColorN(args1) {\n                        this.current.strokeColor = this._makeColorN_Pattern(args1);\n                    }\n                    setFillColorN(args1) {\n                        this.current.fillColor = this._makeColorN_Pattern(args1);\n                    }\n                    shadingFill(args1) {\n                        const { width: width2, height: height1 } = this.viewport;\n                        const inv1 = _util1.Util.inverseTransform(this.transformMatrix);\n                        const [x01, y01, x11, y11] = _util1.Util.getAxialAlignedBoundingBox([\n                            0,\n                            0,\n                            width2,\n                            height1\n                        ], inv1);\n                        const rect3 = this.svgFactory.createElement(\"svg:rect\");\n                        rect3.setAttributeNS(null, \"x\", x01);\n                        rect3.setAttributeNS(null, \"y\", y01);\n                        rect3.setAttributeNS(null, \"width\", x11 - x01);\n                        rect3.setAttributeNS(null, \"height\", y11 - y01);\n                        rect3.setAttributeNS(null, \"fill\", this._makeShadingPattern(args1));\n                        if (this.current.fillAlpha < 1) {\n                            rect3.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n                        }\n                        this._ensureTransformGroup().append(rect3);\n                    }\n                    _makeColorN_Pattern(args1) {\n                        if (args1[0] === \"TilingPattern\") {\n                            return this._makeTilingPattern(args1);\n                        }\n                        return this._makeShadingPattern(args1);\n                    }\n                    _makeTilingPattern(args1) {\n                        const color1 = args1[1];\n                        const operatorList1 = args1[2];\n                        const matrix1 = args1[3] || _util1.IDENTITY_MATRIX;\n                        const [x01, y01, x11, y11] = args1[4];\n                        const xstep1 = args1[5];\n                        const ystep1 = args1[6];\n                        const paintType1 = args1[7];\n                        const tilingId1 = `shading${shadingCount1++}`;\n                        const [tx01, ty01, tx11, ty11] = _util1.Util.normalizeRect([\n                            ..._util1.Util.applyTransform([\n                                x01,\n                                y01\n                            ], matrix1),\n                            ..._util1.Util.applyTransform([\n                                x11,\n                                y11\n                            ], matrix1)\n                        ]);\n                        const [xscale1, yscale1] = _util1.Util.singularValueDecompose2dScale(matrix1);\n                        const txstep1 = xstep1 * xscale1;\n                        const tystep1 = ystep1 * yscale1;\n                        const tiling1 = this.svgFactory.createElement(\"svg:pattern\");\n                        tiling1.setAttributeNS(null, \"id\", tilingId1);\n                        tiling1.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n                        tiling1.setAttributeNS(null, \"width\", txstep1);\n                        tiling1.setAttributeNS(null, \"height\", tystep1);\n                        tiling1.setAttributeNS(null, \"x\", `${tx01}`);\n                        tiling1.setAttributeNS(null, \"y\", `${ty01}`);\n                        const svg1 = this.svg;\n                        const transformMatrix1 = this.transformMatrix;\n                        const fillColor1 = this.current.fillColor;\n                        const strokeColor1 = this.current.strokeColor;\n                        const bbox1 = this.svgFactory.create(tx11 - tx01, ty11 - ty01);\n                        this.svg = bbox1;\n                        this.transformMatrix = matrix1;\n                        if (paintType1 === 2) {\n                            const cssColor1 = _util1.Util.makeHexColor(...color1);\n                            this.current.fillColor = cssColor1;\n                            this.current.strokeColor = cssColor1;\n                        }\n                        this.executeOpTree(this.convertOpList(operatorList1));\n                        this.svg = svg1;\n                        this.transformMatrix = transformMatrix1;\n                        this.current.fillColor = fillColor1;\n                        this.current.strokeColor = strokeColor1;\n                        tiling1.append(bbox1.childNodes[0]);\n                        this.defs.append(tiling1);\n                        return `url(#${tilingId1})`;\n                    }\n                    _makeShadingPattern(args1) {\n                        if (typeof args1 === \"string\") {\n                            args1 = this.objs.get(args1);\n                        }\n                        switch(args1[0]){\n                            case \"RadialAxial\":\n                                const shadingId1 = `shading${shadingCount1++}`;\n                                const colorStops1 = args1[3];\n                                let gradient1;\n                                switch(args1[1]){\n                                    case \"axial\":\n                                        const point01 = args1[4];\n                                        const point11 = args1[5];\n                                        gradient1 = this.svgFactory.createElement(\"svg:linearGradient\");\n                                        gradient1.setAttributeNS(null, \"id\", shadingId1);\n                                        gradient1.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient1.setAttributeNS(null, \"x1\", point01[0]);\n                                        gradient1.setAttributeNS(null, \"y1\", point01[1]);\n                                        gradient1.setAttributeNS(null, \"x2\", point11[0]);\n                                        gradient1.setAttributeNS(null, \"y2\", point11[1]);\n                                        break;\n                                    case \"radial\":\n                                        const focalPoint1 = args1[4];\n                                        const circlePoint1 = args1[5];\n                                        const focalRadius1 = args1[6];\n                                        const circleRadius1 = args1[7];\n                                        gradient1 = this.svgFactory.createElement(\"svg:radialGradient\");\n                                        gradient1.setAttributeNS(null, \"id\", shadingId1);\n                                        gradient1.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                                        gradient1.setAttributeNS(null, \"cx\", circlePoint1[0]);\n                                        gradient1.setAttributeNS(null, \"cy\", circlePoint1[1]);\n                                        gradient1.setAttributeNS(null, \"r\", circleRadius1);\n                                        gradient1.setAttributeNS(null, \"fx\", focalPoint1[0]);\n                                        gradient1.setAttributeNS(null, \"fy\", focalPoint1[1]);\n                                        gradient1.setAttributeNS(null, \"fr\", focalRadius1);\n                                        break;\n                                    default:\n                                        throw new Error(`Unknown RadialAxial type: ${args1[1]}`);\n                                }\n                                for (const colorStop1 of colorStops1){\n                                    const stop1 = this.svgFactory.createElement(\"svg:stop\");\n                                    stop1.setAttributeNS(null, \"offset\", colorStop1[0]);\n                                    stop1.setAttributeNS(null, \"stop-color\", colorStop1[1]);\n                                    gradient1.append(stop1);\n                                }\n                                this.defs.append(gradient1);\n                                return `url(#${shadingId1})`;\n                            case \"Mesh\":\n                                (0, _util1.warn)(\"Unimplemented pattern Mesh\");\n                                return null;\n                            case \"Dummy\":\n                                return \"hotpink\";\n                            default:\n                                throw new Error(`Unknown IR type: ${args1[0]}`);\n                        }\n                    }\n                    setDash(dashArray1, dashPhase1) {\n                        this.current.dashArray = dashArray1;\n                        this.current.dashPhase = dashPhase1;\n                    }\n                    constructPath(ops1, args1) {\n                        const current1 = this.current;\n                        let x4 = current1.x, y4 = current1.y;\n                        let d5 = [];\n                        let j1 = 0;\n                        for (const op1 of ops1){\n                            switch(op1 | 0){\n                                case _util1.OPS.rectangle:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    const width2 = args1[j1++];\n                                    const height1 = args1[j1++];\n                                    const xw1 = x4 + width2;\n                                    const yh1 = y4 + height1;\n                                    d5.push(\"M\", pf1(x4), pf1(y4), \"L\", pf1(xw1), pf1(y4), \"L\", pf1(xw1), pf1(yh1), \"L\", pf1(x4), pf1(yh1), \"Z\");\n                                    break;\n                                case _util1.OPS.moveTo:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    d5.push(\"M\", pf1(x4), pf1(y4));\n                                    break;\n                                case _util1.OPS.lineTo:\n                                    x4 = args1[j1++];\n                                    y4 = args1[j1++];\n                                    d5.push(\"L\", pf1(x4), pf1(y4));\n                                    break;\n                                case _util1.OPS.curveTo:\n                                    x4 = args1[j1 + 4];\n                                    y4 = args1[j1 + 5];\n                                    d5.push(\"C\", pf1(args1[j1]), pf1(args1[j1 + 1]), pf1(args1[j1 + 2]), pf1(args1[j1 + 3]), pf1(x4), pf1(y4));\n                                    j1 += 6;\n                                    break;\n                                case _util1.OPS.curveTo2:\n                                    d5.push(\"C\", pf1(x4), pf1(y4), pf1(args1[j1]), pf1(args1[j1 + 1]), pf1(args1[j1 + 2]), pf1(args1[j1 + 3]));\n                                    x4 = args1[j1 + 2];\n                                    y4 = args1[j1 + 3];\n                                    j1 += 4;\n                                    break;\n                                case _util1.OPS.curveTo3:\n                                    x4 = args1[j1 + 2];\n                                    y4 = args1[j1 + 3];\n                                    d5.push(\"C\", pf1(args1[j1]), pf1(args1[j1 + 1]), pf1(x4), pf1(y4), pf1(x4), pf1(y4));\n                                    j1 += 4;\n                                    break;\n                                case _util1.OPS.closePath:\n                                    d5.push(\"Z\");\n                                    break;\n                            }\n                        }\n                        d5 = d5.join(\" \");\n                        if (current1.path && ops1.length > 0 && ops1[0] !== _util1.OPS.rectangle && ops1[0] !== _util1.OPS.moveTo) {\n                            d5 = current1.path.getAttributeNS(null, \"d\") + d5;\n                        } else {\n                            current1.path = this.svgFactory.createElement(\"svg:path\");\n                            this._ensureTransformGroup().append(current1.path);\n                        }\n                        current1.path.setAttributeNS(null, \"d\", d5);\n                        current1.path.setAttributeNS(null, \"fill\", \"none\");\n                        current1.element = current1.path;\n                        current1.setCurrentPoint(x4, y4);\n                    }\n                    endPath() {\n                        const current1 = this.current;\n                        current1.path = null;\n                        if (!this.pendingClip) {\n                            return;\n                        }\n                        if (!current1.element) {\n                            this.pendingClip = null;\n                            return;\n                        }\n                        const clipId1 = `clippath${clipCount1++}`;\n                        const clipPath1 = this.svgFactory.createElement(\"svg:clipPath\");\n                        clipPath1.setAttributeNS(null, \"id\", clipId1);\n                        clipPath1.setAttributeNS(null, \"transform\", pm1(this.transformMatrix));\n                        const clipElement1 = current1.element.cloneNode(true);\n                        if (this.pendingClip === \"evenodd\") {\n                            clipElement1.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n                        } else {\n                            clipElement1.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n                        }\n                        this.pendingClip = null;\n                        clipPath1.append(clipElement1);\n                        this.defs.append(clipPath1);\n                        if (current1.activeClipUrl) {\n                            current1.clipGroup = null;\n                            for (const prev1 of this.extraStack){\n                                prev1.clipGroup = null;\n                            }\n                            clipPath1.setAttributeNS(null, \"clip-path\", current1.activeClipUrl);\n                        }\n                        current1.activeClipUrl = `url(#${clipId1})`;\n                        this.tgrp = null;\n                    }\n                    clip(type1) {\n                        this.pendingClip = type1;\n                    }\n                    closePath() {\n                        const current1 = this.current;\n                        if (current1.path) {\n                            const d5 = `${current1.path.getAttributeNS(null, \"d\")}Z`;\n                            current1.path.setAttributeNS(null, \"d\", d5);\n                        }\n                    }\n                    setLeading(leading1) {\n                        this.current.leading = -leading1;\n                    }\n                    setTextRise(textRise1) {\n                        this.current.textRise = textRise1;\n                    }\n                    setTextRenderingMode(textRenderingMode1) {\n                        this.current.textRenderingMode = textRenderingMode1;\n                    }\n                    setHScale(scale1) {\n                        this.current.textHScale = scale1 / 100;\n                    }\n                    setRenderingIntent(intent1) {}\n                    setFlatness(flatness1) {}\n                    setGState(states1) {\n                        for (const [key1, value1] of states1){\n                            switch(key1){\n                                case \"LW\":\n                                    this.setLineWidth(value1);\n                                    break;\n                                case \"LC\":\n                                    this.setLineCap(value1);\n                                    break;\n                                case \"LJ\":\n                                    this.setLineJoin(value1);\n                                    break;\n                                case \"ML\":\n                                    this.setMiterLimit(value1);\n                                    break;\n                                case \"D\":\n                                    this.setDash(value1[0], value1[1]);\n                                    break;\n                                case \"RI\":\n                                    this.setRenderingIntent(value1);\n                                    break;\n                                case \"FL\":\n                                    this.setFlatness(value1);\n                                    break;\n                                case \"Font\":\n                                    this.setFont(value1);\n                                    break;\n                                case \"CA\":\n                                    this.setStrokeAlpha(value1);\n                                    break;\n                                case \"ca\":\n                                    this.setFillAlpha(value1);\n                                    break;\n                                default:\n                                    (0, _util1.warn)(`Unimplemented graphic state operator ${key1}`);\n                                    break;\n                            }\n                        }\n                    }\n                    fill() {\n                        const current1 = this.current;\n                        if (current1.element) {\n                            current1.element.setAttributeNS(null, \"fill\", current1.fillColor);\n                            current1.element.setAttributeNS(null, \"fill-opacity\", current1.fillAlpha);\n                            this.endPath();\n                        }\n                    }\n                    stroke() {\n                        const current1 = this.current;\n                        if (current1.element) {\n                            this._setStrokeAttributes(current1.element);\n                            current1.element.setAttributeNS(null, \"fill\", \"none\");\n                            this.endPath();\n                        }\n                    }\n                    _setStrokeAttributes(element1, lineWidthScale1 = 1) {\n                        const current1 = this.current;\n                        let dashArray1 = current1.dashArray;\n                        if (lineWidthScale1 !== 1 && dashArray1.length > 0) {\n                            dashArray1 = dashArray1.map(function(value1) {\n                                return lineWidthScale1 * value1;\n                            });\n                        }\n                        element1.setAttributeNS(null, \"stroke\", current1.strokeColor);\n                        element1.setAttributeNS(null, \"stroke-opacity\", current1.strokeAlpha);\n                        element1.setAttributeNS(null, \"stroke-miterlimit\", pf1(current1.miterLimit));\n                        element1.setAttributeNS(null, \"stroke-linecap\", current1.lineCap);\n                        element1.setAttributeNS(null, \"stroke-linejoin\", current1.lineJoin);\n                        element1.setAttributeNS(null, \"stroke-width\", pf1(lineWidthScale1 * current1.lineWidth) + \"px\");\n                        element1.setAttributeNS(null, \"stroke-dasharray\", dashArray1.map(pf1).join(\" \"));\n                        element1.setAttributeNS(null, \"stroke-dashoffset\", pf1(lineWidthScale1 * current1.dashPhase) + \"px\");\n                    }\n                    eoFill() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fill();\n                    }\n                    fillStroke() {\n                        this.stroke();\n                        this.fill();\n                    }\n                    eoFillStroke() {\n                        this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n                        this.fillStroke();\n                    }\n                    closeStroke() {\n                        this.closePath();\n                        this.stroke();\n                    }\n                    closeFillStroke() {\n                        this.closePath();\n                        this.fillStroke();\n                    }\n                    closeEOFillStroke() {\n                        this.closePath();\n                        this.eoFillStroke();\n                    }\n                    paintSolidColorImageMask() {\n                        const rect3 = this.svgFactory.createElement(\"svg:rect\");\n                        rect3.setAttributeNS(null, \"x\", \"0\");\n                        rect3.setAttributeNS(null, \"y\", \"0\");\n                        rect3.setAttributeNS(null, \"width\", \"1px\");\n                        rect3.setAttributeNS(null, \"height\", \"1px\");\n                        rect3.setAttributeNS(null, \"fill\", this.current.fillColor);\n                        this._ensureTransformGroup().append(rect3);\n                    }\n                    paintImageXObject(objId1) {\n                        const imgData1 = this.getObject(objId1);\n                        if (!imgData1) {\n                            (0, _util1.warn)(`Dependent image with object ID ${objId1} is not ready yet`);\n                            return;\n                        }\n                        this.paintInlineImageXObject(imgData1);\n                    }\n                    paintInlineImageXObject(imgData1, mask1) {\n                        const width2 = imgData1.width;\n                        const height1 = imgData1.height;\n                        const imgSrc1 = convertImgDataToPng1(imgData1, this.forceDataSchema, !!mask1);\n                        const cliprect1 = this.svgFactory.createElement(\"svg:rect\");\n                        cliprect1.setAttributeNS(null, \"x\", \"0\");\n                        cliprect1.setAttributeNS(null, \"y\", \"0\");\n                        cliprect1.setAttributeNS(null, \"width\", pf1(width2));\n                        cliprect1.setAttributeNS(null, \"height\", pf1(height1));\n                        this.current.element = cliprect1;\n                        this.clip(\"nonzero\");\n                        const imgEl1 = this.svgFactory.createElement(\"svg:image\");\n                        imgEl1.setAttributeNS(XLINK_NS1, \"xlink:href\", imgSrc1);\n                        imgEl1.setAttributeNS(null, \"x\", \"0\");\n                        imgEl1.setAttributeNS(null, \"y\", pf1(-height1));\n                        imgEl1.setAttributeNS(null, \"width\", pf1(width2) + \"px\");\n                        imgEl1.setAttributeNS(null, \"height\", pf1(height1) + \"px\");\n                        imgEl1.setAttributeNS(null, \"transform\", `scale(${pf1(1 / width2)} ${pf1(-1 / height1)})`);\n                        if (mask1) {\n                            mask1.append(imgEl1);\n                        } else {\n                            this._ensureTransformGroup().append(imgEl1);\n                        }\n                    }\n                    paintImageMaskXObject(img1) {\n                        const imgData1 = this.getObject(img1.data, img1);\n                        if (imgData1.bitmap) {\n                            (0, _util1.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n                            return;\n                        }\n                        const current1 = this.current;\n                        const width2 = imgData1.width;\n                        const height1 = imgData1.height;\n                        const fillColor1 = current1.fillColor;\n                        current1.maskId = `mask${maskCount1++}`;\n                        const mask1 = this.svgFactory.createElement(\"svg:mask\");\n                        mask1.setAttributeNS(null, \"id\", current1.maskId);\n                        const rect3 = this.svgFactory.createElement(\"svg:rect\");\n                        rect3.setAttributeNS(null, \"x\", \"0\");\n                        rect3.setAttributeNS(null, \"y\", \"0\");\n                        rect3.setAttributeNS(null, \"width\", pf1(width2));\n                        rect3.setAttributeNS(null, \"height\", pf1(height1));\n                        rect3.setAttributeNS(null, \"fill\", fillColor1);\n                        rect3.setAttributeNS(null, \"mask\", `url(#${current1.maskId})`);\n                        this.defs.append(mask1);\n                        this._ensureTransformGroup().append(rect3);\n                        this.paintInlineImageXObject(imgData1, mask1);\n                    }\n                    paintFormXObjectBegin(matrix1, bbox1) {\n                        if (Array.isArray(matrix1) && matrix1.length === 6) {\n                            this.transform(matrix1[0], matrix1[1], matrix1[2], matrix1[3], matrix1[4], matrix1[5]);\n                        }\n                        if (bbox1) {\n                            const width2 = bbox1[2] - bbox1[0];\n                            const height1 = bbox1[3] - bbox1[1];\n                            const cliprect1 = this.svgFactory.createElement(\"svg:rect\");\n                            cliprect1.setAttributeNS(null, \"x\", bbox1[0]);\n                            cliprect1.setAttributeNS(null, \"y\", bbox1[1]);\n                            cliprect1.setAttributeNS(null, \"width\", pf1(width2));\n                            cliprect1.setAttributeNS(null, \"height\", pf1(height1));\n                            this.current.element = cliprect1;\n                            this.clip(\"nonzero\");\n                            this.endPath();\n                        }\n                    }\n                    paintFormXObjectEnd() {}\n                    _initialize(viewport1) {\n                        const svg1 = this.svgFactory.create(viewport1.width, viewport1.height);\n                        const definitions1 = this.svgFactory.createElement(\"svg:defs\");\n                        svg1.append(definitions1);\n                        this.defs = definitions1;\n                        const rootGroup1 = this.svgFactory.createElement(\"svg:g\");\n                        rootGroup1.setAttributeNS(null, \"transform\", pm1(viewport1.transform));\n                        svg1.append(rootGroup1);\n                        this.svg = rootGroup1;\n                        return svg1;\n                    }\n                    _ensureClipGroup() {\n                        if (!this.current.clipGroup) {\n                            const clipGroup1 = this.svgFactory.createElement(\"svg:g\");\n                            clipGroup1.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n                            this.svg.append(clipGroup1);\n                            this.current.clipGroup = clipGroup1;\n                        }\n                        return this.current.clipGroup;\n                    }\n                    _ensureTransformGroup() {\n                        if (!this.tgrp) {\n                            this.tgrp = this.svgFactory.createElement(\"svg:g\");\n                            this.tgrp.setAttributeNS(null, \"transform\", pm1(this.transformMatrix));\n                            if (this.current.activeClipUrl) {\n                                this._ensureClipGroup().append(this.tgrp);\n                            } else {\n                                this.svg.append(this.tgrp);\n                            }\n                        }\n                        return this.tgrp;\n                    }\n                }\n                exports1.SVGGraphics = SVGGraphics1;\n            /***/ },\n            /* 25 */ /***/ (__unused_webpack_module1, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaText = void 0;\n                class XfaText1 {\n                    static textContent(xfa1) {\n                        const items1 = [];\n                        const output1 = {\n                            items: items1,\n                            styles: Object.create(null)\n                        };\n                        function walk1(node1) {\n                            if (!node1) {\n                                return;\n                            }\n                            let str1 = null;\n                            const name1 = node1.name;\n                            if (name1 === \"#text\") {\n                                str1 = node1.value;\n                            } else if (!XfaText1.shouldBuildText(name1)) {\n                                return;\n                            } else if (node1?.attributes?.textContent) {\n                                str1 = node1.attributes.textContent;\n                            } else if (node1.value) {\n                                str1 = node1.value;\n                            }\n                            if (str1 !== null) {\n                                items1.push({\n                                    str: str1\n                                });\n                            }\n                            if (!node1.children) {\n                                return;\n                            }\n                            for (const child1 of node1.children){\n                                walk1(child1);\n                            }\n                        }\n                        walk1(xfa1);\n                        return output1;\n                    }\n                    static shouldBuildText(name1) {\n                        return !(name1 === \"textarea\" || name1 === \"input\" || name1 === \"option\" || name1 === \"select\");\n                    }\n                }\n                exports1.XfaText = XfaText1;\n            /***/ },\n            /* 26 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.TextLayerRenderTask = void 0;\n                exports1.renderTextLayer = renderTextLayer1;\n                exports1.updateTextLayer = updateTextLayer1;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                const MAX_TEXT_DIVS_TO_RENDER1 = 100000;\n                const DEFAULT_FONT_SIZE1 = 30;\n                const DEFAULT_FONT_ASCENT1 = 0.8;\n                const ascentCache1 = new Map();\n                function getCtx1(size1, isOffscreenCanvasSupported1) {\n                    let ctx1;\n                    if (isOffscreenCanvasSupported1 && _util1.FeatureTest.isOffscreenCanvasSupported) {\n                        ctx1 = new OffscreenCanvas(size1, size1).getContext(\"2d\", {\n                            alpha: false\n                        });\n                    } else {\n                        const canvas1 = document.createElement(\"canvas\");\n                        canvas1.width = canvas1.height = size1;\n                        ctx1 = canvas1.getContext(\"2d\", {\n                            alpha: false\n                        });\n                    }\n                    return ctx1;\n                }\n                function getAscent1(fontFamily1, isOffscreenCanvasSupported1) {\n                    const cachedAscent1 = ascentCache1.get(fontFamily1);\n                    if (cachedAscent1) {\n                        return cachedAscent1;\n                    }\n                    const ctx1 = getCtx1(DEFAULT_FONT_SIZE1, isOffscreenCanvasSupported1);\n                    ctx1.font = `${DEFAULT_FONT_SIZE1}px ${fontFamily1}`;\n                    const metrics1 = ctx1.measureText(\"\");\n                    let ascent1 = metrics1.fontBoundingBoxAscent;\n                    let descent1 = Math.abs(metrics1.fontBoundingBoxDescent);\n                    if (ascent1) {\n                        const ratio1 = ascent1 / (ascent1 + descent1);\n                        ascentCache1.set(fontFamily1, ratio1);\n                        ctx1.canvas.width = ctx1.canvas.height = 0;\n                        return ratio1;\n                    }\n                    ctx1.strokeStyle = \"red\";\n                    ctx1.clearRect(0, 0, DEFAULT_FONT_SIZE1, DEFAULT_FONT_SIZE1);\n                    ctx1.strokeText(\"g\", 0, 0);\n                    let pixels1 = ctx1.getImageData(0, 0, DEFAULT_FONT_SIZE1, DEFAULT_FONT_SIZE1).data;\n                    descent1 = 0;\n                    for(let i1 = pixels1.length - 1 - 3; i1 >= 0; i1 -= 4){\n                        if (pixels1[i1] > 0) {\n                            descent1 = Math.ceil(i1 / 4 / DEFAULT_FONT_SIZE1);\n                            break;\n                        }\n                    }\n                    ctx1.clearRect(0, 0, DEFAULT_FONT_SIZE1, DEFAULT_FONT_SIZE1);\n                    ctx1.strokeText(\"A\", 0, DEFAULT_FONT_SIZE1);\n                    pixels1 = ctx1.getImageData(0, 0, DEFAULT_FONT_SIZE1, DEFAULT_FONT_SIZE1).data;\n                    ascent1 = 0;\n                    for(let i1 = 0, ii1 = pixels1.length; i1 < ii1; i1 += 4){\n                        if (pixels1[i1] > 0) {\n                            ascent1 = DEFAULT_FONT_SIZE1 - Math.floor(i1 / 4 / DEFAULT_FONT_SIZE1);\n                            break;\n                        }\n                    }\n                    ctx1.canvas.width = ctx1.canvas.height = 0;\n                    if (ascent1) {\n                        const ratio1 = ascent1 / (ascent1 + descent1);\n                        ascentCache1.set(fontFamily1, ratio1);\n                        return ratio1;\n                    }\n                    ascentCache1.set(fontFamily1, DEFAULT_FONT_ASCENT1);\n                    return DEFAULT_FONT_ASCENT1;\n                }\n                function appendText1(task1, geom1, styles1) {\n                    const textDiv1 = document.createElement(\"span\");\n                    const textDivProperties1 = {\n                        angle: 0,\n                        canvasWidth: 0,\n                        hasText: geom1.str !== \"\",\n                        hasEOL: geom1.hasEOL,\n                        fontSize: 0\n                    };\n                    task1._textDivs.push(textDiv1);\n                    const tx2 = _util1.Util.transform(task1._transform, geom1.transform);\n                    let angle1 = Math.atan2(tx2[1], tx2[0]);\n                    const style1 = styles1[geom1.fontName];\n                    if (style1.vertical) {\n                        angle1 += Math.PI / 2;\n                    }\n                    const fontHeight1 = Math.hypot(tx2[2], tx2[3]);\n                    const fontAscent1 = fontHeight1 * getAscent1(style1.fontFamily, task1._isOffscreenCanvasSupported);\n                    let left1, top1;\n                    if (angle1 === 0) {\n                        left1 = tx2[4];\n                        top1 = tx2[5] - fontAscent1;\n                    } else {\n                        left1 = tx2[4] + fontAscent1 * Math.sin(angle1);\n                        top1 = tx2[5] - fontAscent1 * Math.cos(angle1);\n                    }\n                    const scaleFactorStr1 = \"calc(var(--scale-factor)*\";\n                    const divStyle1 = textDiv1.style;\n                    if (task1._container === task1._rootContainer) {\n                        divStyle1.left = `${(100 * left1 / task1._pageWidth).toFixed(2)}%`;\n                        divStyle1.top = `${(100 * top1 / task1._pageHeight).toFixed(2)}%`;\n                    } else {\n                        divStyle1.left = `${scaleFactorStr1}${left1.toFixed(2)}px)`;\n                        divStyle1.top = `${scaleFactorStr1}${top1.toFixed(2)}px)`;\n                    }\n                    divStyle1.fontSize = `${scaleFactorStr1}${fontHeight1.toFixed(2)}px)`;\n                    divStyle1.fontFamily = style1.fontFamily;\n                    textDivProperties1.fontSize = fontHeight1;\n                    textDiv1.setAttribute(\"role\", \"presentation\");\n                    textDiv1.textContent = geom1.str;\n                    textDiv1.dir = geom1.dir;\n                    if (task1._fontInspectorEnabled) {\n                        textDiv1.dataset.fontName = geom1.fontName;\n                    }\n                    if (angle1 !== 0) {\n                        textDivProperties1.angle = angle1 * (180 / Math.PI);\n                    }\n                    let shouldScaleText1 = false;\n                    if (geom1.str.length > 1) {\n                        shouldScaleText1 = true;\n                    } else if (geom1.str !== \" \" && geom1.transform[0] !== geom1.transform[3]) {\n                        const absScaleX1 = Math.abs(geom1.transform[0]), absScaleY1 = Math.abs(geom1.transform[3]);\n                        if (absScaleX1 !== absScaleY1 && Math.max(absScaleX1, absScaleY1) / Math.min(absScaleX1, absScaleY1) > 1.5) {\n                            shouldScaleText1 = true;\n                        }\n                    }\n                    if (shouldScaleText1) {\n                        textDivProperties1.canvasWidth = style1.vertical ? geom1.height : geom1.width;\n                    }\n                    task1._textDivProperties.set(textDiv1, textDivProperties1);\n                    if (task1._isReadableStream) {\n                        task1._layoutText(textDiv1);\n                    }\n                }\n                function layout1(params1) {\n                    const { div: div1, scale: scale1, properties: properties1, ctx: ctx1, prevFontSize: prevFontSize1, prevFontFamily: prevFontFamily1 } = params1;\n                    const { style: style1 } = div1;\n                    let transform1 = \"\";\n                    if (properties1.canvasWidth !== 0 && properties1.hasText) {\n                        const { fontFamily: fontFamily1 } = style1;\n                        const { canvasWidth: canvasWidth1, fontSize: fontSize1 } = properties1;\n                        if (prevFontSize1 !== fontSize1 || prevFontFamily1 !== fontFamily1) {\n                            ctx1.font = `${fontSize1 * scale1}px ${fontFamily1}`;\n                            params1.prevFontSize = fontSize1;\n                            params1.prevFontFamily = fontFamily1;\n                        }\n                        const { width: width2 } = ctx1.measureText(div1.textContent);\n                        if (width2 > 0) {\n                            transform1 = `scaleX(${canvasWidth1 * scale1 / width2})`;\n                        }\n                    }\n                    if (properties1.angle !== 0) {\n                        transform1 = `rotate(${properties1.angle}deg) ${transform1}`;\n                    }\n                    if (transform1.length > 0) {\n                        style1.transform = transform1;\n                    }\n                }\n                function render1(task1) {\n                    if (task1._canceled) {\n                        return;\n                    }\n                    const textDivs1 = task1._textDivs;\n                    const capability1 = task1._capability;\n                    const textDivsLength1 = textDivs1.length;\n                    if (textDivsLength1 > MAX_TEXT_DIVS_TO_RENDER1) {\n                        capability1.resolve();\n                        return;\n                    }\n                    if (!task1._isReadableStream) {\n                        for (const textDiv1 of textDivs1){\n                            task1._layoutText(textDiv1);\n                        }\n                    }\n                    capability1.resolve();\n                }\n                class TextLayerRenderTask1 {\n                    constructor({ textContentSource: textContentSource1, container: container1, viewport: viewport1, textDivs: textDivs1, textDivProperties: textDivProperties1, textContentItemsStr: textContentItemsStr1, isOffscreenCanvasSupported: isOffscreenCanvasSupported1 }){\n                        this._textContentSource = textContentSource1;\n                        this._isReadableStream = textContentSource1 instanceof ReadableStream;\n                        this._container = this._rootContainer = container1;\n                        this._textDivs = textDivs1 || [];\n                        this._textContentItemsStr = textContentItemsStr1 || [];\n                        this._isOffscreenCanvasSupported = isOffscreenCanvasSupported1;\n                        this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n                        this._reader = null;\n                        this._textDivProperties = textDivProperties1 || new WeakMap();\n                        this._canceled = false;\n                        this._capability = new _util1.PromiseCapability();\n                        this._layoutTextParams = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale: viewport1.scale * (globalThis.devicePixelRatio || 1),\n                            properties: null,\n                            ctx: getCtx1(0, isOffscreenCanvasSupported1)\n                        };\n                        const { pageWidth: pageWidth1, pageHeight: pageHeight1, pageX: pageX1, pageY: pageY1 } = viewport1.rawDims;\n                        this._transform = [\n                            1,\n                            0,\n                            0,\n                            -1,\n                            -pageX1,\n                            pageY1 + pageHeight1\n                        ];\n                        this._pageWidth = pageWidth1;\n                        this._pageHeight = pageHeight1;\n                        (0, _display_utils1.setLayerDimensions)(container1, viewport1);\n                        this._capability.promise.finally(()=>{\n                            this._layoutTextParams = null;\n                        }).catch(()=>{});\n                    }\n                    get promise() {\n                        return this._capability.promise;\n                    }\n                    cancel() {\n                        this._canceled = true;\n                        if (this._reader) {\n                            this._reader.cancel(new _util1.AbortException(\"TextLayer task cancelled.\")).catch(()=>{});\n                            this._reader = null;\n                        }\n                        this._capability.reject(new _util1.AbortException(\"TextLayer task cancelled.\"));\n                    }\n                    _processItems(items1, styleCache1) {\n                        for (const item1 of items1){\n                            if (item1.str === undefined) {\n                                if (item1.type === \"beginMarkedContentProps\" || item1.type === \"beginMarkedContent\") {\n                                    const parent1 = this._container;\n                                    this._container = document.createElement(\"span\");\n                                    this._container.classList.add(\"markedContent\");\n                                    if (item1.id !== null) {\n                                        this._container.setAttribute(\"id\", `${item1.id}`);\n                                    }\n                                    parent1.append(this._container);\n                                } else if (item1.type === \"endMarkedContent\") {\n                                    this._container = this._container.parentNode;\n                                }\n                                continue;\n                            }\n                            this._textContentItemsStr.push(item1.str);\n                            appendText1(this, item1, styleCache1);\n                        }\n                    }\n                    _layoutText(textDiv1) {\n                        const textDivProperties1 = this._layoutTextParams.properties = this._textDivProperties.get(textDiv1);\n                        this._layoutTextParams.div = textDiv1;\n                        layout1(this._layoutTextParams);\n                        if (textDivProperties1.hasText) {\n                            this._container.append(textDiv1);\n                        }\n                        if (textDivProperties1.hasEOL) {\n                            const br1 = document.createElement(\"br\");\n                            br1.setAttribute(\"role\", \"presentation\");\n                            this._container.append(br1);\n                        }\n                    }\n                    _render() {\n                        const capability1 = new _util1.PromiseCapability();\n                        let styleCache1 = Object.create(null);\n                        if (this._isReadableStream) {\n                            const pump1 = ()=>{\n                                this._reader.read().then(({ value: value1, done: done1 })=>{\n                                    if (done1) {\n                                        capability1.resolve();\n                                        return;\n                                    }\n                                    Object.assign(styleCache1, value1.styles);\n                                    this._processItems(value1.items, styleCache1);\n                                    pump1();\n                                }, capability1.reject);\n                            };\n                            this._reader = this._textContentSource.getReader();\n                            pump1();\n                        } else if (this._textContentSource) {\n                            const { items: items1, styles: styles1 } = this._textContentSource;\n                            this._processItems(items1, styles1);\n                            capability1.resolve();\n                        } else {\n                            throw new Error('No \"textContentSource\" parameter specified.');\n                        }\n                        capability1.promise.then(()=>{\n                            styleCache1 = null;\n                            render1(this);\n                        }, this._capability.reject);\n                    }\n                }\n                exports1.TextLayerRenderTask = TextLayerRenderTask1;\n                function renderTextLayer1(params1) {\n                    if (!params1.textContentSource && (params1.textContent || params1.textContentStream)) {\n                        (0, _display_utils1.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n                        params1.textContentSource = params1.textContent || params1.textContentStream;\n                    }\n                    const { container: container1, viewport: viewport1 } = params1;\n                    const style1 = getComputedStyle(container1);\n                    const visibility1 = style1.getPropertyValue(\"visibility\");\n                    const scaleFactor1 = parseFloat(style1.getPropertyValue(\"--scale-factor\"));\n                    if (visibility1 === \"visible\" && (!scaleFactor1 || Math.abs(scaleFactor1 - viewport1.scale) > 1e-5)) {\n                        console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n                    }\n                    const task1 = new TextLayerRenderTask1(params1);\n                    task1._render();\n                    return task1;\n                }\n                function updateTextLayer1({ container: container1, viewport: viewport1, textDivs: textDivs1, textDivProperties: textDivProperties1, isOffscreenCanvasSupported: isOffscreenCanvasSupported1, mustRotate: mustRotate1 = true, mustRescale: mustRescale1 = true }) {\n                    if (mustRotate1) {\n                        (0, _display_utils1.setLayerDimensions)(container1, {\n                            rotation: viewport1.rotation\n                        });\n                    }\n                    if (mustRescale1) {\n                        const ctx1 = getCtx1(0, isOffscreenCanvasSupported1);\n                        const scale1 = viewport1.scale * (globalThis.devicePixelRatio || 1);\n                        const params1 = {\n                            prevFontSize: null,\n                            prevFontFamily: null,\n                            div: null,\n                            scale: scale1,\n                            properties: null,\n                            ctx: ctx1\n                        };\n                        for (const div1 of textDivs1){\n                            params1.properties = textDivProperties1.get(div1);\n                            params1.div = div1;\n                            layout1(params1);\n                        }\n                    }\n                }\n            /***/ },\n            /* 27 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.AnnotationEditorLayer = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _editor1 = __w_pdfjs_require__1(4);\n                var _freetext1 = __w_pdfjs_require__1(28);\n                var _ink1 = __w_pdfjs_require__1(33);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _stamp1 = __w_pdfjs_require__1(34);\n                class AnnotationEditorLayer1 {\n                    #accessibilityManager;\n                    #allowClick;\n                    #annotationLayer;\n                    #boundPointerup;\n                    #boundPointerdown;\n                    #editors;\n                    #hadPointerDown;\n                    #isCleaningUp;\n                    #isDisabling;\n                    #uiManager;\n                    static{\n                        this._initialized = false;\n                    }\n                    constructor({ uiManager: uiManager1, pageIndex: pageIndex1, div: div1, accessibilityManager: accessibilityManager1, annotationLayer: annotationLayer1, viewport: viewport1, l10n: l10n1 }){\n                        this.#allowClick = false;\n                        this.#annotationLayer = null;\n                        this.#boundPointerup = this.pointerup.bind(this);\n                        this.#boundPointerdown = this.pointerdown.bind(this);\n                        this.#editors = new Map();\n                        this.#hadPointerDown = false;\n                        this.#isCleaningUp = false;\n                        this.#isDisabling = false;\n                        const editorTypes1 = [\n                            _freetext1.FreeTextEditor,\n                            _ink1.InkEditor,\n                            _stamp1.StampEditor\n                        ];\n                        if (!AnnotationEditorLayer1._initialized) {\n                            AnnotationEditorLayer1._initialized = true;\n                            for (const editorType1 of editorTypes1){\n                                editorType1.initialize(l10n1);\n                            }\n                        }\n                        uiManager1.registerEditorTypes(editorTypes1);\n                        this.#uiManager = uiManager1;\n                        this.pageIndex = pageIndex1;\n                        this.div = div1;\n                        this.#accessibilityManager = accessibilityManager1;\n                        this.#annotationLayer = annotationLayer1;\n                        this.viewport = viewport1;\n                        this.#uiManager.addLayer(this);\n                    }\n                    get isEmpty() {\n                        return this.#editors.size === 0;\n                    }\n                    updateToolbar(mode1) {\n                        this.#uiManager.updateToolbar(mode1);\n                    }\n                    updateMode(mode1 = this.#uiManager.getMode()) {\n                        this.#cleanup();\n                        if (mode1 === _util1.AnnotationEditorType.INK) {\n                            this.addInkEditorIfNeeded(false);\n                            this.disableClick();\n                        } else {\n                            this.enableClick();\n                        }\n                        if (mode1 !== _util1.AnnotationEditorType.NONE) {\n                            this.div.classList.toggle(\"freeTextEditing\", mode1 === _util1.AnnotationEditorType.FREETEXT);\n                            this.div.classList.toggle(\"inkEditing\", mode1 === _util1.AnnotationEditorType.INK);\n                            this.div.classList.toggle(\"stampEditing\", mode1 === _util1.AnnotationEditorType.STAMP);\n                            this.div.hidden = false;\n                        }\n                    }\n                    addInkEditorIfNeeded(isCommitting1) {\n                        if (!isCommitting1 && this.#uiManager.getMode() !== _util1.AnnotationEditorType.INK) {\n                            return;\n                        }\n                        if (!isCommitting1) {\n                            for (const editor1 of this.#editors.values()){\n                                if (editor1.isEmpty()) {\n                                    editor1.setInBackground();\n                                    return;\n                                }\n                            }\n                        }\n                        const editor1 = this.#createAndAddNewEditor({\n                            offsetX: 0,\n                            offsetY: 0\n                        }, false);\n                        editor1.setInBackground();\n                    }\n                    setEditingState(isEditing1) {\n                        this.#uiManager.setEditingState(isEditing1);\n                    }\n                    addCommands(params1) {\n                        this.#uiManager.addCommands(params1);\n                    }\n                    enable() {\n                        this.div.style.pointerEvents = \"auto\";\n                        const annotationElementIds1 = new Set();\n                        for (const editor1 of this.#editors.values()){\n                            editor1.enableEditing();\n                            if (editor1.annotationElementId) {\n                                annotationElementIds1.add(editor1.annotationElementId);\n                            }\n                        }\n                        if (!this.#annotationLayer) {\n                            return;\n                        }\n                        const editables1 = this.#annotationLayer.getEditableAnnotations();\n                        for (const editable1 of editables1){\n                            editable1.hide();\n                            if (this.#uiManager.isDeletedAnnotationElement(editable1.data.id)) {\n                                continue;\n                            }\n                            if (annotationElementIds1.has(editable1.data.id)) {\n                                continue;\n                            }\n                            const editor1 = this.deserialize(editable1);\n                            if (!editor1) {\n                                continue;\n                            }\n                            this.addOrRebuild(editor1);\n                            editor1.enableEditing();\n                        }\n                    }\n                    disable() {\n                        this.#isDisabling = true;\n                        this.div.style.pointerEvents = \"none\";\n                        const hiddenAnnotationIds1 = new Set();\n                        for (const editor1 of this.#editors.values()){\n                            editor1.disableEditing();\n                            if (!editor1.annotationElementId || editor1.serialize() !== null) {\n                                hiddenAnnotationIds1.add(editor1.annotationElementId);\n                                continue;\n                            }\n                            this.getEditableAnnotation(editor1.annotationElementId)?.show();\n                            editor1.remove();\n                        }\n                        if (this.#annotationLayer) {\n                            const editables1 = this.#annotationLayer.getEditableAnnotations();\n                            for (const editable1 of editables1){\n                                const { id: id1 } = editable1.data;\n                                if (hiddenAnnotationIds1.has(id1) || this.#uiManager.isDeletedAnnotationElement(id1)) {\n                                    continue;\n                                }\n                                editable1.show();\n                            }\n                        }\n                        this.#cleanup();\n                        if (this.isEmpty) {\n                            this.div.hidden = true;\n                        }\n                        this.#isDisabling = false;\n                    }\n                    getEditableAnnotation(id1) {\n                        return this.#annotationLayer?.getEditableAnnotation(id1) || null;\n                    }\n                    setActiveEditor(editor1) {\n                        const currentActive1 = this.#uiManager.getActive();\n                        if (currentActive1 === editor1) {\n                            return;\n                        }\n                        this.#uiManager.setActiveEditor(editor1);\n                    }\n                    enableClick() {\n                        this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    disableClick() {\n                        this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n                        this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n                    }\n                    attach(editor1) {\n                        this.#editors.set(editor1.id, editor1);\n                        const { annotationElementId: annotationElementId1 } = editor1;\n                        if (annotationElementId1 && this.#uiManager.isDeletedAnnotationElement(annotationElementId1)) {\n                            this.#uiManager.removeDeletedAnnotationElement(editor1);\n                        }\n                    }\n                    detach(editor1) {\n                        this.#editors.delete(editor1.id);\n                        this.#accessibilityManager?.removePointerInTextLayer(editor1.contentDiv);\n                        if (!this.#isDisabling && editor1.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor1);\n                        }\n                    }\n                    remove(editor1) {\n                        this.detach(editor1);\n                        this.#uiManager.removeEditor(editor1);\n                        if (editor1.div.contains(document.activeElement)) {\n                            setTimeout(()=>{\n                                this.#uiManager.focusMainContainer();\n                            }, 0);\n                        }\n                        editor1.div.remove();\n                        editor1.isAttachedToDOM = false;\n                        if (!this.#isCleaningUp) {\n                            this.addInkEditorIfNeeded(false);\n                        }\n                    }\n                    changeParent(editor1) {\n                        if (editor1.parent === this) {\n                            return;\n                        }\n                        if (editor1.annotationElementId) {\n                            this.#uiManager.addDeletedAnnotationElement(editor1.annotationElementId);\n                            _editor1.AnnotationEditor.deleteAnnotationElement(editor1);\n                            editor1.annotationElementId = null;\n                        }\n                        this.attach(editor1);\n                        editor1.parent?.detach(editor1);\n                        editor1.setParent(this);\n                        if (editor1.div && editor1.isAttachedToDOM) {\n                            editor1.div.remove();\n                            this.div.append(editor1.div);\n                        }\n                    }\n                    add(editor1) {\n                        this.changeParent(editor1);\n                        this.#uiManager.addEditor(editor1);\n                        this.attach(editor1);\n                        if (!editor1.isAttachedToDOM) {\n                            const div1 = editor1.render();\n                            this.div.append(div1);\n                            editor1.isAttachedToDOM = true;\n                        }\n                        editor1.fixAndSetPosition();\n                        editor1.onceAdded();\n                        this.#uiManager.addToAnnotationStorage(editor1);\n                    }\n                    moveEditorInDOM(editor1) {\n                        if (!editor1.isAttachedToDOM) {\n                            return;\n                        }\n                        const { activeElement: activeElement1 } = document;\n                        if (editor1.div.contains(activeElement1)) {\n                            editor1._focusEventsAllowed = false;\n                            setTimeout(()=>{\n                                if (!editor1.div.contains(document.activeElement)) {\n                                    editor1.div.addEventListener(\"focusin\", ()=>{\n                                        editor1._focusEventsAllowed = true;\n                                    }, {\n                                        once: true\n                                    });\n                                    activeElement1.focus();\n                                } else {\n                                    editor1._focusEventsAllowed = true;\n                                }\n                            }, 0);\n                        }\n                        editor1._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor1.div, editor1.contentDiv, true);\n                    }\n                    addOrRebuild(editor1) {\n                        if (editor1.needsToBeRebuilt()) {\n                            editor1.rebuild();\n                        } else {\n                            this.add(editor1);\n                        }\n                    }\n                    addUndoableEditor(editor1) {\n                        const cmd1 = ()=>editor1._uiManager.rebuild(editor1);\n                        const undo1 = ()=>{\n                            editor1.remove();\n                        };\n                        this.addCommands({\n                            cmd: cmd1,\n                            undo: undo1,\n                            mustExec: false\n                        });\n                    }\n                    getNextId() {\n                        return this.#uiManager.getId();\n                    }\n                    #createNewEditor(params1) {\n                        switch(this.#uiManager.getMode()){\n                            case _util1.AnnotationEditorType.FREETEXT:\n                                return new _freetext1.FreeTextEditor(params1);\n                            case _util1.AnnotationEditorType.INK:\n                                return new _ink1.InkEditor(params1);\n                            case _util1.AnnotationEditorType.STAMP:\n                                return new _stamp1.StampEditor(params1);\n                        }\n                        return null;\n                    }\n                    pasteEditor(mode1, params1) {\n                        this.#uiManager.updateToolbar(mode1);\n                        this.#uiManager.updateMode(mode1);\n                        const { offsetX: offsetX1, offsetY: offsetY1 } = this.#getCenterPoint();\n                        const id1 = this.getNextId();\n                        const editor1 = this.#createNewEditor({\n                            parent: this,\n                            id: id1,\n                            x: offsetX1,\n                            y: offsetY1,\n                            uiManager: this.#uiManager,\n                            isCentered: true,\n                            ...params1\n                        });\n                        if (editor1) {\n                            this.add(editor1);\n                        }\n                    }\n                    deserialize(data1) {\n                        switch(data1.annotationType ?? data1.annotationEditorType){\n                            case _util1.AnnotationEditorType.FREETEXT:\n                                return _freetext1.FreeTextEditor.deserialize(data1, this, this.#uiManager);\n                            case _util1.AnnotationEditorType.INK:\n                                return _ink1.InkEditor.deserialize(data1, this, this.#uiManager);\n                            case _util1.AnnotationEditorType.STAMP:\n                                return _stamp1.StampEditor.deserialize(data1, this, this.#uiManager);\n                        }\n                        return null;\n                    }\n                    #createAndAddNewEditor(event1, isCentered1) {\n                        const id1 = this.getNextId();\n                        const editor1 = this.#createNewEditor({\n                            parent: this,\n                            id: id1,\n                            x: event1.offsetX,\n                            y: event1.offsetY,\n                            uiManager: this.#uiManager,\n                            isCentered: isCentered1\n                        });\n                        if (editor1) {\n                            this.add(editor1);\n                        }\n                        return editor1;\n                    }\n                    #getCenterPoint() {\n                        const { x: x4, y: y4, width: width2, height: height1 } = this.div.getBoundingClientRect();\n                        const tlX1 = Math.max(0, x4);\n                        const tlY1 = Math.max(0, y4);\n                        const brX1 = Math.min(window.innerWidth, x4 + width2);\n                        const brY1 = Math.min(window.innerHeight, y4 + height1);\n                        const centerX1 = (tlX1 + brX1) / 2 - x4;\n                        const centerY1 = (tlY1 + brY1) / 2 - y4;\n                        const [offsetX1, offsetY1] = this.viewport.rotation % 180 === 0 ? [\n                            centerX1,\n                            centerY1\n                        ] : [\n                            centerY1,\n                            centerX1\n                        ];\n                        return {\n                            offsetX: offsetX1,\n                            offsetY: offsetY1\n                        };\n                    }\n                    addNewEditor() {\n                        this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n                    }\n                    setSelected(editor1) {\n                        this.#uiManager.setSelected(editor1);\n                    }\n                    toggleSelected(editor1) {\n                        this.#uiManager.toggleSelected(editor1);\n                    }\n                    isSelected(editor1) {\n                        return this.#uiManager.isSelected(editor1);\n                    }\n                    unselect(editor1) {\n                        this.#uiManager.unselect(editor1);\n                    }\n                    pointerup(event1) {\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        if (event1.button !== 0 || event1.ctrlKey && isMac1) {\n                            return;\n                        }\n                        if (event1.target !== this.div) {\n                            return;\n                        }\n                        if (!this.#hadPointerDown) {\n                            return;\n                        }\n                        this.#hadPointerDown = false;\n                        if (!this.#allowClick) {\n                            this.#allowClick = true;\n                            return;\n                        }\n                        if (this.#uiManager.getMode() === _util1.AnnotationEditorType.STAMP) {\n                            this.#uiManager.unselectAll();\n                            return;\n                        }\n                        this.#createAndAddNewEditor(event1, false);\n                    }\n                    pointerdown(event1) {\n                        if (this.#hadPointerDown) {\n                            this.#hadPointerDown = false;\n                            return;\n                        }\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        if (event1.button !== 0 || event1.ctrlKey && isMac1) {\n                            return;\n                        }\n                        if (event1.target !== this.div) {\n                            return;\n                        }\n                        this.#hadPointerDown = true;\n                        const editor1 = this.#uiManager.getActive();\n                        this.#allowClick = !editor1 || editor1.isEmpty();\n                    }\n                    findNewParent(editor1, x4, y4) {\n                        const layer1 = this.#uiManager.findParent(x4, y4);\n                        if (layer1 === null || layer1 === this) {\n                            return false;\n                        }\n                        layer1.changeParent(editor1);\n                        return true;\n                    }\n                    destroy() {\n                        if (this.#uiManager.getActive()?.parent === this) {\n                            this.#uiManager.commitOrRemove();\n                            this.#uiManager.setActiveEditor(null);\n                        }\n                        for (const editor1 of this.#editors.values()){\n                            this.#accessibilityManager?.removePointerInTextLayer(editor1.contentDiv);\n                            editor1.setParent(null);\n                            editor1.isAttachedToDOM = false;\n                            editor1.div.remove();\n                        }\n                        this.div = null;\n                        this.#editors.clear();\n                        this.#uiManager.removeLayer(this);\n                    }\n                    #cleanup() {\n                        this.#isCleaningUp = true;\n                        for (const editor1 of this.#editors.values()){\n                            if (editor1.isEmpty()) {\n                                editor1.remove();\n                            }\n                        }\n                        this.#isCleaningUp = false;\n                    }\n                    render({ viewport: viewport1 }) {\n                        this.viewport = viewport1;\n                        (0, _display_utils1.setLayerDimensions)(this.div, viewport1);\n                        for (const editor1 of this.#uiManager.getEditors(this.pageIndex)){\n                            this.add(editor1);\n                        }\n                        this.updateMode();\n                    }\n                    update({ viewport: viewport1 }) {\n                        this.#uiManager.commitOrRemove();\n                        this.viewport = viewport1;\n                        (0, _display_utils1.setLayerDimensions)(this.div, {\n                            rotation: viewport1.rotation\n                        });\n                        this.updateMode();\n                    }\n                    get pageDimensions() {\n                        const { pageWidth: pageWidth1, pageHeight: pageHeight1 } = this.viewport.rawDims;\n                        return [\n                            pageWidth1,\n                            pageHeight1\n                        ];\n                    }\n                }\n                exports1.AnnotationEditorLayer = AnnotationEditorLayer1;\n            /***/ },\n            /* 28 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.FreeTextEditor = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _tools1 = __w_pdfjs_require__1(5);\n                var _editor1 = __w_pdfjs_require__1(4);\n                var _annotation_layer1 = __w_pdfjs_require__1(29);\n                class FreeTextEditor1 extends _editor1.AnnotationEditor {\n                    #boundEditorDivBlur;\n                    #boundEditorDivFocus;\n                    #boundEditorDivInput;\n                    #boundEditorDivKeydown;\n                    #color;\n                    #content;\n                    #editorDivId;\n                    #fontSize;\n                    #initialData;\n                    static{\n                        this._freeTextDefaultContent = \"\";\n                    }\n                    static{\n                        this._internalPadding = 0;\n                    }\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultFontSize = 10;\n                    }\n                    static get _keyboardManager() {\n                        const proto1 = FreeTextEditor1.prototype;\n                        const arrowChecker1 = (self1)=>self1.isEmpty();\n                        const small1 = _tools1.AnnotationEditorUIManager.TRANSLATE_SMALL;\n                        const big1 = _tools1.AnnotationEditorUIManager.TRANSLATE_BIG;\n                        return (0, _util1.shadow)(this, \"_keyboardManager\", new _tools1.KeyboardManager([\n                            [\n                                [\n                                    \"ctrl+s\",\n                                    \"mac+meta+s\",\n                                    \"ctrl+p\",\n                                    \"mac+meta+p\"\n                                ],\n                                proto1.commitOrRemove,\n                                {\n                                    bubbles: true\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+Enter\",\n                                    \"mac+meta+Enter\",\n                                    \"Escape\",\n                                    \"mac+Escape\"\n                                ],\n                                proto1.commitOrRemove\n                            ],\n                            [\n                                [\n                                    \"ArrowLeft\",\n                                    \"mac+ArrowLeft\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        -small1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowLeft\",\n                                    \"mac+shift+ArrowLeft\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        -big1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowRight\",\n                                    \"mac+ArrowRight\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        small1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowRight\",\n                                    \"mac+shift+ArrowRight\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        big1,\n                                        0\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowUp\",\n                                    \"mac+ArrowUp\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -small1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowUp\",\n                                    \"mac+shift+ArrowUp\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        -big1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ArrowDown\",\n                                    \"mac+ArrowDown\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        small1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ],\n                            [\n                                [\n                                    \"ctrl+ArrowDown\",\n                                    \"mac+shift+ArrowDown\"\n                                ],\n                                proto1._translateEmpty,\n                                {\n                                    args: [\n                                        0,\n                                        big1\n                                    ],\n                                    checker: arrowChecker1\n                                }\n                            ]\n                        ]));\n                    }\n                    static{\n                        this._type = \"freetext\";\n                    }\n                    constructor(params1){\n                        super({\n                            ...params1,\n                            name: \"freeTextEditor\"\n                        });\n                        this.#boundEditorDivBlur = this.editorDivBlur.bind(this);\n                        this.#boundEditorDivFocus = this.editorDivFocus.bind(this);\n                        this.#boundEditorDivInput = this.editorDivInput.bind(this);\n                        this.#boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n                        this.#content = \"\";\n                        this.#editorDivId = `${this.id}-editor`;\n                        this.#initialData = null;\n                        this.#color = params1.color || FreeTextEditor1._defaultColor || _editor1.AnnotationEditor._defaultLineColor;\n                        this.#fontSize = params1.fontSize || FreeTextEditor1._defaultFontSize;\n                    }\n                    static initialize(l10n1) {\n                        _editor1.AnnotationEditor.initialize(l10n1, {\n                            strings: [\n                                \"free_text2_default_content\",\n                                \"editor_free_text2_aria_label\"\n                            ]\n                        });\n                        const style1 = getComputedStyle(document.documentElement);\n                        this._internalPadding = parseFloat(style1.getPropertyValue(\"--freetext-padding\"));\n                    }\n                    static updateDefaultParams(type1, value1) {\n                        switch(type1){\n                            case _util1.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                FreeTextEditor1._defaultFontSize = value1;\n                                break;\n                            case _util1.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                FreeTextEditor1._defaultColor = value1;\n                                break;\n                        }\n                    }\n                    updateParams(type1, value1) {\n                        switch(type1){\n                            case _util1.AnnotationEditorParamsType.FREETEXT_SIZE:\n                                this.#updateFontSize(value1);\n                                break;\n                            case _util1.AnnotationEditorParamsType.FREETEXT_COLOR:\n                                this.#updateColor(value1);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util1.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                FreeTextEditor1._defaultFontSize\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                FreeTextEditor1._defaultColor || _editor1.AnnotationEditor._defaultLineColor\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util1.AnnotationEditorParamsType.FREETEXT_SIZE,\n                                this.#fontSize\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.FREETEXT_COLOR,\n                                this.#color\n                            ]\n                        ];\n                    }\n                    #updateFontSize(fontSize1) {\n                        const setFontsize1 = (size1)=>{\n                            this.editorDiv.style.fontSize = `calc(${size1}px * var(--scale-factor))`;\n                            this.translate(0, -(size1 - this.#fontSize) * this.parentScale);\n                            this.#fontSize = size1;\n                            this.#setEditorDimensions();\n                        };\n                        const savedFontsize1 = this.#fontSize;\n                        this.addCommands({\n                            cmd: ()=>{\n                                setFontsize1(fontSize1);\n                            },\n                            undo: ()=>{\n                                setFontsize1(savedFontsize1);\n                            },\n                            mustExec: true,\n                            type: _util1.AnnotationEditorParamsType.FREETEXT_SIZE,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color1) {\n                        const savedColor1 = this.#color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.#color = this.editorDiv.style.color = color1;\n                            },\n                            undo: ()=>{\n                                this.#color = this.editorDiv.style.color = savedColor1;\n                            },\n                            mustExec: true,\n                            type: _util1.AnnotationEditorParamsType.FREETEXT_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    _translateEmpty(x4, y4) {\n                        this._uiManager.translateSelectedEditors(x4, y4, true);\n                    }\n                    getInitialTranslation() {\n                        const scale1 = this.parentScale;\n                        return [\n                            -FreeTextEditor1._internalPadding * scale1,\n                            -(FreeTextEditor1._internalPadding + this.#fontSize) * scale1\n                        ];\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    enableEditMode() {\n                        if (this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(false);\n                        this.parent.updateToolbar(_util1.AnnotationEditorType.FREETEXT);\n                        super.enableEditMode();\n                        this.overlayDiv.classList.remove(\"enabled\");\n                        this.editorDiv.contentEditable = true;\n                        this._isDraggable = false;\n                        this.div.removeAttribute(\"aria-activedescendant\");\n                        this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        this.parent.setEditingState(true);\n                        super.disableEditMode();\n                        this.overlayDiv.classList.add(\"enabled\");\n                        this.editorDiv.contentEditable = false;\n                        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n                        this._isDraggable = true;\n                        this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n                        this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n                        this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n                        this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                        this.isEditing = false;\n                        this.parent.div.classList.add(\"freeTextEditing\");\n                    }\n                    focusin(event1) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event1);\n                        if (event1.target !== this.editorDiv) {\n                            this.editorDiv.focus();\n                        }\n                    }\n                    onceAdded() {\n                        if (this.width) {\n                            this.#cheatInitialRect();\n                            return;\n                        }\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        }\n                        this._initialOptions = null;\n                    }\n                    isEmpty() {\n                        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n                    }\n                    remove() {\n                        this.isEditing = false;\n                        if (this.parent) {\n                            this.parent.setEditingState(true);\n                            this.parent.div.classList.add(\"freeTextEditing\");\n                        }\n                        super.remove();\n                    }\n                    #extractText() {\n                        const divs1 = this.editorDiv.getElementsByTagName(\"div\");\n                        if (divs1.length === 0) {\n                            return this.editorDiv.innerText;\n                        }\n                        const buffer1 = [];\n                        for (const div1 of divs1){\n                            buffer1.push(div1.innerText.replace(/\\r\\n?|\\n/, \"\"));\n                        }\n                        return buffer1.join(\"\\n\");\n                    }\n                    #setEditorDimensions() {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        let rect3;\n                        if (this.isAttachedToDOM) {\n                            rect3 = this.div.getBoundingClientRect();\n                        } else {\n                            const { currentLayer: currentLayer1, div: div1 } = this;\n                            const savedDisplay1 = div1.style.display;\n                            div1.style.display = \"hidden\";\n                            currentLayer1.div.append(this.div);\n                            rect3 = div1.getBoundingClientRect();\n                            div1.remove();\n                            div1.style.display = savedDisplay1;\n                        }\n                        if (this.rotation % 180 === this.parentRotation % 180) {\n                            this.width = rect3.width / parentWidth1;\n                            this.height = rect3.height / parentHeight1;\n                        } else {\n                            this.width = rect3.height / parentWidth1;\n                            this.height = rect3.width / parentHeight1;\n                        }\n                        this.fixAndSetPosition();\n                    }\n                    commit() {\n                        if (!this.isInEditMode()) {\n                            return;\n                        }\n                        super.commit();\n                        this.disableEditMode();\n                        const savedText1 = this.#content;\n                        const newText1 = this.#content = this.#extractText().trimEnd();\n                        if (savedText1 === newText1) {\n                            return;\n                        }\n                        const setText1 = (text1)=>{\n                            this.#content = text1;\n                            if (!text1) {\n                                this.remove();\n                                return;\n                            }\n                            this.#setContent();\n                            this._uiManager.rebuild(this);\n                            this.#setEditorDimensions();\n                        };\n                        this.addCommands({\n                            cmd: ()=>{\n                                setText1(newText1);\n                            },\n                            undo: ()=>{\n                                setText1(savedText1);\n                            },\n                            mustExec: false\n                        });\n                        this.#setEditorDimensions();\n                    }\n                    shouldGetKeyboardEvents() {\n                        return this.isInEditMode();\n                    }\n                    enterInEditMode() {\n                        this.enableEditMode();\n                        this.editorDiv.focus();\n                    }\n                    dblclick(event1) {\n                        this.enterInEditMode();\n                    }\n                    keydown(event1) {\n                        if (event1.target === this.div && event1.key === \"Enter\") {\n                            this.enterInEditMode();\n                            event1.preventDefault();\n                        }\n                    }\n                    editorDivKeydown(event1) {\n                        FreeTextEditor1._keyboardManager.exec(this, event1);\n                    }\n                    editorDivFocus(event1) {\n                        this.isEditing = true;\n                    }\n                    editorDivBlur(event1) {\n                        this.isEditing = false;\n                    }\n                    editorDivInput(event1) {\n                        this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n                    }\n                    disableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"comment\");\n                        this.editorDiv.removeAttribute(\"aria-multiline\");\n                    }\n                    enableEditing() {\n                        this.editorDiv.setAttribute(\"role\", \"textbox\");\n                        this.editorDiv.setAttribute(\"aria-multiline\", true);\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX1, baseY1;\n                        if (this.width) {\n                            baseX1 = this.x;\n                            baseY1 = this.y;\n                        }\n                        super.render();\n                        this.editorDiv = document.createElement(\"div\");\n                        this.editorDiv.className = \"internal\";\n                        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n                        this.enableEditing();\n                        _editor1.AnnotationEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then((msg1)=>this.editorDiv?.setAttribute(\"aria-label\", msg1));\n                        _editor1.AnnotationEditor._l10nPromise.get(\"free_text2_default_content\").then((msg1)=>this.editorDiv?.setAttribute(\"default-content\", msg1));\n                        this.editorDiv.contentEditable = true;\n                        const { style: style1 } = this.editorDiv;\n                        style1.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n                        style1.color = this.#color;\n                        this.div.append(this.editorDiv);\n                        this.overlayDiv = document.createElement(\"div\");\n                        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n                        this.div.append(this.overlayDiv);\n                        (0, _tools1.bindEvents)(this, this.div, [\n                            \"dblclick\",\n                            \"keydown\"\n                        ]);\n                        if (this.width) {\n                            const [parentWidth1, parentHeight1] = this.parentDimensions;\n                            if (this.annotationElementId) {\n                                const { position: position1 } = this.#initialData;\n                                let [tx2, ty2] = this.getInitialTranslation();\n                                [tx2, ty2] = this.pageTranslationToScreen(tx2, ty2);\n                                const [pageWidth1, pageHeight1] = this.pageDimensions;\n                                const [pageX1, pageY1] = this.pageTranslation;\n                                let posX1, posY1;\n                                switch(this.rotation){\n                                    case 0:\n                                        posX1 = baseX1 + (position1[0] - pageX1) / pageWidth1;\n                                        posY1 = baseY1 + this.height - (position1[1] - pageY1) / pageHeight1;\n                                        break;\n                                    case 90:\n                                        posX1 = baseX1 + (position1[0] - pageX1) / pageWidth1;\n                                        posY1 = baseY1 - (position1[1] - pageY1) / pageHeight1;\n                                        [tx2, ty2] = [\n                                            ty2,\n                                            -tx2\n                                        ];\n                                        break;\n                                    case 180:\n                                        posX1 = baseX1 - this.width + (position1[0] - pageX1) / pageWidth1;\n                                        posY1 = baseY1 - (position1[1] - pageY1) / pageHeight1;\n                                        [tx2, ty2] = [\n                                            -tx2,\n                                            -ty2\n                                        ];\n                                        break;\n                                    case 270:\n                                        posX1 = baseX1 + (position1[0] - pageX1 - this.height * pageHeight1) / pageWidth1;\n                                        posY1 = baseY1 + (position1[1] - pageY1 - this.width * pageWidth1) / pageHeight1;\n                                        [tx2, ty2] = [\n                                            -ty2,\n                                            tx2\n                                        ];\n                                        break;\n                                }\n                                this.setAt(posX1 * parentWidth1, posY1 * parentHeight1, tx2, ty2);\n                            } else {\n                                this.setAt(baseX1 * parentWidth1, baseY1 * parentHeight1, this.width * parentWidth1, this.height * parentHeight1);\n                            }\n                            this.#setContent();\n                            this._isDraggable = true;\n                            this.editorDiv.contentEditable = false;\n                        } else {\n                            this._isDraggable = false;\n                            this.editorDiv.contentEditable = true;\n                        }\n                        return this.div;\n                    }\n                    #setContent() {\n                        this.editorDiv.replaceChildren();\n                        if (!this.#content) {\n                            return;\n                        }\n                        for (const line1 of this.#content.split(\"\\n\")){\n                            const div1 = document.createElement(\"div\");\n                            div1.append(line1 ? document.createTextNode(line1) : document.createElement(\"br\"));\n                            this.editorDiv.append(div1);\n                        }\n                    }\n                    get contentDiv() {\n                        return this.editorDiv;\n                    }\n                    static deserialize(data1, parent1, uiManager1) {\n                        let initialData1 = null;\n                        if (data1 instanceof _annotation_layer1.FreeTextAnnotationElement) {\n                            const { data: { defaultAppearanceData: { fontSize: fontSize1, fontColor: fontColor1 }, rect: rect3, rotation: rotation1, id: id1 }, textContent: textContent1, textPosition: textPosition1, parent: { page: { pageNumber: pageNumber1 } } } = data1;\n                            if (!textContent1 || textContent1.length === 0) {\n                                return null;\n                            }\n                            initialData1 = data1 = {\n                                annotationType: _util1.AnnotationEditorType.FREETEXT,\n                                color: Array.from(fontColor1),\n                                fontSize: fontSize1,\n                                value: textContent1.join(\"\\n\"),\n                                position: textPosition1,\n                                pageIndex: pageNumber1 - 1,\n                                rect: rect3,\n                                rotation: rotation1,\n                                id: id1,\n                                deleted: false\n                            };\n                        }\n                        const editor1 = super.deserialize(data1, parent1, uiManager1);\n                        editor1.#fontSize = data1.fontSize;\n                        editor1.#color = _util1.Util.makeHexColor(...data1.color);\n                        editor1.#content = data1.value;\n                        editor1.annotationElementId = data1.id || null;\n                        editor1.#initialData = initialData1;\n                        return editor1;\n                    }\n                    serialize(isForCopying1 = false) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        if (this.deleted) {\n                            return {\n                                pageIndex: this.pageIndex,\n                                id: this.annotationElementId,\n                                deleted: true\n                            };\n                        }\n                        const padding1 = FreeTextEditor1._internalPadding * this.parentScale;\n                        const rect3 = this.getRect(padding1, padding1);\n                        const color1 = _editor1.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n                        const serialized1 = {\n                            annotationType: _util1.AnnotationEditorType.FREETEXT,\n                            color: color1,\n                            fontSize: this.#fontSize,\n                            value: this.#content,\n                            pageIndex: this.pageIndex,\n                            rect: rect3,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying1) {\n                            return serialized1;\n                        }\n                        if (this.annotationElementId && !this.#hasElementChanged(serialized1)) {\n                            return null;\n                        }\n                        serialized1.id = this.annotationElementId;\n                        return serialized1;\n                    }\n                    #hasElementChanged(serialized1) {\n                        const { value: value1, fontSize: fontSize1, color: color1, rect: rect3, pageIndex: pageIndex1 } = this.#initialData;\n                        return serialized1.value !== value1 || serialized1.fontSize !== fontSize1 || serialized1.rect.some((x4, i1)=>Math.abs(x4 - rect3[i1]) >= 1) || serialized1.color.some((c4, i1)=>c4 !== color1[i1]) || serialized1.pageIndex !== pageIndex1;\n                    }\n                    #cheatInitialRect(delayed1 = false) {\n                        if (!this.annotationElementId) {\n                            return;\n                        }\n                        this.#setEditorDimensions();\n                        if (!delayed1 && (this.width === 0 || this.height === 0)) {\n                            setTimeout(()=>this.#cheatInitialRect(true), 0);\n                            return;\n                        }\n                        const padding1 = FreeTextEditor1._internalPadding * this.parentScale;\n                        this.#initialData.rect = this.getRect(padding1, padding1);\n                    }\n                }\n                exports1.FreeTextEditor = FreeTextEditor1;\n            /***/ },\n            /* 29 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampAnnotationElement = exports1.InkAnnotationElement = exports1.FreeTextAnnotationElement = exports1.AnnotationLayer = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _annotation_storage1 = __w_pdfjs_require__1(3);\n                var _scripting_utils1 = __w_pdfjs_require__1(30);\n                var _displayL10n_utils1 = __w_pdfjs_require__1(31);\n                var _xfa_layer1 = __w_pdfjs_require__1(32);\n                const DEFAULT_TAB_INDEX1 = 1000;\n                const DEFAULT_FONT_SIZE1 = 9;\n                const GetElementsByNameSet1 = new WeakSet();\n                function getRectDims1(rect3) {\n                    return {\n                        width: rect3[2] - rect3[0],\n                        height: rect3[3] - rect3[1]\n                    };\n                }\n                class AnnotationElementFactory1 {\n                    static create(parameters1) {\n                        const subtype1 = parameters1.data.annotationType;\n                        switch(subtype1){\n                            case _util1.AnnotationType.LINK:\n                                return new LinkAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.TEXT:\n                                return new TextAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.WIDGET:\n                                const fieldType1 = parameters1.data.fieldType;\n                                switch(fieldType1){\n                                    case \"Tx\":\n                                        return new TextWidgetAnnotationElement1(parameters1);\n                                    case \"Btn\":\n                                        if (parameters1.data.radioButton) {\n                                            return new RadioButtonWidgetAnnotationElement1(parameters1);\n                                        } else if (parameters1.data.checkBox) {\n                                            return new CheckboxWidgetAnnotationElement1(parameters1);\n                                        }\n                                        return new PushButtonWidgetAnnotationElement1(parameters1);\n                                    case \"Ch\":\n                                        return new ChoiceWidgetAnnotationElement1(parameters1);\n                                    case \"Sig\":\n                                        return new SignatureWidgetAnnotationElement1(parameters1);\n                                }\n                                return new WidgetAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.POPUP:\n                                return new PopupAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.FREETEXT:\n                                return new FreeTextAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.LINE:\n                                return new LineAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.SQUARE:\n                                return new SquareAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.CIRCLE:\n                                return new CircleAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.POLYLINE:\n                                return new PolylineAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.CARET:\n                                return new CaretAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.INK:\n                                return new InkAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.POLYGON:\n                                return new PolygonAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.HIGHLIGHT:\n                                return new HighlightAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.UNDERLINE:\n                                return new UnderlineAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.SQUIGGLY:\n                                return new SquigglyAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.STRIKEOUT:\n                                return new StrikeOutAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.STAMP:\n                                return new StampAnnotationElement1(parameters1);\n                            case _util1.AnnotationType.FILEATTACHMENT:\n                                return new FileAttachmentAnnotationElement1(parameters1);\n                            default:\n                                return new AnnotationElement1(parameters1);\n                        }\n                    }\n                }\n                class AnnotationElement1 {\n                    #hasBorder;\n                    constructor(parameters1, { isRenderable: isRenderable1 = false, ignoreBorder: ignoreBorder1 = false, createQuadrilaterals: createQuadrilaterals1 = false } = {}){\n                        this.#hasBorder = false;\n                        this.isRenderable = isRenderable1;\n                        this.data = parameters1.data;\n                        this.layer = parameters1.layer;\n                        this.linkService = parameters1.linkService;\n                        this.downloadManager = parameters1.downloadManager;\n                        this.imageResourcesPath = parameters1.imageResourcesPath;\n                        this.renderForms = parameters1.renderForms;\n                        this.svgFactory = parameters1.svgFactory;\n                        this.annotationStorage = parameters1.annotationStorage;\n                        this.enableScripting = parameters1.enableScripting;\n                        this.hasJSActions = parameters1.hasJSActions;\n                        this._fieldObjects = parameters1.fieldObjects;\n                        this.parent = parameters1.parent;\n                        if (isRenderable1) {\n                            this.container = this._createContainer(ignoreBorder1);\n                        }\n                        if (createQuadrilaterals1) {\n                            this._createQuadrilaterals();\n                        }\n                    }\n                    static _hasPopupData({ titleObj: titleObj1, contentsObj: contentsObj1, richText: richText1 }) {\n                        return !!(titleObj1?.str || contentsObj1?.str || richText1?.str);\n                    }\n                    get hasPopupData() {\n                        return AnnotationElement1._hasPopupData(this.data);\n                    }\n                    _createContainer(ignoreBorder1) {\n                        const { data: data1, parent: { page: page1, viewport: viewport1 } } = this;\n                        const container1 = document.createElement(\"section\");\n                        container1.setAttribute(\"data-annotation-id\", data1.id);\n                        if (!(this instanceof WidgetAnnotationElement1)) {\n                            container1.tabIndex = DEFAULT_TAB_INDEX1;\n                        }\n                        container1.style.zIndex = this.parent.zIndex++;\n                        if (this.data.popupRef) {\n                            container1.setAttribute(\"aria-haspopup\", \"dialog\");\n                        }\n                        if (data1.noRotate) {\n                            container1.classList.add(\"norotate\");\n                        }\n                        const { pageWidth: pageWidth1, pageHeight: pageHeight1, pageX: pageX1, pageY: pageY1 } = viewport1.rawDims;\n                        if (!data1.rect || this instanceof PopupAnnotationElement1) {\n                            const { rotation: rotation1 } = data1;\n                            if (!data1.hasOwnCanvas && rotation1 !== 0) {\n                                this.setRotation(rotation1, container1);\n                            }\n                            return container1;\n                        }\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const rect3 = _util1.Util.normalizeRect([\n                            data1.rect[0],\n                            page1.view[3] - data1.rect[1] + page1.view[1],\n                            data1.rect[2],\n                            page1.view[3] - data1.rect[3] + page1.view[1]\n                        ]);\n                        if (!ignoreBorder1 && data1.borderStyle.width > 0) {\n                            container1.style.borderWidth = `${data1.borderStyle.width}px`;\n                            const horizontalRadius1 = data1.borderStyle.horizontalCornerRadius;\n                            const verticalRadius1 = data1.borderStyle.verticalCornerRadius;\n                            if (horizontalRadius1 > 0 || verticalRadius1 > 0) {\n                                const radius1 = `calc(${horizontalRadius1}px * var(--scale-factor)) / calc(${verticalRadius1}px * var(--scale-factor))`;\n                                container1.style.borderRadius = radius1;\n                            } else if (this instanceof RadioButtonWidgetAnnotationElement1) {\n                                const radius1 = `calc(${width2}px * var(--scale-factor)) / calc(${height1}px * var(--scale-factor))`;\n                                container1.style.borderRadius = radius1;\n                            }\n                            switch(data1.borderStyle.style){\n                                case _util1.AnnotationBorderStyleType.SOLID:\n                                    container1.style.borderStyle = \"solid\";\n                                    break;\n                                case _util1.AnnotationBorderStyleType.DASHED:\n                                    container1.style.borderStyle = \"dashed\";\n                                    break;\n                                case _util1.AnnotationBorderStyleType.BEVELED:\n                                    (0, _util1.warn)(\"Unimplemented border style: beveled\");\n                                    break;\n                                case _util1.AnnotationBorderStyleType.INSET:\n                                    (0, _util1.warn)(\"Unimplemented border style: inset\");\n                                    break;\n                                case _util1.AnnotationBorderStyleType.UNDERLINE:\n                                    container1.style.borderBottomStyle = \"solid\";\n                                    break;\n                                default:\n                                    break;\n                            }\n                            const borderColor1 = data1.borderColor || null;\n                            if (borderColor1) {\n                                this.#hasBorder = true;\n                                container1.style.borderColor = _util1.Util.makeHexColor(borderColor1[0] | 0, borderColor1[1] | 0, borderColor1[2] | 0);\n                            } else {\n                                container1.style.borderWidth = 0;\n                            }\n                        }\n                        container1.style.left = `${100 * (rect3[0] - pageX1) / pageWidth1}%`;\n                        container1.style.top = `${100 * (rect3[1] - pageY1) / pageHeight1}%`;\n                        const { rotation: rotation1 } = data1;\n                        if (data1.hasOwnCanvas || rotation1 === 0) {\n                            container1.style.width = `${100 * width2 / pageWidth1}%`;\n                            container1.style.height = `${100 * height1 / pageHeight1}%`;\n                        } else {\n                            this.setRotation(rotation1, container1);\n                        }\n                        return container1;\n                    }\n                    setRotation(angle1, container1 = this.container) {\n                        if (!this.data.rect) {\n                            return;\n                        }\n                        const { pageWidth: pageWidth1, pageHeight: pageHeight1 } = this.parent.viewport.rawDims;\n                        const { width: width2, height: height1 } = getRectDims1(this.data.rect);\n                        let elementWidth1, elementHeight1;\n                        if (angle1 % 180 === 0) {\n                            elementWidth1 = 100 * width2 / pageWidth1;\n                            elementHeight1 = 100 * height1 / pageHeight1;\n                        } else {\n                            elementWidth1 = 100 * height1 / pageWidth1;\n                            elementHeight1 = 100 * width2 / pageHeight1;\n                        }\n                        container1.style.width = `${elementWidth1}%`;\n                        container1.style.height = `${elementHeight1}%`;\n                        container1.setAttribute(\"data-main-rotation\", (360 - angle1) % 360);\n                    }\n                    get _commonActions() {\n                        const setColor1 = (jsName1, styleName1, event1)=>{\n                            const color1 = event1.detail[jsName1];\n                            const colorType1 = color1[0];\n                            const colorArray1 = color1.slice(1);\n                            event1.target.style[styleName1] = _scripting_utils1.ColorConverters[`${colorType1}_HTML`](colorArray1);\n                            this.annotationStorage.setValue(this.data.id, {\n                                [styleName1]: _scripting_utils1.ColorConverters[`${colorType1}_rgb`](colorArray1)\n                            });\n                        };\n                        return (0, _util1.shadow)(this, \"_commonActions\", {\n                            display: (event1)=>{\n                                const { display: display1 } = event1.detail;\n                                const hidden1 = display1 % 2 === 1;\n                                this.container.style.visibility = hidden1 ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noView: hidden1,\n                                    noPrint: display1 === 1 || display1 === 2\n                                });\n                            },\n                            print: (event1)=>{\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: !event1.detail.print\n                                });\n                            },\n                            hidden: (event1)=>{\n                                const { hidden: hidden1 } = event1.detail;\n                                this.container.style.visibility = hidden1 ? \"hidden\" : \"visible\";\n                                this.annotationStorage.setValue(this.data.id, {\n                                    noPrint: hidden1,\n                                    noView: hidden1\n                                });\n                            },\n                            focus: (event1)=>{\n                                setTimeout(()=>event1.target.focus({\n                                        preventScroll: false\n                                    }), 0);\n                            },\n                            userName: (event1)=>{\n                                event1.target.title = event1.detail.userName;\n                            },\n                            readonly: (event1)=>{\n                                event1.target.disabled = event1.detail.readonly;\n                            },\n                            required: (event1)=>{\n                                this._setRequired(event1.target, event1.detail.required);\n                            },\n                            bgColor: (event1)=>{\n                                setColor1(\"bgColor\", \"backgroundColor\", event1);\n                            },\n                            fillColor: (event1)=>{\n                                setColor1(\"fillColor\", \"backgroundColor\", event1);\n                            },\n                            fgColor: (event1)=>{\n                                setColor1(\"fgColor\", \"color\", event1);\n                            },\n                            textColor: (event1)=>{\n                                setColor1(\"textColor\", \"color\", event1);\n                            },\n                            borderColor: (event1)=>{\n                                setColor1(\"borderColor\", \"borderColor\", event1);\n                            },\n                            strokeColor: (event1)=>{\n                                setColor1(\"strokeColor\", \"borderColor\", event1);\n                            },\n                            rotation: (event1)=>{\n                                const angle1 = event1.detail.rotation;\n                                this.setRotation(angle1);\n                                this.annotationStorage.setValue(this.data.id, {\n                                    rotation: angle1\n                                });\n                            }\n                        });\n                    }\n                    _dispatchEventFromSandbox(actions1, jsEvent1) {\n                        const commonActions1 = this._commonActions;\n                        for (const name1 of Object.keys(jsEvent1.detail)){\n                            const action1 = actions1[name1] || commonActions1[name1];\n                            action1?.(jsEvent1);\n                        }\n                    }\n                    _setDefaultPropertiesFromJS(element1) {\n                        if (!this.enableScripting) {\n                            return;\n                        }\n                        const storedData1 = this.annotationStorage.getRawValue(this.data.id);\n                        if (!storedData1) {\n                            return;\n                        }\n                        const commonActions1 = this._commonActions;\n                        for (const [actionName1, detail1] of Object.entries(storedData1)){\n                            const action1 = commonActions1[actionName1];\n                            if (action1) {\n                                const eventProxy1 = {\n                                    detail: {\n                                        [actionName1]: detail1\n                                    },\n                                    target: element1\n                                };\n                                action1(eventProxy1);\n                                delete storedData1[actionName1];\n                            }\n                        }\n                    }\n                    _createQuadrilaterals() {\n                        if (!this.container) {\n                            return;\n                        }\n                        const { quadPoints: quadPoints1 } = this.data;\n                        if (!quadPoints1) {\n                            return;\n                        }\n                        const [rectBlX1, rectBlY1, rectTrX1, rectTrY1] = this.data.rect;\n                        if (quadPoints1.length === 1) {\n                            const [, { x: trX1, y: trY1 }, { x: blX1, y: blY1 }] = quadPoints1[0];\n                            if (rectTrX1 === trX1 && rectTrY1 === trY1 && rectBlX1 === blX1 && rectBlY1 === blY1) {\n                                return;\n                            }\n                        }\n                        const { style: style1 } = this.container;\n                        let svgBuffer1;\n                        if (this.#hasBorder) {\n                            const { borderColor: borderColor1, borderWidth: borderWidth1 } = style1;\n                            style1.borderWidth = 0;\n                            svgBuffer1 = [\n                                \"url('data:image/svg+xml;utf8,\",\n                                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                                `<g fill=\"transparent\" stroke=\"${borderColor1}\" stroke-width=\"${borderWidth1}\">`\n                            ];\n                            this.container.classList.add(\"hasBorder\");\n                        }\n                        const width2 = rectTrX1 - rectBlX1;\n                        const height1 = rectTrY1 - rectBlY1;\n                        const { svgFactory: svgFactory1 } = this;\n                        const svg1 = svgFactory1.createElement(\"svg\");\n                        svg1.classList.add(\"quadrilateralsContainer\");\n                        svg1.setAttribute(\"width\", 0);\n                        svg1.setAttribute(\"height\", 0);\n                        const defs1 = svgFactory1.createElement(\"defs\");\n                        svg1.append(defs1);\n                        const clipPath1 = svgFactory1.createElement(\"clipPath\");\n                        const id1 = `clippath_${this.data.id}`;\n                        clipPath1.setAttribute(\"id\", id1);\n                        clipPath1.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n                        defs1.append(clipPath1);\n                        for (const [, { x: trX1, y: trY1 }, { x: blX1, y: blY1 }] of quadPoints1){\n                            const rect3 = svgFactory1.createElement(\"rect\");\n                            const x4 = (blX1 - rectBlX1) / width2;\n                            const y4 = (rectTrY1 - trY1) / height1;\n                            const rectWidth1 = (trX1 - blX1) / width2;\n                            const rectHeight1 = (trY1 - blY1) / height1;\n                            rect3.setAttribute(\"x\", x4);\n                            rect3.setAttribute(\"y\", y4);\n                            rect3.setAttribute(\"width\", rectWidth1);\n                            rect3.setAttribute(\"height\", rectHeight1);\n                            clipPath1.append(rect3);\n                            svgBuffer1?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x4}\" y=\"${y4}\" width=\"${rectWidth1}\" height=\"${rectHeight1}\"/>`);\n                        }\n                        if (this.#hasBorder) {\n                            svgBuffer1.push(`</g></svg>')`);\n                            style1.backgroundImage = svgBuffer1.join(\"\");\n                        }\n                        this.container.append(svg1);\n                        this.container.style.clipPath = `url(#${id1})`;\n                    }\n                    _createPopup() {\n                        const { container: container1, data: data1 } = this;\n                        container1.setAttribute(\"aria-haspopup\", \"dialog\");\n                        const popup1 = new PopupAnnotationElement1({\n                            data: {\n                                color: data1.color,\n                                titleObj: data1.titleObj,\n                                modificationDate: data1.modificationDate,\n                                contentsObj: data1.contentsObj,\n                                richText: data1.richText,\n                                parentRect: data1.rect,\n                                borderStyle: 0,\n                                id: `popup_${data1.id}`,\n                                rotation: data1.rotation\n                            },\n                            parent: this.parent,\n                            elements: [\n                                this\n                            ]\n                        });\n                        this.parent.div.append(popup1.render());\n                    }\n                    render() {\n                        (0, _util1.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n                    }\n                    _getElementsByName(name1, skipId1 = null) {\n                        const fields1 = [];\n                        if (this._fieldObjects) {\n                            const fieldObj1 = this._fieldObjects[name1];\n                            if (fieldObj1) {\n                                for (const { page: page1, id: id1, exportValues: exportValues1 } of fieldObj1){\n                                    if (page1 === -1) {\n                                        continue;\n                                    }\n                                    if (id1 === skipId1) {\n                                        continue;\n                                    }\n                                    const exportValue1 = typeof exportValues1 === \"string\" ? exportValues1 : null;\n                                    const domElement1 = document.querySelector(`[data-element-id=\"${id1}\"]`);\n                                    if (domElement1 && !GetElementsByNameSet1.has(domElement1)) {\n                                        (0, _util1.warn)(`_getElementsByName - element not allowed: ${id1}`);\n                                        continue;\n                                    }\n                                    fields1.push({\n                                        id: id1,\n                                        exportValue: exportValue1,\n                                        domElement: domElement1\n                                    });\n                                }\n                            }\n                            return fields1;\n                        }\n                        for (const domElement1 of document.getElementsByName(name1)){\n                            const { exportValue: exportValue1 } = domElement1;\n                            const id1 = domElement1.getAttribute(\"data-element-id\");\n                            if (id1 === skipId1) {\n                                continue;\n                            }\n                            if (!GetElementsByNameSet1.has(domElement1)) {\n                                continue;\n                            }\n                            fields1.push({\n                                id: id1,\n                                exportValue: exportValue1,\n                                domElement: domElement1\n                            });\n                        }\n                        return fields1;\n                    }\n                    show() {\n                        if (this.container) {\n                            this.container.hidden = false;\n                        }\n                        this.popup?.maybeShow();\n                    }\n                    hide() {\n                        if (this.container) {\n                            this.container.hidden = true;\n                        }\n                        this.popup?.forceHide();\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.container;\n                    }\n                    addHighlightArea() {\n                        const triggers1 = this.getElementsToTriggerPopup();\n                        if (Array.isArray(triggers1)) {\n                            for (const element1 of triggers1){\n                                element1.classList.add(\"highlightArea\");\n                            }\n                        } else {\n                            triggers1.classList.add(\"highlightArea\");\n                        }\n                    }\n                    _editOnDoubleClick() {\n                        const { annotationEditorType: mode1, data: { id: editId1 } } = this;\n                        this.container.addEventListener(\"dblclick\", ()=>{\n                            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                                source: this,\n                                mode: mode1,\n                                editId: editId1\n                            });\n                        });\n                    }\n                }\n                class LinkAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1, options1 = null){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: !!options1?.ignoreBorder,\n                            createQuadrilaterals: true\n                        });\n                        this.isTooltipOnly = parameters1.data.isTooltipOnly;\n                    }\n                    render() {\n                        const { data: data1, linkService: linkService1 } = this;\n                        const link1 = document.createElement(\"a\");\n                        link1.setAttribute(\"data-element-id\", data1.id);\n                        let isBound1 = false;\n                        if (data1.url) {\n                            linkService1.addLinkAttributes(link1, data1.url, data1.newWindow);\n                            isBound1 = true;\n                        } else if (data1.action) {\n                            this._bindNamedAction(link1, data1.action);\n                            isBound1 = true;\n                        } else if (data1.attachment) {\n                            this._bindAttachment(link1, data1.attachment);\n                            isBound1 = true;\n                        } else if (data1.setOCGState) {\n                            this.#bindSetOCGState(link1, data1.setOCGState);\n                            isBound1 = true;\n                        } else if (data1.dest) {\n                            this._bindLink(link1, data1.dest);\n                            isBound1 = true;\n                        } else {\n                            if (data1.actions && (data1.actions.Action || data1.actions[\"Mouse Up\"] || data1.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                                this._bindJSAction(link1, data1);\n                                isBound1 = true;\n                            }\n                            if (data1.resetForm) {\n                                this._bindResetFormAction(link1, data1.resetForm);\n                                isBound1 = true;\n                            } else if (this.isTooltipOnly && !isBound1) {\n                                this._bindLink(link1, \"\");\n                                isBound1 = true;\n                            }\n                        }\n                        this.container.classList.add(\"linkAnnotation\");\n                        if (isBound1) {\n                            this.container.append(link1);\n                        }\n                        return this.container;\n                    }\n                    #setInternalLink() {\n                        this.container.setAttribute(\"data-internal-link\", \"\");\n                    }\n                    _bindLink(link1, destination1) {\n                        link1.href = this.linkService.getDestinationHash(destination1);\n                        link1.onclick = ()=>{\n                            if (destination1) {\n                                this.linkService.goToDestination(destination1);\n                            }\n                            return false;\n                        };\n                        if (destination1 || destination1 === \"\") {\n                            this.#setInternalLink();\n                        }\n                    }\n                    _bindNamedAction(link1, action1) {\n                        link1.href = this.linkService.getAnchorUrl(\"\");\n                        link1.onclick = ()=>{\n                            this.linkService.executeNamedAction(action1);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindAttachment(link1, attachment1) {\n                        link1.href = this.linkService.getAnchorUrl(\"\");\n                        link1.onclick = ()=>{\n                            this.downloadManager?.openOrDownloadData(this.container, attachment1.content, attachment1.filename);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    #bindSetOCGState(link1, action1) {\n                        link1.href = this.linkService.getAnchorUrl(\"\");\n                        link1.onclick = ()=>{\n                            this.linkService.executeSetOCGState(action1);\n                            return false;\n                        };\n                        this.#setInternalLink();\n                    }\n                    _bindJSAction(link1, data1) {\n                        link1.href = this.linkService.getAnchorUrl(\"\");\n                        const map1 = new Map([\n                            [\n                                \"Action\",\n                                \"onclick\"\n                            ],\n                            [\n                                \"Mouse Up\",\n                                \"onmouseup\"\n                            ],\n                            [\n                                \"Mouse Down\",\n                                \"onmousedown\"\n                            ]\n                        ]);\n                        for (const name1 of Object.keys(data1.actions)){\n                            const jsName1 = map1.get(name1);\n                            if (!jsName1) {\n                                continue;\n                            }\n                            link1[jsName1] = ()=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: data1.id,\n                                        name: name1\n                                    }\n                                });\n                                return false;\n                            };\n                        }\n                        if (!link1.onclick) {\n                            link1.onclick = ()=>false;\n                        }\n                        this.#setInternalLink();\n                    }\n                    _bindResetFormAction(link1, resetForm1) {\n                        const otherClickAction1 = link1.onclick;\n                        if (!otherClickAction1) {\n                            link1.href = this.linkService.getAnchorUrl(\"\");\n                        }\n                        this.#setInternalLink();\n                        if (!this._fieldObjects) {\n                            (0, _util1.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n                            if (!otherClickAction1) {\n                                link1.onclick = ()=>false;\n                            }\n                            return;\n                        }\n                        link1.onclick = ()=>{\n                            otherClickAction1?.();\n                            const { fields: resetFormFields1, refs: resetFormRefs1, include: include1 } = resetForm1;\n                            const allFields1 = [];\n                            if (resetFormFields1.length !== 0 || resetFormRefs1.length !== 0) {\n                                const fieldIds1 = new Set(resetFormRefs1);\n                                for (const fieldName1 of resetFormFields1){\n                                    const fields1 = this._fieldObjects[fieldName1] || [];\n                                    for (const { id: id1 } of fields1){\n                                        fieldIds1.add(id1);\n                                    }\n                                }\n                                for (const fields1 of Object.values(this._fieldObjects)){\n                                    for (const field1 of fields1){\n                                        if (fieldIds1.has(field1.id) === include1) {\n                                            allFields1.push(field1);\n                                        }\n                                    }\n                                }\n                            } else {\n                                for (const fields1 of Object.values(this._fieldObjects)){\n                                    allFields1.push(...fields1);\n                                }\n                            }\n                            const storage1 = this.annotationStorage;\n                            const allIds1 = [];\n                            for (const field1 of allFields1){\n                                const { id: id1 } = field1;\n                                allIds1.push(id1);\n                                switch(field1.type){\n                                    case \"text\":\n                                        {\n                                            const value1 = field1.defaultValue || \"\";\n                                            storage1.setValue(id1, {\n                                                value: value1\n                                            });\n                                            break;\n                                        }\n                                    case \"checkbox\":\n                                    case \"radiobutton\":\n                                        {\n                                            const value1 = field1.defaultValue === field1.exportValues;\n                                            storage1.setValue(id1, {\n                                                value: value1\n                                            });\n                                            break;\n                                        }\n                                    case \"combobox\":\n                                    case \"listbox\":\n                                        {\n                                            const value1 = field1.defaultValue || \"\";\n                                            storage1.setValue(id1, {\n                                                value: value1\n                                            });\n                                            break;\n                                        }\n                                    default:\n                                        continue;\n                                }\n                                const domElement1 = document.querySelector(`[data-element-id=\"${id1}\"]`);\n                                if (!domElement1) {\n                                    continue;\n                                } else if (!GetElementsByNameSet1.has(domElement1)) {\n                                    (0, _util1.warn)(`_bindResetFormAction - element not allowed: ${id1}`);\n                                    continue;\n                                }\n                                domElement1.dispatchEvent(new Event(\"resetform\"));\n                            }\n                            if (this.enableScripting) {\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: \"app\",\n                                        ids: allIds1,\n                                        name: \"ResetForm\"\n                                    }\n                                });\n                            }\n                            return false;\n                        };\n                    }\n                }\n                class TextAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"textAnnotation\");\n                        const image1 = document.createElement(\"img\");\n                        image1.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n                        image1.alt = \"[{{type}} Annotation]\";\n                        image1.dataset.l10nId = \"text_annotation_type\";\n                        image1.dataset.l10nArgs = JSON.stringify({\n                            type: this.data.name\n                        });\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.append(image1);\n                        return this.container;\n                    }\n                }\n                class WidgetAnnotationElement1 extends AnnotationElement1 {\n                    render() {\n                        if (this.data.alternativeText) {\n                            this.container.title = this.data.alternativeText;\n                        }\n                        return this.container;\n                    }\n                    showElementAndHideCanvas(element1) {\n                        if (this.data.hasOwnCanvas) {\n                            if (element1.previousSibling?.nodeName === \"CANVAS\") {\n                                element1.previousSibling.hidden = true;\n                            }\n                            element1.hidden = false;\n                        }\n                    }\n                    _getKeyModifier(event1) {\n                        const { isWin: isWin1, isMac: isMac1 } = _util1.FeatureTest.platform;\n                        return isWin1 && event1.ctrlKey || isMac1 && event1.metaKey;\n                    }\n                    _setEventListener(element1, elementData1, baseName1, eventName1, valueGetter1) {\n                        if (baseName1.includes(\"mouse\")) {\n                            element1.addEventListener(baseName1, (event1)=>{\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName1,\n                                        value: valueGetter1(event1),\n                                        shift: event1.shiftKey,\n                                        modifier: this._getKeyModifier(event1)\n                                    }\n                                });\n                            });\n                        } else {\n                            element1.addEventListener(baseName1, (event1)=>{\n                                if (baseName1 === \"blur\") {\n                                    if (!elementData1.focused || !event1.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData1.focused = false;\n                                } else if (baseName1 === \"focus\") {\n                                    if (elementData1.focused) {\n                                        return;\n                                    }\n                                    elementData1.focused = true;\n                                }\n                                if (!valueGetter1) {\n                                    return;\n                                }\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: this.data.id,\n                                        name: eventName1,\n                                        value: valueGetter1(event1)\n                                    }\n                                });\n                            });\n                        }\n                    }\n                    _setEventListeners(element1, elementData1, names1, getter1) {\n                        for (const [baseName1, eventName1] of names1){\n                            if (eventName1 === \"Action\" || this.data.actions?.[eventName1]) {\n                                if (eventName1 === \"Focus\" || eventName1 === \"Blur\") {\n                                    elementData1 ||= {\n                                        focused: false\n                                    };\n                                }\n                                this._setEventListener(element1, elementData1, baseName1, eventName1, getter1);\n                                if (eventName1 === \"Focus\" && !this.data.actions?.Blur) {\n                                    this._setEventListener(element1, elementData1, \"blur\", \"Blur\", null);\n                                } else if (eventName1 === \"Blur\" && !this.data.actions?.Focus) {\n                                    this._setEventListener(element1, elementData1, \"focus\", \"Focus\", null);\n                                }\n                            }\n                        }\n                    }\n                    _setBackgroundColor(element1) {\n                        const color1 = this.data.backgroundColor || null;\n                        element1.style.backgroundColor = color1 === null ? \"transparent\" : _util1.Util.makeHexColor(color1[0], color1[1], color1[2]);\n                    }\n                    _setTextStyle(element1) {\n                        const TEXT_ALIGNMENT1 = [\n                            \"left\",\n                            \"center\",\n                            \"right\"\n                        ];\n                        const { fontColor: fontColor1 } = this.data.defaultAppearanceData;\n                        const fontSize1 = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE1;\n                        const style1 = element1.style;\n                        let computedFontSize1;\n                        const BORDER_SIZE1 = 2;\n                        const roundToOneDecimal1 = (x4)=>Math.round(10 * x4) / 10;\n                        if (this.data.multiLine) {\n                            const height1 = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE1);\n                            const numberOfLines1 = Math.round(height1 / (_util1.LINE_FACTOR * fontSize1)) || 1;\n                            const lineHeight1 = height1 / numberOfLines1;\n                            computedFontSize1 = Math.min(fontSize1, roundToOneDecimal1(lineHeight1 / _util1.LINE_FACTOR));\n                        } else {\n                            const height1 = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE1);\n                            computedFontSize1 = Math.min(fontSize1, roundToOneDecimal1(height1 / _util1.LINE_FACTOR));\n                        }\n                        style1.fontSize = `calc(${computedFontSize1}px * var(--scale-factor))`;\n                        style1.color = _util1.Util.makeHexColor(fontColor1[0], fontColor1[1], fontColor1[2]);\n                        if (this.data.textAlignment !== null) {\n                            style1.textAlign = TEXT_ALIGNMENT1[this.data.textAlignment];\n                        }\n                    }\n                    _setRequired(element1, isRequired1) {\n                        if (isRequired1) {\n                            element1.setAttribute(\"required\", true);\n                        } else {\n                            element1.removeAttribute(\"required\");\n                        }\n                        element1.setAttribute(\"aria-required\", isRequired1);\n                    }\n                }\n                class TextWidgetAnnotationElement1 extends WidgetAnnotationElement1 {\n                    constructor(parameters1){\n                        const isRenderable1 = parameters1.renderForms || !parameters1.data.hasAppearance && !!parameters1.data.fieldValue;\n                        super(parameters1, {\n                            isRenderable: isRenderable1\n                        });\n                    }\n                    setPropertyOnSiblings(base1, key1, value1, keyInStorage1) {\n                        const storage1 = this.annotationStorage;\n                        for (const element1 of this._getElementsByName(base1.name, base1.id)){\n                            if (element1.domElement) {\n                                element1.domElement[key1] = value1;\n                            }\n                            storage1.setValue(element1.id, {\n                                [keyInStorage1]: value1\n                            });\n                        }\n                    }\n                    render() {\n                        const storage1 = this.annotationStorage;\n                        const id1 = this.data.id;\n                        this.container.classList.add(\"textWidgetAnnotation\");\n                        let element1 = null;\n                        if (this.renderForms) {\n                            const storedData1 = storage1.getValue(id1, {\n                                value: this.data.fieldValue\n                            });\n                            let textContent1 = storedData1.value || \"\";\n                            const maxLen1 = storage1.getValue(id1, {\n                                charLimit: this.data.maxLen\n                            }).charLimit;\n                            if (maxLen1 && textContent1.length > maxLen1) {\n                                textContent1 = textContent1.slice(0, maxLen1);\n                            }\n                            let fieldFormattedValues1 = storedData1.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n                            if (fieldFormattedValues1 && this.data.comb) {\n                                fieldFormattedValues1 = fieldFormattedValues1.replaceAll(/\\s+/g, \"\");\n                            }\n                            const elementData1 = {\n                                userValue: textContent1,\n                                formattedValue: fieldFormattedValues1,\n                                lastCommittedValue: null,\n                                commitKey: 1,\n                                focused: false\n                            };\n                            if (this.data.multiLine) {\n                                element1 = document.createElement(\"textarea\");\n                                element1.textContent = fieldFormattedValues1 ?? textContent1;\n                                if (this.data.doNotScroll) {\n                                    element1.style.overflowY = \"hidden\";\n                                }\n                            } else {\n                                element1 = document.createElement(\"input\");\n                                element1.type = \"text\";\n                                element1.setAttribute(\"value\", fieldFormattedValues1 ?? textContent1);\n                                if (this.data.doNotScroll) {\n                                    element1.style.overflowX = \"hidden\";\n                                }\n                            }\n                            if (this.data.hasOwnCanvas) {\n                                element1.hidden = true;\n                            }\n                            GetElementsByNameSet1.add(element1);\n                            element1.setAttribute(\"data-element-id\", id1);\n                            element1.disabled = this.data.readOnly;\n                            element1.name = this.data.fieldName;\n                            element1.tabIndex = DEFAULT_TAB_INDEX1;\n                            this._setRequired(element1, this.data.required);\n                            if (maxLen1) {\n                                element1.maxLength = maxLen1;\n                            }\n                            element1.addEventListener(\"input\", (event1)=>{\n                                storage1.setValue(id1, {\n                                    value: event1.target.value\n                                });\n                                this.setPropertyOnSiblings(element1, \"value\", event1.target.value, \"value\");\n                                elementData1.formattedValue = null;\n                            });\n                            element1.addEventListener(\"resetform\", (event1)=>{\n                                const defaultValue1 = this.data.defaultFieldValue ?? \"\";\n                                element1.value = elementData1.userValue = defaultValue1;\n                                elementData1.formattedValue = null;\n                            });\n                            let blurListener1 = (event1)=>{\n                                const { formattedValue: formattedValue1 } = elementData1;\n                                if (formattedValue1 !== null && formattedValue1 !== undefined) {\n                                    event1.target.value = formattedValue1;\n                                }\n                                event1.target.scrollLeft = 0;\n                            };\n                            if (this.enableScripting && this.hasJSActions) {\n                                element1.addEventListener(\"focus\", (event1)=>{\n                                    if (elementData1.focused) {\n                                        return;\n                                    }\n                                    const { target: target1 } = event1;\n                                    if (elementData1.userValue) {\n                                        target1.value = elementData1.userValue;\n                                    }\n                                    elementData1.lastCommittedValue = target1.value;\n                                    elementData1.commitKey = 1;\n                                    elementData1.focused = true;\n                                });\n                                element1.addEventListener(\"updatefromsandbox\", (jsEvent1)=>{\n                                    this.showElementAndHideCanvas(jsEvent1.target);\n                                    const actions1 = {\n                                        value (event1) {\n                                            elementData1.userValue = event1.detail.value ?? \"\";\n                                            storage1.setValue(id1, {\n                                                value: elementData1.userValue.toString()\n                                            });\n                                            event1.target.value = elementData1.userValue;\n                                        },\n                                        formattedValue (event1) {\n                                            const { formattedValue: formattedValue1 } = event1.detail;\n                                            elementData1.formattedValue = formattedValue1;\n                                            if (formattedValue1 !== null && formattedValue1 !== undefined && event1.target !== document.activeElement) {\n                                                event1.target.value = formattedValue1;\n                                            }\n                                            storage1.setValue(id1, {\n                                                formattedValue: formattedValue1\n                                            });\n                                        },\n                                        selRange (event1) {\n                                            event1.target.setSelectionRange(...event1.detail.selRange);\n                                        },\n                                        charLimit: (event1)=>{\n                                            const { charLimit: charLimit1 } = event1.detail;\n                                            const { target: target1 } = event1;\n                                            if (charLimit1 === 0) {\n                                                target1.removeAttribute(\"maxLength\");\n                                                return;\n                                            }\n                                            target1.setAttribute(\"maxLength\", charLimit1);\n                                            let value1 = elementData1.userValue;\n                                            if (!value1 || value1.length <= charLimit1) {\n                                                return;\n                                            }\n                                            value1 = value1.slice(0, charLimit1);\n                                            target1.value = elementData1.userValue = value1;\n                                            storage1.setValue(id1, {\n                                                value: value1\n                                            });\n                                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                                source: this,\n                                                detail: {\n                                                    id: id1,\n                                                    name: \"Keystroke\",\n                                                    value: value1,\n                                                    willCommit: true,\n                                                    commitKey: 1,\n                                                    selStart: target1.selectionStart,\n                                                    selEnd: target1.selectionEnd\n                                                }\n                                            });\n                                        }\n                                    };\n                                    this._dispatchEventFromSandbox(actions1, jsEvent1);\n                                });\n                                element1.addEventListener(\"keydown\", (event1)=>{\n                                    elementData1.commitKey = 1;\n                                    let commitKey1 = -1;\n                                    if (event1.key === \"Escape\") {\n                                        commitKey1 = 0;\n                                    } else if (event1.key === \"Enter\" && !this.data.multiLine) {\n                                        commitKey1 = 2;\n                                    } else if (event1.key === \"Tab\") {\n                                        elementData1.commitKey = 3;\n                                    }\n                                    if (commitKey1 === -1) {\n                                        return;\n                                    }\n                                    const { value: value1 } = event1.target;\n                                    if (elementData1.lastCommittedValue === value1) {\n                                        return;\n                                    }\n                                    elementData1.lastCommittedValue = value1;\n                                    elementData1.userValue = value1;\n                                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                        source: this,\n                                        detail: {\n                                            id: id1,\n                                            name: \"Keystroke\",\n                                            value: value1,\n                                            willCommit: true,\n                                            commitKey: commitKey1,\n                                            selStart: event1.target.selectionStart,\n                                            selEnd: event1.target.selectionEnd\n                                        }\n                                    });\n                                });\n                                const _blurListener1 = blurListener1;\n                                blurListener1 = null;\n                                element1.addEventListener(\"blur\", (event1)=>{\n                                    if (!elementData1.focused || !event1.relatedTarget) {\n                                        return;\n                                    }\n                                    elementData1.focused = false;\n                                    const { value: value1 } = event1.target;\n                                    elementData1.userValue = value1;\n                                    if (elementData1.lastCommittedValue !== value1) {\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id: id1,\n                                                name: \"Keystroke\",\n                                                value: value1,\n                                                willCommit: true,\n                                                commitKey: elementData1.commitKey,\n                                                selStart: event1.target.selectionStart,\n                                                selEnd: event1.target.selectionEnd\n                                            }\n                                        });\n                                    }\n                                    _blurListener1(event1);\n                                });\n                                if (this.data.actions?.Keystroke) {\n                                    element1.addEventListener(\"beforeinput\", (event1)=>{\n                                        elementData1.lastCommittedValue = null;\n                                        const { data: data1, target: target1 } = event1;\n                                        const { value: value1, selectionStart: selectionStart1, selectionEnd: selectionEnd1 } = target1;\n                                        let selStart1 = selectionStart1, selEnd1 = selectionEnd1;\n                                        switch(event1.inputType){\n                                            case \"deleteWordBackward\":\n                                                {\n                                                    const match1 = value1.substring(0, selectionStart1).match(/\\w*[^\\w]*$/);\n                                                    if (match1) {\n                                                        selStart1 -= match1[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteWordForward\":\n                                                {\n                                                    const match1 = value1.substring(selectionStart1).match(/^[^\\w]*\\w*/);\n                                                    if (match1) {\n                                                        selEnd1 += match1[0].length;\n                                                    }\n                                                    break;\n                                                }\n                                            case \"deleteContentBackward\":\n                                                if (selectionStart1 === selectionEnd1) {\n                                                    selStart1 -= 1;\n                                                }\n                                                break;\n                                            case \"deleteContentForward\":\n                                                if (selectionStart1 === selectionEnd1) {\n                                                    selEnd1 += 1;\n                                                }\n                                                break;\n                                        }\n                                        event1.preventDefault();\n                                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                            source: this,\n                                            detail: {\n                                                id: id1,\n                                                name: \"Keystroke\",\n                                                value: value1,\n                                                change: data1 || \"\",\n                                                willCommit: false,\n                                                selStart: selStart1,\n                                                selEnd: selEnd1\n                                            }\n                                        });\n                                    });\n                                }\n                                this._setEventListeners(element1, elementData1, [\n                                    [\n                                        \"focus\",\n                                        \"Focus\"\n                                    ],\n                                    [\n                                        \"blur\",\n                                        \"Blur\"\n                                    ],\n                                    [\n                                        \"mousedown\",\n                                        \"Mouse Down\"\n                                    ],\n                                    [\n                                        \"mouseenter\",\n                                        \"Mouse Enter\"\n                                    ],\n                                    [\n                                        \"mouseleave\",\n                                        \"Mouse Exit\"\n                                    ],\n                                    [\n                                        \"mouseup\",\n                                        \"Mouse Up\"\n                                    ]\n                                ], (event1)=>event1.target.value);\n                            }\n                            if (blurListener1) {\n                                element1.addEventListener(\"blur\", blurListener1);\n                            }\n                            if (this.data.comb) {\n                                const fieldWidth1 = this.data.rect[2] - this.data.rect[0];\n                                const combWidth1 = fieldWidth1 / maxLen1;\n                                element1.classList.add(\"comb\");\n                                element1.style.letterSpacing = `calc(${combWidth1}px * var(--scale-factor) - 1ch)`;\n                            }\n                        } else {\n                            element1 = document.createElement(\"div\");\n                            element1.textContent = this.data.fieldValue;\n                            element1.style.verticalAlign = \"middle\";\n                            element1.style.display = \"table-cell\";\n                        }\n                        this._setTextStyle(element1);\n                        this._setBackgroundColor(element1);\n                        this._setDefaultPropertiesFromJS(element1);\n                        this.container.append(element1);\n                        return this.container;\n                    }\n                }\n                class SignatureWidgetAnnotationElement1 extends WidgetAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: !!parameters1.data.hasOwnCanvas\n                        });\n                    }\n                }\n                class CheckboxWidgetAnnotationElement1 extends WidgetAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: parameters1.renderForms\n                        });\n                    }\n                    render() {\n                        const storage1 = this.annotationStorage;\n                        const data1 = this.data;\n                        const id1 = data1.id;\n                        let value1 = storage1.getValue(id1, {\n                            value: data1.exportValue === data1.fieldValue\n                        }).value;\n                        if (typeof value1 === \"string\") {\n                            value1 = value1 !== \"Off\";\n                            storage1.setValue(id1, {\n                                value: value1\n                            });\n                        }\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n                        const element1 = document.createElement(\"input\");\n                        GetElementsByNameSet1.add(element1);\n                        element1.setAttribute(\"data-element-id\", id1);\n                        element1.disabled = data1.readOnly;\n                        this._setRequired(element1, this.data.required);\n                        element1.type = \"checkbox\";\n                        element1.name = data1.fieldName;\n                        if (value1) {\n                            element1.setAttribute(\"checked\", true);\n                        }\n                        element1.setAttribute(\"exportValue\", data1.exportValue);\n                        element1.tabIndex = DEFAULT_TAB_INDEX1;\n                        element1.addEventListener(\"change\", (event1)=>{\n                            const { name: name1, checked: checked1 } = event1.target;\n                            for (const checkbox1 of this._getElementsByName(name1, id1)){\n                                const curChecked1 = checked1 && checkbox1.exportValue === data1.exportValue;\n                                if (checkbox1.domElement) {\n                                    checkbox1.domElement.checked = curChecked1;\n                                }\n                                storage1.setValue(checkbox1.id, {\n                                    value: curChecked1\n                                });\n                            }\n                            storage1.setValue(id1, {\n                                value: checked1\n                            });\n                        });\n                        element1.addEventListener(\"resetform\", (event1)=>{\n                            const defaultValue1 = data1.defaultFieldValue || \"Off\";\n                            event1.target.checked = defaultValue1 === data1.exportValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            element1.addEventListener(\"updatefromsandbox\", (jsEvent1)=>{\n                                const actions1 = {\n                                    value (event1) {\n                                        event1.target.checked = event1.detail.value !== \"Off\";\n                                        storage1.setValue(id1, {\n                                            value: event1.target.checked\n                                        });\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions1, jsEvent1);\n                            });\n                            this._setEventListeners(element1, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event1)=>event1.target.checked);\n                        }\n                        this._setBackgroundColor(element1);\n                        this._setDefaultPropertiesFromJS(element1);\n                        this.container.append(element1);\n                        return this.container;\n                    }\n                }\n                class RadioButtonWidgetAnnotationElement1 extends WidgetAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: parameters1.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n                        const storage1 = this.annotationStorage;\n                        const data1 = this.data;\n                        const id1 = data1.id;\n                        let value1 = storage1.getValue(id1, {\n                            value: data1.fieldValue === data1.buttonValue\n                        }).value;\n                        if (typeof value1 === \"string\") {\n                            value1 = value1 !== data1.buttonValue;\n                            storage1.setValue(id1, {\n                                value: value1\n                            });\n                        }\n                        const element1 = document.createElement(\"input\");\n                        GetElementsByNameSet1.add(element1);\n                        element1.setAttribute(\"data-element-id\", id1);\n                        element1.disabled = data1.readOnly;\n                        this._setRequired(element1, this.data.required);\n                        element1.type = \"radio\";\n                        element1.name = data1.fieldName;\n                        if (value1) {\n                            element1.setAttribute(\"checked\", true);\n                        }\n                        element1.tabIndex = DEFAULT_TAB_INDEX1;\n                        element1.addEventListener(\"change\", (event1)=>{\n                            const { name: name1, checked: checked1 } = event1.target;\n                            for (const radio1 of this._getElementsByName(name1, id1)){\n                                storage1.setValue(radio1.id, {\n                                    value: false\n                                });\n                            }\n                            storage1.setValue(id1, {\n                                value: checked1\n                            });\n                        });\n                        element1.addEventListener(\"resetform\", (event1)=>{\n                            const defaultValue1 = data1.defaultFieldValue;\n                            event1.target.checked = defaultValue1 !== null && defaultValue1 !== undefined && defaultValue1 === data1.buttonValue;\n                        });\n                        if (this.enableScripting && this.hasJSActions) {\n                            const pdfButtonValue1 = data1.buttonValue;\n                            element1.addEventListener(\"updatefromsandbox\", (jsEvent1)=>{\n                                const actions1 = {\n                                    value: (event1)=>{\n                                        const checked1 = pdfButtonValue1 === event1.detail.value;\n                                        for (const radio1 of this._getElementsByName(event1.target.name)){\n                                            const curChecked1 = checked1 && radio1.id === id1;\n                                            if (radio1.domElement) {\n                                                radio1.domElement.checked = curChecked1;\n                                            }\n                                            storage1.setValue(radio1.id, {\n                                                value: curChecked1\n                                            });\n                                        }\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions1, jsEvent1);\n                            });\n                            this._setEventListeners(element1, null, [\n                                [\n                                    \"change\",\n                                    \"Validate\"\n                                ],\n                                [\n                                    \"change\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ]\n                            ], (event1)=>event1.target.checked);\n                        }\n                        this._setBackgroundColor(element1);\n                        this._setDefaultPropertiesFromJS(element1);\n                        this.container.append(element1);\n                        return this.container;\n                    }\n                }\n                class PushButtonWidgetAnnotationElement1 extends LinkAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            ignoreBorder: parameters1.data.hasAppearance\n                        });\n                    }\n                    render() {\n                        const container1 = super.render();\n                        container1.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n                        if (this.data.alternativeText) {\n                            container1.title = this.data.alternativeText;\n                        }\n                        const linkElement1 = container1.lastChild;\n                        if (this.enableScripting && this.hasJSActions && linkElement1) {\n                            this._setDefaultPropertiesFromJS(linkElement1);\n                            linkElement1.addEventListener(\"updatefromsandbox\", (jsEvent1)=>{\n                                this._dispatchEventFromSandbox({}, jsEvent1);\n                            });\n                        }\n                        return container1;\n                    }\n                }\n                class ChoiceWidgetAnnotationElement1 extends WidgetAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: parameters1.renderForms\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"choiceWidgetAnnotation\");\n                        const storage1 = this.annotationStorage;\n                        const id1 = this.data.id;\n                        const storedData1 = storage1.getValue(id1, {\n                            value: this.data.fieldValue\n                        });\n                        const selectElement1 = document.createElement(\"select\");\n                        GetElementsByNameSet1.add(selectElement1);\n                        selectElement1.setAttribute(\"data-element-id\", id1);\n                        selectElement1.disabled = this.data.readOnly;\n                        this._setRequired(selectElement1, this.data.required);\n                        selectElement1.name = this.data.fieldName;\n                        selectElement1.tabIndex = DEFAULT_TAB_INDEX1;\n                        let addAnEmptyEntry1 = this.data.combo && this.data.options.length > 0;\n                        if (!this.data.combo) {\n                            selectElement1.size = this.data.options.length;\n                            if (this.data.multiSelect) {\n                                selectElement1.multiple = true;\n                            }\n                        }\n                        selectElement1.addEventListener(\"resetform\", (event1)=>{\n                            const defaultValue1 = this.data.defaultFieldValue;\n                            for (const option1 of selectElement1.options){\n                                option1.selected = option1.value === defaultValue1;\n                            }\n                        });\n                        for (const option1 of this.data.options){\n                            const optionElement1 = document.createElement(\"option\");\n                            optionElement1.textContent = option1.displayValue;\n                            optionElement1.value = option1.exportValue;\n                            if (storedData1.value.includes(option1.exportValue)) {\n                                optionElement1.setAttribute(\"selected\", true);\n                                addAnEmptyEntry1 = false;\n                            }\n                            selectElement1.append(optionElement1);\n                        }\n                        let removeEmptyEntry1 = null;\n                        if (addAnEmptyEntry1) {\n                            const noneOptionElement1 = document.createElement(\"option\");\n                            noneOptionElement1.value = \" \";\n                            noneOptionElement1.setAttribute(\"hidden\", true);\n                            noneOptionElement1.setAttribute(\"selected\", true);\n                            selectElement1.prepend(noneOptionElement1);\n                            removeEmptyEntry1 = ()=>{\n                                noneOptionElement1.remove();\n                                selectElement1.removeEventListener(\"input\", removeEmptyEntry1);\n                                removeEmptyEntry1 = null;\n                            };\n                            selectElement1.addEventListener(\"input\", removeEmptyEntry1);\n                        }\n                        const getValue1 = (isExport1)=>{\n                            const name1 = isExport1 ? \"value\" : \"textContent\";\n                            const { options: options1, multiple: multiple1 } = selectElement1;\n                            if (!multiple1) {\n                                return options1.selectedIndex === -1 ? null : options1[options1.selectedIndex][name1];\n                            }\n                            return Array.prototype.filter.call(options1, (option1)=>option1.selected).map((option1)=>option1[name1]);\n                        };\n                        let selectedValues1 = getValue1(false);\n                        const getItems1 = (event1)=>{\n                            const options1 = event1.target.options;\n                            return Array.prototype.map.call(options1, (option1)=>{\n                                return {\n                                    displayValue: option1.textContent,\n                                    exportValue: option1.value\n                                };\n                            });\n                        };\n                        if (this.enableScripting && this.hasJSActions) {\n                            selectElement1.addEventListener(\"updatefromsandbox\", (jsEvent1)=>{\n                                const actions1 = {\n                                    value (event1) {\n                                        removeEmptyEntry1?.();\n                                        const value1 = event1.detail.value;\n                                        const values1 = new Set(Array.isArray(value1) ? value1 : [\n                                            value1\n                                        ]);\n                                        for (const option1 of selectElement1.options){\n                                            option1.selected = values1.has(option1.value);\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: getValue1(true)\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    multipleSelection (event1) {\n                                        selectElement1.multiple = true;\n                                    },\n                                    remove (event1) {\n                                        const options1 = selectElement1.options;\n                                        const index1 = event1.detail.remove;\n                                        options1[index1].selected = false;\n                                        selectElement1.remove(index1);\n                                        if (options1.length > 0) {\n                                            const i1 = Array.prototype.findIndex.call(options1, (option1)=>option1.selected);\n                                            if (i1 === -1) {\n                                                options1[0].selected = true;\n                                            }\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: getValue1(true),\n                                            items: getItems1(event1)\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    clear (event1) {\n                                        while(selectElement1.length !== 0){\n                                            selectElement1.remove(0);\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: null,\n                                            items: []\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    insert (event1) {\n                                        const { index: index1, displayValue: displayValue1, exportValue: exportValue1 } = event1.detail.insert;\n                                        const selectChild1 = selectElement1.children[index1];\n                                        const optionElement1 = document.createElement(\"option\");\n                                        optionElement1.textContent = displayValue1;\n                                        optionElement1.value = exportValue1;\n                                        if (selectChild1) {\n                                            selectChild1.before(optionElement1);\n                                        } else {\n                                            selectElement1.append(optionElement1);\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: getValue1(true),\n                                            items: getItems1(event1)\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    items (event1) {\n                                        const { items: items1 } = event1.detail;\n                                        while(selectElement1.length !== 0){\n                                            selectElement1.remove(0);\n                                        }\n                                        for (const item1 of items1){\n                                            const { displayValue: displayValue1, exportValue: exportValue1 } = item1;\n                                            const optionElement1 = document.createElement(\"option\");\n                                            optionElement1.textContent = displayValue1;\n                                            optionElement1.value = exportValue1;\n                                            selectElement1.append(optionElement1);\n                                        }\n                                        if (selectElement1.options.length > 0) {\n                                            selectElement1.options[0].selected = true;\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: getValue1(true),\n                                            items: getItems1(event1)\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    indices (event1) {\n                                        const indices1 = new Set(event1.detail.indices);\n                                        for (const option1 of event1.target.options){\n                                            option1.selected = indices1.has(option1.index);\n                                        }\n                                        storage1.setValue(id1, {\n                                            value: getValue1(true)\n                                        });\n                                        selectedValues1 = getValue1(false);\n                                    },\n                                    editable (event1) {\n                                        event1.target.disabled = !event1.detail.editable;\n                                    }\n                                };\n                                this._dispatchEventFromSandbox(actions1, jsEvent1);\n                            });\n                            selectElement1.addEventListener(\"input\", (event1)=>{\n                                const exportValue1 = getValue1(true);\n                                storage1.setValue(id1, {\n                                    value: exportValue1\n                                });\n                                event1.preventDefault();\n                                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                    source: this,\n                                    detail: {\n                                        id: id1,\n                                        name: \"Keystroke\",\n                                        value: selectedValues1,\n                                        changeEx: exportValue1,\n                                        willCommit: false,\n                                        commitKey: 1,\n                                        keyDown: false\n                                    }\n                                });\n                            });\n                            this._setEventListeners(selectElement1, null, [\n                                [\n                                    \"focus\",\n                                    \"Focus\"\n                                ],\n                                [\n                                    \"blur\",\n                                    \"Blur\"\n                                ],\n                                [\n                                    \"mousedown\",\n                                    \"Mouse Down\"\n                                ],\n                                [\n                                    \"mouseenter\",\n                                    \"Mouse Enter\"\n                                ],\n                                [\n                                    \"mouseleave\",\n                                    \"Mouse Exit\"\n                                ],\n                                [\n                                    \"mouseup\",\n                                    \"Mouse Up\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Action\"\n                                ],\n                                [\n                                    \"input\",\n                                    \"Validate\"\n                                ]\n                            ], (event1)=>event1.target.value);\n                        } else {\n                            selectElement1.addEventListener(\"input\", function(event1) {\n                                storage1.setValue(id1, {\n                                    value: getValue1(true)\n                                });\n                            });\n                        }\n                        if (this.data.combo) {\n                            this._setTextStyle(selectElement1);\n                        } else {}\n                        this._setBackgroundColor(selectElement1);\n                        this._setDefaultPropertiesFromJS(selectElement1);\n                        this.container.append(selectElement1);\n                        return this.container;\n                    }\n                }\n                class PopupAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        const { data: data1, elements: elements1 } = parameters1;\n                        super(parameters1, {\n                            isRenderable: AnnotationElement1._hasPopupData(data1)\n                        });\n                        this.elements = elements1;\n                    }\n                    render() {\n                        this.container.classList.add(\"popupAnnotation\");\n                        const popup1 = new PopupElement1({\n                            container: this.container,\n                            color: this.data.color,\n                            titleObj: this.data.titleObj,\n                            modificationDate: this.data.modificationDate,\n                            contentsObj: this.data.contentsObj,\n                            richText: this.data.richText,\n                            rect: this.data.rect,\n                            parentRect: this.data.parentRect || null,\n                            parent: this.parent,\n                            elements: this.elements,\n                            open: this.data.open\n                        });\n                        const elementIds1 = [];\n                        for (const element1 of this.elements){\n                            element1.popup = popup1;\n                            elementIds1.push(element1.data.id);\n                            element1.addHighlightArea();\n                        }\n                        this.container.setAttribute(\"aria-controls\", elementIds1.map((id1)=>`${_util1.AnnotationPrefix}${id1}`).join(\",\"));\n                        return this.container;\n                    }\n                }\n                class PopupElement1 {\n                    #dateTimePromise;\n                    #boundKeyDown;\n                    #boundHide;\n                    #boundShow;\n                    #boundToggle;\n                    #color;\n                    #container;\n                    #contentsObj;\n                    #elements;\n                    #parent;\n                    #parentRect;\n                    #pinned;\n                    #popup;\n                    #rect;\n                    #richText;\n                    #titleObj;\n                    #wasVisible;\n                    constructor({ container: container1, color: color1, elements: elements1, titleObj: titleObj1, modificationDate: modificationDate1, contentsObj: contentsObj1, richText: richText1, parent: parent1, rect: rect3, parentRect: parentRect1, open: open1 }){\n                        this.#dateTimePromise = null;\n                        this.#boundKeyDown = this.#keyDown.bind(this);\n                        this.#boundHide = this.#hide.bind(this);\n                        this.#boundShow = this.#show.bind(this);\n                        this.#boundToggle = this.#toggle.bind(this);\n                        this.#color = null;\n                        this.#container = null;\n                        this.#contentsObj = null;\n                        this.#elements = null;\n                        this.#parent = null;\n                        this.#parentRect = null;\n                        this.#pinned = false;\n                        this.#popup = null;\n                        this.#rect = null;\n                        this.#richText = null;\n                        this.#titleObj = null;\n                        this.#wasVisible = false;\n                        this.#container = container1;\n                        this.#titleObj = titleObj1;\n                        this.#contentsObj = contentsObj1;\n                        this.#richText = richText1;\n                        this.#parent = parent1;\n                        this.#color = color1;\n                        this.#rect = rect3;\n                        this.#parentRect = parentRect1;\n                        this.#elements = elements1;\n                        const dateObject1 = _display_utils1.PDFDateString.toDateObject(modificationDate1);\n                        if (dateObject1) {\n                            this.#dateTimePromise = parent1.l10n.get(\"annotation_date_string\", {\n                                date: dateObject1.toLocaleDateString(),\n                                time: dateObject1.toLocaleTimeString()\n                            });\n                        }\n                        this.trigger = elements1.flatMap((e1)=>e1.getElementsToTriggerPopup());\n                        for (const element1 of this.trigger){\n                            element1.addEventListener(\"click\", this.#boundToggle);\n                            element1.addEventListener(\"mouseenter\", this.#boundShow);\n                            element1.addEventListener(\"mouseleave\", this.#boundHide);\n                            element1.classList.add(\"popupTriggerArea\");\n                        }\n                        for (const element1 of elements1){\n                            element1.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                        this.#container.hidden = true;\n                        if (open1) {\n                            this.#toggle();\n                        }\n                    }\n                    render() {\n                        if (this.#popup) {\n                            return;\n                        }\n                        const { page: { view: view1 }, viewport: { rawDims: { pageWidth: pageWidth1, pageHeight: pageHeight1, pageX: pageX1, pageY: pageY1 } } } = this.#parent;\n                        const popup1 = this.#popup = document.createElement(\"div\");\n                        popup1.className = \"popup\";\n                        if (this.#color) {\n                            const baseColor1 = popup1.style.outlineColor = _util1.Util.makeHexColor(...this.#color);\n                            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                                popup1.style.backgroundColor = `color-mix(in srgb, ${baseColor1} 30%, white)`;\n                            } else {\n                                const BACKGROUND_ENLIGHT1 = 0.7;\n                                popup1.style.backgroundColor = _util1.Util.makeHexColor(...this.#color.map((c4)=>Math.floor(BACKGROUND_ENLIGHT1 * (255 - c4) + c4)));\n                            }\n                        }\n                        const header1 = document.createElement(\"span\");\n                        header1.className = \"header\";\n                        const title1 = document.createElement(\"h1\");\n                        header1.append(title1);\n                        ({ dir: title1.dir, str: title1.textContent } = this.#titleObj);\n                        popup1.append(header1);\n                        if (this.#dateTimePromise) {\n                            const modificationDate1 = document.createElement(\"span\");\n                            modificationDate1.classList.add(\"popupDate\");\n                            this.#dateTimePromise.then((localized1)=>{\n                                modificationDate1.textContent = localized1;\n                            });\n                            header1.append(modificationDate1);\n                        }\n                        const contentsObj1 = this.#contentsObj;\n                        const richText1 = this.#richText;\n                        if (richText1?.str && (!contentsObj1?.str || contentsObj1.str === richText1.str)) {\n                            _xfa_layer1.XfaLayer.render({\n                                xfaHtml: richText1.html,\n                                intent: \"richText\",\n                                div: popup1\n                            });\n                            popup1.lastChild.classList.add(\"richText\", \"popupContent\");\n                        } else {\n                            const contents1 = this._formatContents(contentsObj1);\n                            popup1.append(contents1);\n                        }\n                        let useParentRect1 = !!this.#parentRect;\n                        let rect3 = useParentRect1 ? this.#parentRect : this.#rect;\n                        for (const element1 of this.#elements){\n                            if (!rect3 || _util1.Util.intersect(element1.data.rect, rect3) !== null) {\n                                rect3 = element1.data.rect;\n                                useParentRect1 = true;\n                                break;\n                            }\n                        }\n                        const normalizedRect1 = _util1.Util.normalizeRect([\n                            rect3[0],\n                            view1[3] - rect3[1] + view1[1],\n                            rect3[2],\n                            view1[3] - rect3[3] + view1[1]\n                        ]);\n                        const HORIZONTAL_SPACE_AFTER_ANNOTATION1 = 5;\n                        const parentWidth1 = useParentRect1 ? rect3[2] - rect3[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION1 : 0;\n                        const popupLeft1 = normalizedRect1[0] + parentWidth1;\n                        const popupTop1 = normalizedRect1[1];\n                        const { style: style1 } = this.#container;\n                        style1.left = `${100 * (popupLeft1 - pageX1) / pageWidth1}%`;\n                        style1.top = `${100 * (popupTop1 - pageY1) / pageHeight1}%`;\n                        this.#container.append(popup1);\n                    }\n                    _formatContents({ str: str1, dir: dir1 }) {\n                        const p5 = document.createElement(\"p\");\n                        p5.classList.add(\"popupContent\");\n                        p5.dir = dir1;\n                        const lines1 = str1.split(/(?:\\r\\n?|\\n)/);\n                        for(let i1 = 0, ii1 = lines1.length; i1 < ii1; ++i1){\n                            const line1 = lines1[i1];\n                            p5.append(document.createTextNode(line1));\n                            if (i1 < ii1 - 1) {\n                                p5.append(document.createElement(\"br\"));\n                            }\n                        }\n                        return p5;\n                    }\n                    #keyDown(event1) {\n                        if (event1.altKey || event1.shiftKey || event1.ctrlKey || event1.metaKey) {\n                            return;\n                        }\n                        if (event1.key === \"Enter\" || event1.key === \"Escape\" && this.#pinned) {\n                            this.#toggle();\n                        }\n                    }\n                    #toggle() {\n                        this.#pinned = !this.#pinned;\n                        if (this.#pinned) {\n                            this.#show();\n                            this.#container.addEventListener(\"click\", this.#boundToggle);\n                            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n                        } else {\n                            this.#hide();\n                            this.#container.removeEventListener(\"click\", this.#boundToggle);\n                            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n                        }\n                    }\n                    #show() {\n                        if (!this.#popup) {\n                            this.render();\n                        }\n                        if (!this.isVisible) {\n                            this.#container.hidden = false;\n                            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n                        } else if (this.#pinned) {\n                            this.#container.classList.add(\"focused\");\n                        }\n                    }\n                    #hide() {\n                        this.#container.classList.remove(\"focused\");\n                        if (this.#pinned || !this.isVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n                    }\n                    forceHide() {\n                        this.#wasVisible = this.isVisible;\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#container.hidden = true;\n                    }\n                    maybeShow() {\n                        if (!this.#wasVisible) {\n                            return;\n                        }\n                        this.#wasVisible = false;\n                        this.#container.hidden = false;\n                    }\n                    get isVisible() {\n                        return this.#container.hidden === false;\n                    }\n                }\n                class FreeTextAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.textContent = parameters1.data.textContent;\n                        this.textPosition = parameters1.data.textPosition;\n                        this.annotationEditorType = _util1.AnnotationEditorType.FREETEXT;\n                    }\n                    render() {\n                        this.container.classList.add(\"freeTextAnnotation\");\n                        if (this.textContent) {\n                            const content1 = document.createElement(\"div\");\n                            content1.classList.add(\"annotationTextContent\");\n                            content1.setAttribute(\"role\", \"comment\");\n                            for (const line1 of this.textContent){\n                                const lineSpan1 = document.createElement(\"span\");\n                                lineSpan1.textContent = line1;\n                                content1.append(lineSpan1);\n                            }\n                            this.container.append(content1);\n                        }\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this._editOnDoubleClick();\n                        return this.container;\n                    }\n                }\n                exports1.FreeTextAnnotationElement = FreeTextAnnotationElement1;\n                class LineAnnotationElement1 extends AnnotationElement1 {\n                    #line;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#line = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"lineAnnotation\");\n                        const data1 = this.data;\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const svg1 = this.svgFactory.create(width2, height1, true);\n                        const line1 = this.#line = this.svgFactory.createElement(\"svg:line\");\n                        line1.setAttribute(\"x1\", data1.rect[2] - data1.lineCoordinates[0]);\n                        line1.setAttribute(\"y1\", data1.rect[3] - data1.lineCoordinates[1]);\n                        line1.setAttribute(\"x2\", data1.rect[2] - data1.lineCoordinates[2]);\n                        line1.setAttribute(\"y2\", data1.rect[3] - data1.lineCoordinates[3]);\n                        line1.setAttribute(\"stroke-width\", data1.borderStyle.width || 1);\n                        line1.setAttribute(\"stroke\", \"transparent\");\n                        line1.setAttribute(\"fill\", \"transparent\");\n                        svg1.append(line1);\n                        this.container.append(svg1);\n                        if (!data1.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#line;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class SquareAnnotationElement1 extends AnnotationElement1 {\n                    #square;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#square = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"squareAnnotation\");\n                        const data1 = this.data;\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const svg1 = this.svgFactory.create(width2, height1, true);\n                        const borderWidth1 = data1.borderStyle.width;\n                        const square1 = this.#square = this.svgFactory.createElement(\"svg:rect\");\n                        square1.setAttribute(\"x\", borderWidth1 / 2);\n                        square1.setAttribute(\"y\", borderWidth1 / 2);\n                        square1.setAttribute(\"width\", width2 - borderWidth1);\n                        square1.setAttribute(\"height\", height1 - borderWidth1);\n                        square1.setAttribute(\"stroke-width\", borderWidth1 || 1);\n                        square1.setAttribute(\"stroke\", \"transparent\");\n                        square1.setAttribute(\"fill\", \"transparent\");\n                        svg1.append(square1);\n                        this.container.append(svg1);\n                        if (!data1.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#square;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class CircleAnnotationElement1 extends AnnotationElement1 {\n                    #circle;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#circle = null;\n                    }\n                    render() {\n                        this.container.classList.add(\"circleAnnotation\");\n                        const data1 = this.data;\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const svg1 = this.svgFactory.create(width2, height1, true);\n                        const borderWidth1 = data1.borderStyle.width;\n                        const circle1 = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n                        circle1.setAttribute(\"cx\", width2 / 2);\n                        circle1.setAttribute(\"cy\", height1 / 2);\n                        circle1.setAttribute(\"rx\", width2 / 2 - borderWidth1 / 2);\n                        circle1.setAttribute(\"ry\", height1 / 2 - borderWidth1 / 2);\n                        circle1.setAttribute(\"stroke-width\", borderWidth1 || 1);\n                        circle1.setAttribute(\"stroke\", \"transparent\");\n                        circle1.setAttribute(\"fill\", \"transparent\");\n                        svg1.append(circle1);\n                        this.container.append(svg1);\n                        if (!data1.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#circle;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolylineAnnotationElement1 extends AnnotationElement1 {\n                    #polyline;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polyline = null;\n                        this.containerClassName = \"polylineAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data1 = this.data;\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const svg1 = this.svgFactory.create(width2, height1, true);\n                        let points1 = [];\n                        for (const coordinate1 of data1.vertices){\n                            const x4 = coordinate1.x - data1.rect[0];\n                            const y4 = data1.rect[3] - coordinate1.y;\n                            points1.push(x4 + \",\" + y4);\n                        }\n                        points1 = points1.join(\" \");\n                        const polyline1 = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n                        polyline1.setAttribute(\"points\", points1);\n                        polyline1.setAttribute(\"stroke-width\", data1.borderStyle.width || 1);\n                        polyline1.setAttribute(\"stroke\", \"transparent\");\n                        polyline1.setAttribute(\"fill\", \"transparent\");\n                        svg1.append(polyline1);\n                        this.container.append(svg1);\n                        if (!data1.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polyline;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                class PolygonAnnotationElement1 extends PolylineAnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1);\n                        this.containerClassName = \"polygonAnnotation\";\n                        this.svgElementName = \"svg:polygon\";\n                    }\n                }\n                class CaretAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"caretAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                class InkAnnotationElement1 extends AnnotationElement1 {\n                    #polylines;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                        this.#polylines = [];\n                        this.containerClassName = \"inkAnnotation\";\n                        this.svgElementName = \"svg:polyline\";\n                        this.annotationEditorType = _util1.AnnotationEditorType.INK;\n                    }\n                    render() {\n                        this.container.classList.add(this.containerClassName);\n                        const data1 = this.data;\n                        const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                        const svg1 = this.svgFactory.create(width2, height1, true);\n                        for (const inkList1 of data1.inkLists){\n                            let points1 = [];\n                            for (const coordinate1 of inkList1){\n                                const x4 = coordinate1.x - data1.rect[0];\n                                const y4 = data1.rect[3] - coordinate1.y;\n                                points1.push(`${x4},${y4}`);\n                            }\n                            points1 = points1.join(\" \");\n                            const polyline1 = this.svgFactory.createElement(this.svgElementName);\n                            this.#polylines.push(polyline1);\n                            polyline1.setAttribute(\"points\", points1);\n                            polyline1.setAttribute(\"stroke-width\", data1.borderStyle.width || 1);\n                            polyline1.setAttribute(\"stroke\", \"transparent\");\n                            polyline1.setAttribute(\"fill\", \"transparent\");\n                            if (!data1.popupRef && this.hasPopupData) {\n                                this._createPopup();\n                            }\n                            svg1.append(polyline1);\n                        }\n                        this.container.append(svg1);\n                        return this.container;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#polylines;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                }\n                exports1.InkAnnotationElement = InkAnnotationElement1;\n                class HighlightAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"highlightAnnotation\");\n                        return this.container;\n                    }\n                }\n                class UnderlineAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"underlineAnnotation\");\n                        return this.container;\n                    }\n                }\n                class SquigglyAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"squigglyAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StrikeOutAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true,\n                            createQuadrilaterals: true\n                        });\n                    }\n                    render() {\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        this.container.classList.add(\"strikeoutAnnotation\");\n                        return this.container;\n                    }\n                }\n                class StampAnnotationElement1 extends AnnotationElement1 {\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true,\n                            ignoreBorder: true\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"stampAnnotation\");\n                        if (!this.data.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        }\n                        return this.container;\n                    }\n                }\n                exports1.StampAnnotationElement = StampAnnotationElement1;\n                class FileAttachmentAnnotationElement1 extends AnnotationElement1 {\n                    #trigger;\n                    constructor(parameters1){\n                        super(parameters1, {\n                            isRenderable: true\n                        });\n                        this.#trigger = null;\n                        const { filename: filename1, content: content1 } = this.data.file;\n                        this.filename = (0, _display_utils1.getFilenameFromUrl)(filename1, true);\n                        this.content = content1;\n                        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n                            source: this,\n                            filename: filename1,\n                            content: content1\n                        });\n                    }\n                    render() {\n                        this.container.classList.add(\"fileAttachmentAnnotation\");\n                        const { container: container1, data: data1 } = this;\n                        let trigger1;\n                        if (data1.hasAppearance || data1.fillAlpha === 0) {\n                            trigger1 = document.createElement(\"div\");\n                        } else {\n                            trigger1 = document.createElement(\"img\");\n                            trigger1.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data1.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n                            if (data1.fillAlpha && data1.fillAlpha < 1) {\n                                trigger1.style = `filter: opacity(${Math.round(data1.fillAlpha * 100)}%);`;\n                            }\n                        }\n                        trigger1.addEventListener(\"dblclick\", this.#download.bind(this));\n                        this.#trigger = trigger1;\n                        const { isMac: isMac1 } = _util1.FeatureTest.platform;\n                        container1.addEventListener(\"keydown\", (evt1)=>{\n                            if (evt1.key === \"Enter\" && (isMac1 ? evt1.metaKey : evt1.ctrlKey)) {\n                                this.#download();\n                            }\n                        });\n                        if (!data1.popupRef && this.hasPopupData) {\n                            this._createPopup();\n                        } else {\n                            trigger1.classList.add(\"popupTriggerArea\");\n                        }\n                        container1.append(trigger1);\n                        return container1;\n                    }\n                    getElementsToTriggerPopup() {\n                        return this.#trigger;\n                    }\n                    addHighlightArea() {\n                        this.container.classList.add(\"highlightArea\");\n                    }\n                    #download() {\n                        this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n                    }\n                }\n                class AnnotationLayer1 {\n                    #accessibilityManager;\n                    #annotationCanvasMap;\n                    #editableAnnotations;\n                    constructor({ div: div1, accessibilityManager: accessibilityManager1, annotationCanvasMap: annotationCanvasMap1, l10n: l10n1, page: page1, viewport: viewport1 }){\n                        this.#accessibilityManager = null;\n                        this.#annotationCanvasMap = null;\n                        this.#editableAnnotations = new Map();\n                        this.div = div1;\n                        this.#accessibilityManager = accessibilityManager1;\n                        this.#annotationCanvasMap = annotationCanvasMap1;\n                        this.l10n = l10n1;\n                        this.page = page1;\n                        this.viewport = viewport1;\n                        this.zIndex = 0;\n                        this.l10n ||= _displayL10n_utils1.NullL10n;\n                    }\n                    #appendElement(element1, id1) {\n                        const contentElement1 = element1.firstChild || element1;\n                        contentElement1.id = `${_util1.AnnotationPrefix}${id1}`;\n                        this.div.append(element1);\n                        this.#accessibilityManager?.moveElementInDOM(this.div, element1, contentElement1, false);\n                    }\n                    async render(params1) {\n                        const { annotations: annotations1 } = params1;\n                        const layer1 = this.div;\n                        (0, _display_utils1.setLayerDimensions)(layer1, this.viewport);\n                        const popupToElements1 = new Map();\n                        const elementParams1 = {\n                            data: null,\n                            layer: layer1,\n                            linkService: params1.linkService,\n                            downloadManager: params1.downloadManager,\n                            imageResourcesPath: params1.imageResourcesPath || \"\",\n                            renderForms: params1.renderForms !== false,\n                            svgFactory: new _display_utils1.DOMSVGFactory(),\n                            annotationStorage: params1.annotationStorage || new _annotation_storage1.AnnotationStorage(),\n                            enableScripting: params1.enableScripting === true,\n                            hasJSActions: params1.hasJSActions,\n                            fieldObjects: params1.fieldObjects,\n                            parent: this,\n                            elements: null\n                        };\n                        for (const data1 of annotations1){\n                            if (data1.noHTML) {\n                                continue;\n                            }\n                            const isPopupAnnotation1 = data1.annotationType === _util1.AnnotationType.POPUP;\n                            if (!isPopupAnnotation1) {\n                                const { width: width2, height: height1 } = getRectDims1(data1.rect);\n                                if (width2 <= 0 || height1 <= 0) {\n                                    continue;\n                                }\n                            } else {\n                                const elements1 = popupToElements1.get(data1.id);\n                                if (!elements1) {\n                                    continue;\n                                }\n                                elementParams1.elements = elements1;\n                            }\n                            elementParams1.data = data1;\n                            const element1 = AnnotationElementFactory1.create(elementParams1);\n                            if (!element1.isRenderable) {\n                                continue;\n                            }\n                            if (!isPopupAnnotation1 && data1.popupRef) {\n                                const elements1 = popupToElements1.get(data1.popupRef);\n                                if (!elements1) {\n                                    popupToElements1.set(data1.popupRef, [\n                                        element1\n                                    ]);\n                                } else {\n                                    elements1.push(element1);\n                                }\n                            }\n                            if (element1.annotationEditorType > 0) {\n                                this.#editableAnnotations.set(element1.data.id, element1);\n                            }\n                            const rendered1 = element1.render();\n                            if (data1.hidden) {\n                                rendered1.style.visibility = \"hidden\";\n                            }\n                            this.#appendElement(rendered1, data1.id);\n                        }\n                        this.#setAnnotationCanvasMap();\n                        await this.l10n.translate(layer1);\n                    }\n                    update({ viewport: viewport1 }) {\n                        const layer1 = this.div;\n                        this.viewport = viewport1;\n                        (0, _display_utils1.setLayerDimensions)(layer1, {\n                            rotation: viewport1.rotation\n                        });\n                        this.#setAnnotationCanvasMap();\n                        layer1.hidden = false;\n                    }\n                    #setAnnotationCanvasMap() {\n                        if (!this.#annotationCanvasMap) {\n                            return;\n                        }\n                        const layer1 = this.div;\n                        for (const [id1, canvas1] of this.#annotationCanvasMap){\n                            const element1 = layer1.querySelector(`[data-annotation-id=\"${id1}\"]`);\n                            if (!element1) {\n                                continue;\n                            }\n                            const { firstChild: firstChild1 } = element1;\n                            if (!firstChild1) {\n                                element1.append(canvas1);\n                            } else if (firstChild1.nodeName === \"CANVAS\") {\n                                firstChild1.replaceWith(canvas1);\n                            } else {\n                                firstChild1.before(canvas1);\n                            }\n                        }\n                        this.#annotationCanvasMap.clear();\n                    }\n                    getEditableAnnotations() {\n                        return Array.from(this.#editableAnnotations.values());\n                    }\n                    getEditableAnnotation(id1) {\n                        return this.#editableAnnotations.get(id1);\n                    }\n                }\n                exports1.AnnotationLayer = AnnotationLayer1;\n            /***/ },\n            /* 30 */ /***/ (__unused_webpack_module1, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.ColorConverters = void 0;\n                function makeColorComp1(n1) {\n                    return Math.floor(Math.max(0, Math.min(1, n1)) * 255).toString(16).padStart(2, \"0\");\n                }\n                function scaleAndClamp1(x4) {\n                    return Math.max(0, Math.min(255, 255 * x4));\n                }\n                class ColorConverters1 {\n                    static CMYK_G([c4, y4, m3, k3]) {\n                        return [\n                            \"G\",\n                            1 - Math.min(1, 0.3 * c4 + 0.59 * m3 + 0.11 * y4 + k3)\n                        ];\n                    }\n                    static G_CMYK([g1]) {\n                        return [\n                            \"CMYK\",\n                            0,\n                            0,\n                            0,\n                            1 - g1\n                        ];\n                    }\n                    static G_RGB([g1]) {\n                        return [\n                            \"RGB\",\n                            g1,\n                            g1,\n                            g1\n                        ];\n                    }\n                    static G_rgb([g1]) {\n                        g1 = scaleAndClamp1(g1);\n                        return [\n                            g1,\n                            g1,\n                            g1\n                        ];\n                    }\n                    static G_HTML([g1]) {\n                        const G1 = makeColorComp1(g1);\n                        return `#${G1}${G1}${G1}`;\n                    }\n                    static RGB_G([r1, g1, b4]) {\n                        return [\n                            \"G\",\n                            0.3 * r1 + 0.59 * g1 + 0.11 * b4\n                        ];\n                    }\n                    static RGB_rgb(color1) {\n                        return color1.map(scaleAndClamp1);\n                    }\n                    static RGB_HTML(color1) {\n                        return `#${color1.map(makeColorComp1).join(\"\")}`;\n                    }\n                    static T_HTML() {\n                        return \"#00000000\";\n                    }\n                    static T_rgb() {\n                        return [\n                            null\n                        ];\n                    }\n                    static CMYK_RGB([c4, y4, m3, k3]) {\n                        return [\n                            \"RGB\",\n                            1 - Math.min(1, c4 + k3),\n                            1 - Math.min(1, m3 + k3),\n                            1 - Math.min(1, y4 + k3)\n                        ];\n                    }\n                    static CMYK_rgb([c4, y4, m3, k3]) {\n                        return [\n                            scaleAndClamp1(1 - Math.min(1, c4 + k3)),\n                            scaleAndClamp1(1 - Math.min(1, m3 + k3)),\n                            scaleAndClamp1(1 - Math.min(1, y4 + k3))\n                        ];\n                    }\n                    static CMYK_HTML(components1) {\n                        const rgb1 = this.CMYK_RGB(components1).slice(1);\n                        return this.RGB_HTML(rgb1);\n                    }\n                    static RGB_CMYK([r1, g1, b4]) {\n                        const c4 = 1 - r1;\n                        const m3 = 1 - g1;\n                        const y4 = 1 - b4;\n                        const k3 = Math.min(c4, m3, y4);\n                        return [\n                            \"CMYK\",\n                            c4,\n                            m3,\n                            y4,\n                            k3\n                        ];\n                    }\n                }\n                exports1.ColorConverters = ColorConverters1;\n            /***/ },\n            /* 31 */ /***/ (__unused_webpack_module1, exports1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.NullL10n = void 0;\n                exports1.getL10nFallback = getL10nFallback1;\n                const DEFAULT_L10N_STRINGS1 = {\n                    of_pages: \"of {{pagesCount}}\",\n                    page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\n                    document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\n                    document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\n                    document_properties_date_string: \"{{date}}, {{time}}\",\n                    document_properties_page_size_unit_inches: \"in\",\n                    document_properties_page_size_unit_millimeters: \"mm\",\n                    document_properties_page_size_orientation_portrait: \"portrait\",\n                    document_properties_page_size_orientation_landscape: \"landscape\",\n                    document_properties_page_size_name_a3: \"A3\",\n                    document_properties_page_size_name_a4: \"A4\",\n                    document_properties_page_size_name_letter: \"Letter\",\n                    document_properties_page_size_name_legal: \"Legal\",\n                    document_properties_page_size_dimension_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{orientation}})\",\n                    document_properties_page_size_dimension_name_string: \"{{width}} \\xd7 {{height}} {{unit}} ({{name}}, {{orientation}})\",\n                    document_properties_linearized_yes: \"Yes\",\n                    document_properties_linearized_no: \"No\",\n                    additional_layers: \"Additional Layers\",\n                    page_landmark: \"Page {{page}}\",\n                    thumb_page_title: \"Page {{page}}\",\n                    thumb_page_canvas: \"Thumbnail of Page {{page}}\",\n                    find_reached_top: \"Reached top of document, continued from bottom\",\n                    find_reached_bottom: \"Reached end of document, continued from top\",\n                    \"find_match_count[one]\": \"{{current}} of {{total}} match\",\n                    \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\n                    \"find_match_count_limit[one]\": \"More than {{limit}} match\",\n                    \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\n                    find_not_found: \"Phrase not found\",\n                    page_scale_width: \"Page Width\",\n                    page_scale_fit: \"Page Fit\",\n                    page_scale_auto: \"Automatic Zoom\",\n                    page_scale_actual: \"Actual Size\",\n                    page_scale_percent: \"{{scale}}%\",\n                    loading_error: \"An error occurred while loading the PDF.\",\n                    invalid_file_error: \"Invalid or corrupted PDF file.\",\n                    missing_file_error: \"Missing PDF file.\",\n                    unexpected_response_error: \"Unexpected server response.\",\n                    rendering_error: \"An error occurred while rendering the page.\",\n                    annotation_date_string: \"{{date}}, {{time}}\",\n                    printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\n                    printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\n                    web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\",\n                    free_text2_default_content: \"Start typing…\",\n                    editor_free_text2_aria_label: \"Text Editor\",\n                    editor_ink2_aria_label: \"Draw Editor\",\n                    editor_ink_canvas_aria_label: \"User-created image\",\n                    editor_alt_text_button_label: \"Alt text\",\n                    editor_alt_text_edit_button_label: \"Edit alt text\",\n                    editor_alt_text_decorative_tooltip: \"Marked as decorative\"\n                };\n                {\n                    DEFAULT_L10N_STRINGS1.print_progress_percent = \"{{progress}}%\";\n                }\n                function getL10nFallback1(key1, args1) {\n                    switch(key1){\n                        case \"find_match_count\":\n                            key1 = `find_match_count[${args1.total === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                        case \"find_match_count_limit\":\n                            key1 = `find_match_count_limit[${args1.limit === 1 ? \"one\" : \"other\"}]`;\n                            break;\n                    }\n                    return DEFAULT_L10N_STRINGS1[key1] || \"\";\n                }\n                function formatL10nValue1(text1, args1) {\n                    if (!args1) {\n                        return text1;\n                    }\n                    return text1.replaceAll(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all1, name1)=>{\n                        return name1 in args1 ? args1[name1] : \"{{\" + name1 + \"}}\";\n                    });\n                }\n                const NullL10n1 = {\n                    async getLanguage () {\n                        return \"en-us\";\n                    },\n                    async getDirection () {\n                        return \"ltr\";\n                    },\n                    async get (key1, args1 = null, fallback1 = getL10nFallback1(key1, args1)) {\n                        return formatL10nValue1(fallback1, args1);\n                    },\n                    async translate (element1) {}\n                };\n                exports1.NullL10n = NullL10n1;\n            /***/ },\n            /* 32 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.XfaLayer = void 0;\n                var _xfa_text1 = __w_pdfjs_require__1(25);\n                class XfaLayer1 {\n                    static setupStorage(html1, id1, element1, storage1, intent1) {\n                        const storedData1 = storage1.getValue(id1, {\n                            value: null\n                        });\n                        switch(element1.name){\n                            case \"textarea\":\n                                if (storedData1.value !== null) {\n                                    html1.textContent = storedData1.value;\n                                }\n                                if (intent1 === \"print\") {\n                                    break;\n                                }\n                                html1.addEventListener(\"input\", (event1)=>{\n                                    storage1.setValue(id1, {\n                                        value: event1.target.value\n                                    });\n                                });\n                                break;\n                            case \"input\":\n                                if (element1.attributes.type === \"radio\" || element1.attributes.type === \"checkbox\") {\n                                    if (storedData1.value === element1.attributes.xfaOn) {\n                                        html1.setAttribute(\"checked\", true);\n                                    } else if (storedData1.value === element1.attributes.xfaOff) {\n                                        html1.removeAttribute(\"checked\");\n                                    }\n                                    if (intent1 === \"print\") {\n                                        break;\n                                    }\n                                    html1.addEventListener(\"change\", (event1)=>{\n                                        storage1.setValue(id1, {\n                                            value: event1.target.checked ? event1.target.getAttribute(\"xfaOn\") : event1.target.getAttribute(\"xfaOff\")\n                                        });\n                                    });\n                                } else {\n                                    if (storedData1.value !== null) {\n                                        html1.setAttribute(\"value\", storedData1.value);\n                                    }\n                                    if (intent1 === \"print\") {\n                                        break;\n                                    }\n                                    html1.addEventListener(\"input\", (event1)=>{\n                                        storage1.setValue(id1, {\n                                            value: event1.target.value\n                                        });\n                                    });\n                                }\n                                break;\n                            case \"select\":\n                                if (storedData1.value !== null) {\n                                    html1.setAttribute(\"value\", storedData1.value);\n                                    for (const option1 of element1.children){\n                                        if (option1.attributes.value === storedData1.value) {\n                                            option1.attributes.selected = true;\n                                        } else if (option1.attributes.hasOwnProperty(\"selected\")) {\n                                            delete option1.attributes.selected;\n                                        }\n                                    }\n                                }\n                                html1.addEventListener(\"input\", (event1)=>{\n                                    const options1 = event1.target.options;\n                                    const value1 = options1.selectedIndex === -1 ? \"\" : options1[options1.selectedIndex].value;\n                                    storage1.setValue(id1, {\n                                        value: value1\n                                    });\n                                });\n                                break;\n                        }\n                    }\n                    static setAttributes({ html: html1, element: element1, storage: storage1 = null, intent: intent1, linkService: linkService1 }) {\n                        const { attributes: attributes1 } = element1;\n                        const isHTMLAnchorElement1 = html1 instanceof HTMLAnchorElement;\n                        if (attributes1.type === \"radio\") {\n                            attributes1.name = `${attributes1.name}-${intent1}`;\n                        }\n                        for (const [key1, value1] of Object.entries(attributes1)){\n                            if (value1 === null || value1 === undefined) {\n                                continue;\n                            }\n                            switch(key1){\n                                case \"class\":\n                                    if (value1.length) {\n                                        html1.setAttribute(key1, value1.join(\" \"));\n                                    }\n                                    break;\n                                case \"dataId\":\n                                    break;\n                                case \"id\":\n                                    html1.setAttribute(\"data-element-id\", value1);\n                                    break;\n                                case \"style\":\n                                    Object.assign(html1.style, value1);\n                                    break;\n                                case \"textContent\":\n                                    html1.textContent = value1;\n                                    break;\n                                default:\n                                    if (!isHTMLAnchorElement1 || key1 !== \"href\" && key1 !== \"newWindow\") {\n                                        html1.setAttribute(key1, value1);\n                                    }\n                            }\n                        }\n                        if (isHTMLAnchorElement1) {\n                            linkService1.addLinkAttributes(html1, attributes1.href, attributes1.newWindow);\n                        }\n                        if (storage1 && attributes1.dataId) {\n                            this.setupStorage(html1, attributes1.dataId, element1, storage1);\n                        }\n                    }\n                    static render(parameters1) {\n                        const storage1 = parameters1.annotationStorage;\n                        const linkService1 = parameters1.linkService;\n                        const root1 = parameters1.xfaHtml;\n                        const intent1 = parameters1.intent || \"display\";\n                        const rootHtml1 = document.createElement(root1.name);\n                        if (root1.attributes) {\n                            this.setAttributes({\n                                html: rootHtml1,\n                                element: root1,\n                                intent: intent1,\n                                linkService: linkService1\n                            });\n                        }\n                        const stack1 = [\n                            [\n                                root1,\n                                -1,\n                                rootHtml1\n                            ]\n                        ];\n                        const rootDiv1 = parameters1.div;\n                        rootDiv1.append(rootHtml1);\n                        if (parameters1.viewport) {\n                            const transform1 = `matrix(${parameters1.viewport.transform.join(\",\")})`;\n                            rootDiv1.style.transform = transform1;\n                        }\n                        if (intent1 !== \"richText\") {\n                            rootDiv1.setAttribute(\"class\", \"xfaLayer xfaFont\");\n                        }\n                        const textDivs1 = [];\n                        while(stack1.length > 0){\n                            const [parent1, i1, html1] = stack1.at(-1);\n                            if (i1 + 1 === parent1.children.length) {\n                                stack1.pop();\n                                continue;\n                            }\n                            const child1 = parent1.children[++stack1.at(-1)[1]];\n                            if (child1 === null) {\n                                continue;\n                            }\n                            const { name: name1 } = child1;\n                            if (name1 === \"#text\") {\n                                const node1 = document.createTextNode(child1.value);\n                                textDivs1.push(node1);\n                                html1.append(node1);\n                                continue;\n                            }\n                            const childHtml1 = child1?.attributes?.xmlns ? document.createElementNS(child1.attributes.xmlns, name1) : document.createElement(name1);\n                            html1.append(childHtml1);\n                            if (child1.attributes) {\n                                this.setAttributes({\n                                    html: childHtml1,\n                                    element: child1,\n                                    storage: storage1,\n                                    intent: intent1,\n                                    linkService: linkService1\n                                });\n                            }\n                            if (child1.children && child1.children.length > 0) {\n                                stack1.push([\n                                    child1,\n                                    -1,\n                                    childHtml1\n                                ]);\n                            } else if (child1.value) {\n                                const node1 = document.createTextNode(child1.value);\n                                if (_xfa_text1.XfaText.shouldBuildText(name1)) {\n                                    textDivs1.push(node1);\n                                }\n                                childHtml1.append(node1);\n                            }\n                        }\n                        for (const el1 of rootDiv1.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n                            el1.setAttribute(\"readOnly\", true);\n                        }\n                        return {\n                            textDivs: textDivs1\n                        };\n                    }\n                    static update(parameters1) {\n                        const transform1 = `matrix(${parameters1.viewport.transform.join(\",\")})`;\n                        parameters1.div.style.transform = transform1;\n                        parameters1.div.hidden = false;\n                    }\n                }\n                exports1.XfaLayer = XfaLayer1;\n            /***/ },\n            /* 33 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.InkEditor = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _editor1 = __w_pdfjs_require__1(4);\n                var _annotation_layer1 = __w_pdfjs_require__1(29);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _tools1 = __w_pdfjs_require__1(5);\n                class InkEditor1 extends _editor1.AnnotationEditor {\n                    #baseHeight;\n                    #baseWidth;\n                    #boundCanvasPointermove;\n                    #boundCanvasPointerleave;\n                    #boundCanvasPointerup;\n                    #boundCanvasPointerdown;\n                    #currentPath2D;\n                    #disableEditing;\n                    #hasSomethingToDraw;\n                    #isCanvasInitialized;\n                    #observer;\n                    #realWidth;\n                    #realHeight;\n                    #requestFrameCallback;\n                    static{\n                        this._defaultColor = null;\n                    }\n                    static{\n                        this._defaultOpacity = 1;\n                    }\n                    static{\n                        this._defaultThickness = 1;\n                    }\n                    static{\n                        this._type = \"ink\";\n                    }\n                    constructor(params1){\n                        super({\n                            ...params1,\n                            name: \"inkEditor\"\n                        });\n                        this.#baseHeight = 0;\n                        this.#baseWidth = 0;\n                        this.#boundCanvasPointermove = this.canvasPointermove.bind(this);\n                        this.#boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n                        this.#boundCanvasPointerup = this.canvasPointerup.bind(this);\n                        this.#boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n                        this.#currentPath2D = new Path2D();\n                        this.#disableEditing = false;\n                        this.#hasSomethingToDraw = false;\n                        this.#isCanvasInitialized = false;\n                        this.#observer = null;\n                        this.#realWidth = 0;\n                        this.#realHeight = 0;\n                        this.#requestFrameCallback = null;\n                        this.color = params1.color || null;\n                        this.thickness = params1.thickness || null;\n                        this.opacity = params1.opacity || null;\n                        this.paths = [];\n                        this.bezierPath2D = [];\n                        this.allRawPaths = [];\n                        this.currentPath = [];\n                        this.scaleFactor = 1;\n                        this.translationX = this.translationY = 0;\n                        this.x = 0;\n                        this.y = 0;\n                        this._willKeepAspectRatio = true;\n                    }\n                    static initialize(l10n1) {\n                        _editor1.AnnotationEditor.initialize(l10n1, {\n                            strings: [\n                                \"editor_ink_canvas_aria_label\",\n                                \"editor_ink2_aria_label\"\n                            ]\n                        });\n                    }\n                    static updateDefaultParams(type1, value1) {\n                        switch(type1){\n                            case _util1.AnnotationEditorParamsType.INK_THICKNESS:\n                                InkEditor1._defaultThickness = value1;\n                                break;\n                            case _util1.AnnotationEditorParamsType.INK_COLOR:\n                                InkEditor1._defaultColor = value1;\n                                break;\n                            case _util1.AnnotationEditorParamsType.INK_OPACITY:\n                                InkEditor1._defaultOpacity = value1 / 100;\n                                break;\n                        }\n                    }\n                    updateParams(type1, value1) {\n                        switch(type1){\n                            case _util1.AnnotationEditorParamsType.INK_THICKNESS:\n                                this.#updateThickness(value1);\n                                break;\n                            case _util1.AnnotationEditorParamsType.INK_COLOR:\n                                this.#updateColor(value1);\n                                break;\n                            case _util1.AnnotationEditorParamsType.INK_OPACITY:\n                                this.#updateOpacity(value1);\n                                break;\n                        }\n                    }\n                    static get defaultPropertiesToUpdate() {\n                        return [\n                            [\n                                _util1.AnnotationEditorParamsType.INK_THICKNESS,\n                                InkEditor1._defaultThickness\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.INK_COLOR,\n                                InkEditor1._defaultColor || _editor1.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(InkEditor1._defaultOpacity * 100)\n                            ]\n                        ];\n                    }\n                    get propertiesToUpdate() {\n                        return [\n                            [\n                                _util1.AnnotationEditorParamsType.INK_THICKNESS,\n                                this.thickness || InkEditor1._defaultThickness\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.INK_COLOR,\n                                this.color || InkEditor1._defaultColor || _editor1.AnnotationEditor._defaultLineColor\n                            ],\n                            [\n                                _util1.AnnotationEditorParamsType.INK_OPACITY,\n                                Math.round(100 * (this.opacity ?? InkEditor1._defaultOpacity))\n                            ]\n                        ];\n                    }\n                    #updateThickness(thickness1) {\n                        const savedThickness1 = this.thickness;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.thickness = thickness1;\n                                this.#fitToContent();\n                            },\n                            undo: ()=>{\n                                this.thickness = savedThickness1;\n                                this.#fitToContent();\n                            },\n                            mustExec: true,\n                            type: _util1.AnnotationEditorParamsType.INK_THICKNESS,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateColor(color1) {\n                        const savedColor1 = this.color;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.color = color1;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.color = savedColor1;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util1.AnnotationEditorParamsType.INK_COLOR,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    #updateOpacity(opacity1) {\n                        opacity1 /= 100;\n                        const savedOpacity1 = this.opacity;\n                        this.addCommands({\n                            cmd: ()=>{\n                                this.opacity = opacity1;\n                                this.#redraw();\n                            },\n                            undo: ()=>{\n                                this.opacity = savedOpacity1;\n                                this.#redraw();\n                            },\n                            mustExec: true,\n                            type: _util1.AnnotationEditorParamsType.INK_OPACITY,\n                            overwriteIfSameType: true,\n                            keepUndo: true\n                        });\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (!this.canvas) {\n                            this.#createCanvas();\n                            this.#createObserver();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                            this.#setCanvasDims();\n                        }\n                        this.#fitToContent();\n                    }\n                    remove() {\n                        if (this.canvas === null) {\n                            return;\n                        }\n                        if (!this.isEmpty()) {\n                            this.commit();\n                        }\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.remove();\n                        this.canvas = null;\n                        this.#observer.disconnect();\n                        this.#observer = null;\n                        super.remove();\n                    }\n                    setParent(parent1) {\n                        if (!this.parent && parent1) {\n                            this._uiManager.removeShouldRescale(this);\n                        } else if (this.parent && parent1 === null) {\n                            this._uiManager.addShouldRescale(this);\n                        }\n                        super.setParent(parent1);\n                    }\n                    onScaleChanging() {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        const width2 = this.width * parentWidth1;\n                        const height1 = this.height * parentHeight1;\n                        this.setDimensions(width2, height1);\n                    }\n                    enableEditMode() {\n                        if (this.#disableEditing || this.canvas === null) {\n                            return;\n                        }\n                        super.enableEditMode();\n                        this._isDraggable = false;\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    disableEditMode() {\n                        if (!this.isInEditMode() || this.canvas === null) {\n                            return;\n                        }\n                        super.disableEditMode();\n                        this._isDraggable = !this.isEmpty();\n                        this.div.classList.remove(\"editing\");\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                    }\n                    onceAdded() {\n                        this._isDraggable = !this.isEmpty();\n                    }\n                    isEmpty() {\n                        return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n                    }\n                    #getInitialBBox() {\n                        const { parentRotation: parentRotation1, parentDimensions: [width2, height1] } = this;\n                        switch(parentRotation1){\n                            case 90:\n                                return [\n                                    0,\n                                    height1,\n                                    height1,\n                                    width2\n                                ];\n                            case 180:\n                                return [\n                                    width2,\n                                    height1,\n                                    width2,\n                                    height1\n                                ];\n                            case 270:\n                                return [\n                                    width2,\n                                    0,\n                                    height1,\n                                    width2\n                                ];\n                            default:\n                                return [\n                                    0,\n                                    0,\n                                    width2,\n                                    height1\n                                ];\n                        }\n                    }\n                    #setStroke() {\n                        const { ctx: ctx1, color: color1, opacity: opacity1, thickness: thickness1, parentScale: parentScale1, scaleFactor: scaleFactor1 } = this;\n                        ctx1.lineWidth = thickness1 * parentScale1 / scaleFactor1;\n                        ctx1.lineCap = \"round\";\n                        ctx1.lineJoin = \"round\";\n                        ctx1.miterLimit = 10;\n                        ctx1.strokeStyle = `${color1}${(0, _tools1.opacityToHex)(opacity1)}`;\n                    }\n                    #startDrawing(x4, y4) {\n                        this.canvas.addEventListener(\"contextmenu\", _display_utils1.noContextMenu);\n                        this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        this.isEditing = true;\n                        if (!this.#isCanvasInitialized) {\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.thickness ||= InkEditor1._defaultThickness;\n                            this.color ||= InkEditor1._defaultColor || _editor1.AnnotationEditor._defaultLineColor;\n                            this.opacity ??= InkEditor1._defaultOpacity;\n                        }\n                        this.currentPath.push([\n                            x4,\n                            y4\n                        ]);\n                        this.#hasSomethingToDraw = false;\n                        this.#setStroke();\n                        this.#requestFrameCallback = ()=>{\n                            this.#drawPoints();\n                            if (this.#requestFrameCallback) {\n                                window.requestAnimationFrame(this.#requestFrameCallback);\n                            }\n                        };\n                        window.requestAnimationFrame(this.#requestFrameCallback);\n                    }\n                    #draw(x4, y4) {\n                        const [lastX1, lastY1] = this.currentPath.at(-1);\n                        if (this.currentPath.length > 1 && x4 === lastX1 && y4 === lastY1) {\n                            return;\n                        }\n                        const currentPath1 = this.currentPath;\n                        let path2D1 = this.#currentPath2D;\n                        currentPath1.push([\n                            x4,\n                            y4\n                        ]);\n                        this.#hasSomethingToDraw = true;\n                        if (currentPath1.length <= 2) {\n                            path2D1.moveTo(...currentPath1[0]);\n                            path2D1.lineTo(x4, y4);\n                            return;\n                        }\n                        if (currentPath1.length === 3) {\n                            this.#currentPath2D = path2D1 = new Path2D();\n                            path2D1.moveTo(...currentPath1[0]);\n                        }\n                        this.#makeBezierCurve(path2D1, ...currentPath1.at(-3), ...currentPath1.at(-2), x4, y4);\n                    }\n                    #endPath() {\n                        if (this.currentPath.length === 0) {\n                            return;\n                        }\n                        const lastPoint1 = this.currentPath.at(-1);\n                        this.#currentPath2D.lineTo(...lastPoint1);\n                    }\n                    #stopDrawing(x4, y4) {\n                        this.#requestFrameCallback = null;\n                        x4 = Math.min(Math.max(x4, 0), this.canvas.width);\n                        y4 = Math.min(Math.max(y4, 0), this.canvas.height);\n                        this.#draw(x4, y4);\n                        this.#endPath();\n                        let bezier1;\n                        if (this.currentPath.length !== 1) {\n                            bezier1 = this.#generateBezierPoints();\n                        } else {\n                            const xy1 = [\n                                x4,\n                                y4\n                            ];\n                            bezier1 = [\n                                [\n                                    xy1,\n                                    xy1.slice(),\n                                    xy1.slice(),\n                                    xy1\n                                ]\n                            ];\n                        }\n                        const path2D1 = this.#currentPath2D;\n                        const currentPath1 = this.currentPath;\n                        this.currentPath = [];\n                        this.#currentPath2D = new Path2D();\n                        const cmd1 = ()=>{\n                            this.allRawPaths.push(currentPath1);\n                            this.paths.push(bezier1);\n                            this.bezierPath2D.push(path2D1);\n                            this.rebuild();\n                        };\n                        const undo1 = ()=>{\n                            this.allRawPaths.pop();\n                            this.paths.pop();\n                            this.bezierPath2D.pop();\n                            if (this.paths.length === 0) {\n                                this.remove();\n                            } else {\n                                if (!this.canvas) {\n                                    this.#createCanvas();\n                                    this.#createObserver();\n                                }\n                                this.#fitToContent();\n                            }\n                        };\n                        this.addCommands({\n                            cmd: cmd1,\n                            undo: undo1,\n                            mustExec: true\n                        });\n                    }\n                    #drawPoints() {\n                        if (!this.#hasSomethingToDraw) {\n                            return;\n                        }\n                        this.#hasSomethingToDraw = false;\n                        const thickness1 = Math.ceil(this.thickness * this.parentScale);\n                        const lastPoints1 = this.currentPath.slice(-3);\n                        const x4 = lastPoints1.map((xy1)=>xy1[0]);\n                        const y4 = lastPoints1.map((xy1)=>xy1[1]);\n                        const xMin1 = Math.min(...x4) - thickness1;\n                        const xMax1 = Math.max(...x4) + thickness1;\n                        const yMin1 = Math.min(...y4) - thickness1;\n                        const yMax1 = Math.max(...y4) + thickness1;\n                        const { ctx: ctx1 } = this;\n                        ctx1.save();\n                        ctx1.clearRect(0, 0, this.canvas.width, this.canvas.height);\n                        for (const path1 of this.bezierPath2D){\n                            ctx1.stroke(path1);\n                        }\n                        ctx1.stroke(this.#currentPath2D);\n                        ctx1.restore();\n                    }\n                    #makeBezierCurve(path2D1, x01, y01, x11, y11, x21, y21) {\n                        const prevX1 = (x01 + x11) / 2;\n                        const prevY1 = (y01 + y11) / 2;\n                        const x31 = (x11 + x21) / 2;\n                        const y31 = (y11 + y21) / 2;\n                        path2D1.bezierCurveTo(prevX1 + 2 * (x11 - prevX1) / 3, prevY1 + 2 * (y11 - prevY1) / 3, x31 + 2 * (x11 - x31) / 3, y31 + 2 * (y11 - y31) / 3, x31, y31);\n                    }\n                    #generateBezierPoints() {\n                        const path1 = this.currentPath;\n                        if (path1.length <= 2) {\n                            return [\n                                [\n                                    path1[0],\n                                    path1[0],\n                                    path1.at(-1),\n                                    path1.at(-1)\n                                ]\n                            ];\n                        }\n                        const bezierPoints1 = [];\n                        let i1;\n                        let [x01, y01] = path1[0];\n                        for(i1 = 1; i1 < path1.length - 2; i1++){\n                            const [x11, y11] = path1[i1];\n                            const [x21, y21] = path1[i1 + 1];\n                            const x31 = (x11 + x21) / 2;\n                            const y31 = (y11 + y21) / 2;\n                            const control11 = [\n                                x01 + 2 * (x11 - x01) / 3,\n                                y01 + 2 * (y11 - y01) / 3\n                            ];\n                            const control21 = [\n                                x31 + 2 * (x11 - x31) / 3,\n                                y31 + 2 * (y11 - y31) / 3\n                            ];\n                            bezierPoints1.push([\n                                [\n                                    x01,\n                                    y01\n                                ],\n                                control11,\n                                control21,\n                                [\n                                    x31,\n                                    y31\n                                ]\n                            ]);\n                            [x01, y01] = [\n                                x31,\n                                y31\n                            ];\n                        }\n                        const [x11, y11] = path1[i1];\n                        const [x21, y21] = path1[i1 + 1];\n                        const control11 = [\n                            x01 + 2 * (x11 - x01) / 3,\n                            y01 + 2 * (y11 - y01) / 3\n                        ];\n                        const control21 = [\n                            x21 + 2 * (x11 - x21) / 3,\n                            y21 + 2 * (y11 - y21) / 3\n                        ];\n                        bezierPoints1.push([\n                            [\n                                x01,\n                                y01\n                            ],\n                            control11,\n                            control21,\n                            [\n                                x21,\n                                y21\n                            ]\n                        ]);\n                        return bezierPoints1;\n                    }\n                    #redraw() {\n                        if (this.isEmpty()) {\n                            this.#updateTransform();\n                            return;\n                        }\n                        this.#setStroke();\n                        const { canvas: canvas1, ctx: ctx1 } = this;\n                        ctx1.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n                        this.#updateTransform();\n                        for (const path1 of this.bezierPath2D){\n                            ctx1.stroke(path1);\n                        }\n                    }\n                    commit() {\n                        if (this.#disableEditing) {\n                            return;\n                        }\n                        super.commit();\n                        this.isEditing = false;\n                        this.disableEditMode();\n                        this.setInForeground();\n                        this.#disableEditing = true;\n                        this.div.classList.add(\"disabled\");\n                        this.#fitToContent(true);\n                        this.makeResizable();\n                        this.parent.addInkEditorIfNeeded(true);\n                        this.moveInDOM();\n                        this.div.focus({\n                            preventScroll: true\n                        });\n                    }\n                    focusin(event1) {\n                        if (!this._focusEventsAllowed) {\n                            return;\n                        }\n                        super.focusin(event1);\n                        this.enableEditMode();\n                    }\n                    canvasPointerdown(event1) {\n                        if (event1.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n                            return;\n                        }\n                        this.setInForeground();\n                        event1.preventDefault();\n                        if (event1.type !== \"mouse\") {\n                            this.div.focus();\n                        }\n                        this.#startDrawing(event1.offsetX, event1.offsetY);\n                    }\n                    canvasPointermove(event1) {\n                        event1.preventDefault();\n                        this.#draw(event1.offsetX, event1.offsetY);\n                    }\n                    canvasPointerup(event1) {\n                        event1.preventDefault();\n                        this.#endDrawing(event1);\n                    }\n                    canvasPointerleave(event1) {\n                        this.#endDrawing(event1);\n                    }\n                    #endDrawing(event1) {\n                        this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n                        this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n                        this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n                        this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n                        setTimeout(()=>{\n                            this.canvas.removeEventListener(\"contextmenu\", _display_utils1.noContextMenu);\n                        }, 10);\n                        this.#stopDrawing(event1.offsetX, event1.offsetY);\n                        this.addToAnnotationStorage();\n                        this.setInBackground();\n                    }\n                    #createCanvas() {\n                        this.canvas = document.createElement(\"canvas\");\n                        this.canvas.width = this.canvas.height = 0;\n                        this.canvas.className = \"inkEditorCanvas\";\n                        _editor1.AnnotationEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then((msg1)=>this.canvas?.setAttribute(\"aria-label\", msg1));\n                        this.div.append(this.canvas);\n                        this.ctx = this.canvas.getContext(\"2d\");\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries1)=>{\n                            const rect3 = entries1[0].contentRect;\n                            if (rect3.width && rect3.height) {\n                                this.setDimensions(rect3.width, rect3.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    get isResizable() {\n                        return !this.isEmpty() && this.#disableEditing;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX1, baseY1;\n                        if (this.width) {\n                            baseX1 = this.x;\n                            baseY1 = this.y;\n                        }\n                        super.render();\n                        _editor1.AnnotationEditor._l10nPromise.get(\"editor_ink2_aria_label\").then((msg1)=>this.div?.setAttribute(\"aria-label\", msg1));\n                        const [x4, y4, w1, h3] = this.#getInitialBBox();\n                        this.setAt(x4, y4, 0, 0);\n                        this.setDims(w1, h3);\n                        this.#createCanvas();\n                        if (this.width) {\n                            const [parentWidth1, parentHeight1] = this.parentDimensions;\n                            this.setAspectRatio(this.width * parentWidth1, this.height * parentHeight1);\n                            this.setAt(baseX1 * parentWidth1, baseY1 * parentHeight1, this.width * parentWidth1, this.height * parentHeight1);\n                            this.#isCanvasInitialized = true;\n                            this.#setCanvasDims();\n                            this.setDims(this.width * parentWidth1, this.height * parentHeight1);\n                            this.#redraw();\n                            this.div.classList.add(\"disabled\");\n                        } else {\n                            this.div.classList.add(\"editing\");\n                            this.enableEditMode();\n                        }\n                        this.#createObserver();\n                        return this.div;\n                    }\n                    #setCanvasDims() {\n                        if (!this.#isCanvasInitialized) {\n                            return;\n                        }\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.canvas.width = Math.ceil(this.width * parentWidth1);\n                        this.canvas.height = Math.ceil(this.height * parentHeight1);\n                        this.#updateTransform();\n                    }\n                    setDimensions(width2, height1) {\n                        const roundedWidth1 = Math.round(width2);\n                        const roundedHeight1 = Math.round(height1);\n                        if (this.#realWidth === roundedWidth1 && this.#realHeight === roundedHeight1) {\n                            return;\n                        }\n                        this.#realWidth = roundedWidth1;\n                        this.#realHeight = roundedHeight1;\n                        this.canvas.style.visibility = \"hidden\";\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.width = width2 / parentWidth1;\n                        this.height = height1 / parentHeight1;\n                        this.fixAndSetPosition();\n                        if (this.#disableEditing) {\n                            this.#setScaleFactor(width2, height1);\n                        }\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.canvas.style.visibility = \"visible\";\n                        this.fixDims();\n                    }\n                    #setScaleFactor(width2, height1) {\n                        const padding1 = this.#getPadding();\n                        const scaleFactorW1 = (width2 - padding1) / this.#baseWidth;\n                        const scaleFactorH1 = (height1 - padding1) / this.#baseHeight;\n                        this.scaleFactor = Math.min(scaleFactorW1, scaleFactorH1);\n                    }\n                    #updateTransform() {\n                        const padding1 = this.#getPadding() / 2;\n                        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding1, this.translationY * this.scaleFactor + padding1);\n                    }\n                    static #buildPath2D(bezier1) {\n                        const path2D1 = new Path2D();\n                        for(let i1 = 0, ii1 = bezier1.length; i1 < ii1; i1++){\n                            const [first1, control11, control21, second1] = bezier1[i1];\n                            if (i1 === 0) {\n                                path2D1.moveTo(...first1);\n                            }\n                            path2D1.bezierCurveTo(control11[0], control11[1], control21[0], control21[1], second1[0], second1[1]);\n                        }\n                        return path2D1;\n                    }\n                    static #toPDFCoordinates(points1, rect3, rotation1) {\n                        const [blX1, blY1, trX1, trY1] = rect3;\n                        switch(rotation1){\n                            case 0:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    points1[i1] += blX1;\n                                    points1[i1 + 1] = trY1 - points1[i1 + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    const x4 = points1[i1];\n                                    points1[i1] = points1[i1 + 1] + blX1;\n                                    points1[i1 + 1] = x4 + blY1;\n                                }\n                                break;\n                            case 180:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    points1[i1] = trX1 - points1[i1];\n                                    points1[i1 + 1] += blY1;\n                                }\n                                break;\n                            case 270:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    const x4 = points1[i1];\n                                    points1[i1] = trX1 - points1[i1 + 1];\n                                    points1[i1 + 1] = trY1 - x4;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points1;\n                    }\n                    static #fromPDFCoordinates(points1, rect3, rotation1) {\n                        const [blX1, blY1, trX1, trY1] = rect3;\n                        switch(rotation1){\n                            case 0:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    points1[i1] -= blX1;\n                                    points1[i1 + 1] = trY1 - points1[i1 + 1];\n                                }\n                                break;\n                            case 90:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    const x4 = points1[i1];\n                                    points1[i1] = points1[i1 + 1] - blY1;\n                                    points1[i1 + 1] = x4 - blX1;\n                                }\n                                break;\n                            case 180:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    points1[i1] = trX1 - points1[i1];\n                                    points1[i1 + 1] -= blY1;\n                                }\n                                break;\n                            case 270:\n                                for(let i1 = 0, ii1 = points1.length; i1 < ii1; i1 += 2){\n                                    const x4 = points1[i1];\n                                    points1[i1] = trY1 - points1[i1 + 1];\n                                    points1[i1 + 1] = trX1 - x4;\n                                }\n                                break;\n                            default:\n                                throw new Error(\"Invalid rotation\");\n                        }\n                        return points1;\n                    }\n                    #serializePaths(s4, tx2, ty2, rect3) {\n                        const paths1 = [];\n                        const padding1 = this.thickness / 2;\n                        const shiftX1 = s4 * tx2 + padding1;\n                        const shiftY1 = s4 * ty2 + padding1;\n                        for (const bezier1 of this.paths){\n                            const buffer1 = [];\n                            const points1 = [];\n                            for(let j1 = 0, jj1 = bezier1.length; j1 < jj1; j1++){\n                                const [first1, control11, control21, second1] = bezier1[j1];\n                                const p101 = s4 * first1[0] + shiftX1;\n                                const p111 = s4 * first1[1] + shiftY1;\n                                const p201 = s4 * control11[0] + shiftX1;\n                                const p211 = s4 * control11[1] + shiftY1;\n                                const p301 = s4 * control21[0] + shiftX1;\n                                const p311 = s4 * control21[1] + shiftY1;\n                                const p401 = s4 * second1[0] + shiftX1;\n                                const p411 = s4 * second1[1] + shiftY1;\n                                if (j1 === 0) {\n                                    buffer1.push(p101, p111);\n                                    points1.push(p101, p111);\n                                }\n                                buffer1.push(p201, p211, p301, p311, p401, p411);\n                                points1.push(p201, p211);\n                                if (j1 === jj1 - 1) {\n                                    points1.push(p401, p411);\n                                }\n                            }\n                            paths1.push({\n                                bezier: InkEditor1.#toPDFCoordinates(buffer1, rect3, this.rotation),\n                                points: InkEditor1.#toPDFCoordinates(points1, rect3, this.rotation)\n                            });\n                        }\n                        return paths1;\n                    }\n                    #getBbox() {\n                        let xMin1 = Infinity;\n                        let xMax1 = -Infinity;\n                        let yMin1 = Infinity;\n                        let yMax1 = -Infinity;\n                        for (const path1 of this.paths){\n                            for (const [first1, control11, control21, second1] of path1){\n                                const bbox1 = _util1.Util.bezierBoundingBox(...first1, ...control11, ...control21, ...second1);\n                                xMin1 = Math.min(xMin1, bbox1[0]);\n                                yMin1 = Math.min(yMin1, bbox1[1]);\n                                xMax1 = Math.max(xMax1, bbox1[2]);\n                                yMax1 = Math.max(yMax1, bbox1[3]);\n                            }\n                        }\n                        return [\n                            xMin1,\n                            yMin1,\n                            xMax1,\n                            yMax1\n                        ];\n                    }\n                    #getPadding() {\n                        return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n                    }\n                    #fitToContent(firstTime1 = false) {\n                        if (this.isEmpty()) {\n                            return;\n                        }\n                        if (!this.#disableEditing) {\n                            this.#redraw();\n                            return;\n                        }\n                        const bbox1 = this.#getBbox();\n                        const padding1 = this.#getPadding();\n                        this.#baseWidth = Math.max(_editor1.AnnotationEditor.MIN_SIZE, bbox1[2] - bbox1[0]);\n                        this.#baseHeight = Math.max(_editor1.AnnotationEditor.MIN_SIZE, bbox1[3] - bbox1[1]);\n                        const width2 = Math.ceil(padding1 + this.#baseWidth * this.scaleFactor);\n                        const height1 = Math.ceil(padding1 + this.#baseHeight * this.scaleFactor);\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.width = width2 / parentWidth1;\n                        this.height = height1 / parentHeight1;\n                        this.setAspectRatio(width2, height1);\n                        const prevTranslationX1 = this.translationX;\n                        const prevTranslationY1 = this.translationY;\n                        this.translationX = -bbox1[0];\n                        this.translationY = -bbox1[1];\n                        this.#setCanvasDims();\n                        this.#redraw();\n                        this.#realWidth = width2;\n                        this.#realHeight = height1;\n                        this.setDims(width2, height1);\n                        const unscaledPadding1 = firstTime1 ? padding1 / this.scaleFactor / 2 : 0;\n                        this.translate(prevTranslationX1 - this.translationX - unscaledPadding1, prevTranslationY1 - this.translationY - unscaledPadding1);\n                    }\n                    static deserialize(data1, parent1, uiManager1) {\n                        if (data1 instanceof _annotation_layer1.InkAnnotationElement) {\n                            return null;\n                        }\n                        const editor1 = super.deserialize(data1, parent1, uiManager1);\n                        editor1.thickness = data1.thickness;\n                        editor1.color = _util1.Util.makeHexColor(...data1.color);\n                        editor1.opacity = data1.opacity;\n                        const [pageWidth1, pageHeight1] = editor1.pageDimensions;\n                        const width2 = editor1.width * pageWidth1;\n                        const height1 = editor1.height * pageHeight1;\n                        const scaleFactor1 = editor1.parentScale;\n                        const padding1 = data1.thickness / 2;\n                        editor1.#disableEditing = true;\n                        editor1.#realWidth = Math.round(width2);\n                        editor1.#realHeight = Math.round(height1);\n                        const { paths: paths1, rect: rect3, rotation: rotation1 } = data1;\n                        for (let { bezier: bezier1 } of paths1){\n                            bezier1 = InkEditor1.#fromPDFCoordinates(bezier1, rect3, rotation1);\n                            const path1 = [];\n                            editor1.paths.push(path1);\n                            let p01 = scaleFactor1 * (bezier1[0] - padding1);\n                            let p12 = scaleFactor1 * (bezier1[1] - padding1);\n                            for(let i1 = 2, ii1 = bezier1.length; i1 < ii1; i1 += 6){\n                                const p101 = scaleFactor1 * (bezier1[i1] - padding1);\n                                const p111 = scaleFactor1 * (bezier1[i1 + 1] - padding1);\n                                const p201 = scaleFactor1 * (bezier1[i1 + 2] - padding1);\n                                const p211 = scaleFactor1 * (bezier1[i1 + 3] - padding1);\n                                const p301 = scaleFactor1 * (bezier1[i1 + 4] - padding1);\n                                const p311 = scaleFactor1 * (bezier1[i1 + 5] - padding1);\n                                path1.push([\n                                    [\n                                        p01,\n                                        p12\n                                    ],\n                                    [\n                                        p101,\n                                        p111\n                                    ],\n                                    [\n                                        p201,\n                                        p211\n                                    ],\n                                    [\n                                        p301,\n                                        p311\n                                    ]\n                                ]);\n                                p01 = p301;\n                                p12 = p311;\n                            }\n                            const path2D1 = this.#buildPath2D(path1);\n                            editor1.bezierPath2D.push(path2D1);\n                        }\n                        const bbox1 = editor1.#getBbox();\n                        editor1.#baseWidth = Math.max(_editor1.AnnotationEditor.MIN_SIZE, bbox1[2] - bbox1[0]);\n                        editor1.#baseHeight = Math.max(_editor1.AnnotationEditor.MIN_SIZE, bbox1[3] - bbox1[1]);\n                        editor1.#setScaleFactor(width2, height1);\n                        return editor1;\n                    }\n                    serialize() {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const rect3 = this.getRect(0, 0);\n                        const color1 = _editor1.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n                        return {\n                            annotationType: _util1.AnnotationEditorType.INK,\n                            color: color1,\n                            thickness: this.thickness,\n                            opacity: this.opacity,\n                            paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect3),\n                            pageIndex: this.pageIndex,\n                            rect: rect3,\n                            rotation: this.rotation,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                    }\n                }\n                exports1.InkEditor = InkEditor1;\n            /***/ },\n            /* 34 */ /***/ (__unused_webpack_module1, exports1, __w_pdfjs_require__1)=>{\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.StampEditor = void 0;\n                var _util1 = __w_pdfjs_require__1(1);\n                var _editor1 = __w_pdfjs_require__1(4);\n                var _display_utils1 = __w_pdfjs_require__1(6);\n                var _annotation_layer1 = __w_pdfjs_require__1(29);\n                class StampEditor1 extends _editor1.AnnotationEditor {\n                    #bitmap;\n                    #bitmapId;\n                    #bitmapPromise;\n                    #bitmapUrl;\n                    #bitmapFile;\n                    #canvas;\n                    #observer;\n                    #resizeTimeoutId;\n                    #isSvg;\n                    #hasBeenAddedInUndoStack;\n                    static{\n                        this._type = \"stamp\";\n                    }\n                    constructor(params1){\n                        super({\n                            ...params1,\n                            name: \"stampEditor\"\n                        });\n                        this.#bitmap = null;\n                        this.#bitmapId = null;\n                        this.#bitmapPromise = null;\n                        this.#bitmapUrl = null;\n                        this.#bitmapFile = null;\n                        this.#canvas = null;\n                        this.#observer = null;\n                        this.#resizeTimeoutId = null;\n                        this.#isSvg = false;\n                        this.#hasBeenAddedInUndoStack = false;\n                        this.#bitmapUrl = params1.bitmapUrl;\n                        this.#bitmapFile = params1.bitmapFile;\n                    }\n                    static initialize(l10n1) {\n                        _editor1.AnnotationEditor.initialize(l10n1);\n                    }\n                    static get supportedTypes() {\n                        const types1 = [\n                            \"apng\",\n                            \"avif\",\n                            \"bmp\",\n                            \"gif\",\n                            \"jpeg\",\n                            \"png\",\n                            \"svg+xml\",\n                            \"webp\",\n                            \"x-icon\"\n                        ];\n                        return (0, _util1.shadow)(this, \"supportedTypes\", types1.map((type1)=>`image/${type1}`));\n                    }\n                    static get supportedTypesStr() {\n                        return (0, _util1.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n                    }\n                    static isHandlingMimeForPasting(mime1) {\n                        return this.supportedTypes.includes(mime1);\n                    }\n                    static paste(item1, parent1) {\n                        parent1.pasteEditor(_util1.AnnotationEditorType.STAMP, {\n                            bitmapFile: item1.getAsFile()\n                        });\n                    }\n                    #getBitmapFetched(data1, fromId1 = false) {\n                        if (!data1) {\n                            this.remove();\n                            return;\n                        }\n                        this.#bitmap = data1.bitmap;\n                        if (!fromId1) {\n                            this.#bitmapId = data1.id;\n                            this.#isSvg = data1.isSvg;\n                        }\n                        this.#createCanvas();\n                    }\n                    #getBitmapDone() {\n                        this.#bitmapPromise = null;\n                        this._uiManager.enableWaiting(false);\n                        if (this.#canvas) {\n                            this.div.focus();\n                        }\n                    }\n                    #getBitmap() {\n                        if (this.#bitmapId) {\n                            this._uiManager.enableWaiting(true);\n                            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data1)=>this.#getBitmapFetched(data1, true)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapUrl) {\n                            const url1 = this.#bitmapUrl;\n                            this.#bitmapUrl = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url1).then((data1)=>this.#getBitmapFetched(data1)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        if (this.#bitmapFile) {\n                            const file1 = this.#bitmapFile;\n                            this.#bitmapFile = null;\n                            this._uiManager.enableWaiting(true);\n                            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file1).then((data1)=>this.#getBitmapFetched(data1)).finally(()=>this.#getBitmapDone());\n                            return;\n                        }\n                        const input1 = document.createElement(\"input\");\n                        input1.type = \"file\";\n                        input1.accept = StampEditor1.supportedTypesStr;\n                        this.#bitmapPromise = new Promise((resolve1)=>{\n                            input1.addEventListener(\"change\", async ()=>{\n                                if (!input1.files || input1.files.length === 0) {\n                                    this.remove();\n                                } else {\n                                    this._uiManager.enableWaiting(true);\n                                    const data1 = await this._uiManager.imageManager.getFromFile(input1.files[0]);\n                                    this.#getBitmapFetched(data1);\n                                }\n                                resolve1();\n                            });\n                            input1.addEventListener(\"cancel\", ()=>{\n                                this.remove();\n                                resolve1();\n                            });\n                        }).finally(()=>this.#getBitmapDone());\n                        input1.click();\n                    }\n                    remove() {\n                        if (this.#bitmapId) {\n                            this.#bitmap = null;\n                            this._uiManager.imageManager.deleteId(this.#bitmapId);\n                            this.#canvas?.remove();\n                            this.#canvas = null;\n                            this.#observer?.disconnect();\n                            this.#observer = null;\n                        }\n                        super.remove();\n                    }\n                    rebuild() {\n                        if (!this.parent) {\n                            if (this.#bitmapId) {\n                                this.#getBitmap();\n                            }\n                            return;\n                        }\n                        super.rebuild();\n                        if (this.div === null) {\n                            return;\n                        }\n                        if (this.#bitmapId) {\n                            this.#getBitmap();\n                        }\n                        if (!this.isAttachedToDOM) {\n                            this.parent.add(this);\n                        }\n                    }\n                    onceAdded() {\n                        this._isDraggable = true;\n                        this.div.focus();\n                    }\n                    isEmpty() {\n                        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n                    }\n                    get isResizable() {\n                        return true;\n                    }\n                    render() {\n                        if (this.div) {\n                            return this.div;\n                        }\n                        let baseX1, baseY1;\n                        if (this.width) {\n                            baseX1 = this.x;\n                            baseY1 = this.y;\n                        }\n                        super.render();\n                        this.div.hidden = true;\n                        if (this.#bitmap) {\n                            this.#createCanvas();\n                        } else {\n                            this.#getBitmap();\n                        }\n                        if (this.width) {\n                            const [parentWidth1, parentHeight1] = this.parentDimensions;\n                            this.setAt(baseX1 * parentWidth1, baseY1 * parentHeight1, this.width * parentWidth1, this.height * parentHeight1);\n                        }\n                        return this.div;\n                    }\n                    #createCanvas() {\n                        const { div: div1 } = this;\n                        let { width: width2, height: height1 } = this.#bitmap;\n                        const [pageWidth1, pageHeight1] = this.pageDimensions;\n                        const MAX_RATIO1 = 0.75;\n                        if (this.width) {\n                            width2 = this.width * pageWidth1;\n                            height1 = this.height * pageHeight1;\n                        } else if (width2 > MAX_RATIO1 * pageWidth1 || height1 > MAX_RATIO1 * pageHeight1) {\n                            const factor1 = Math.min(MAX_RATIO1 * pageWidth1 / width2, MAX_RATIO1 * pageHeight1 / height1);\n                            width2 *= factor1;\n                            height1 *= factor1;\n                        }\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.setDims(width2 * parentWidth1 / pageWidth1, height1 * parentHeight1 / pageHeight1);\n                        this._uiManager.enableWaiting(false);\n                        const canvas1 = this.#canvas = document.createElement(\"canvas\");\n                        div1.append(canvas1);\n                        div1.hidden = false;\n                        this.#drawBitmap(width2, height1);\n                        this.#createObserver();\n                        if (!this.#hasBeenAddedInUndoStack) {\n                            this.parent.addUndoableEditor(this);\n                            this.#hasBeenAddedInUndoStack = true;\n                        }\n                        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n                            source: this,\n                            details: {\n                                type: \"editing\",\n                                subtype: this.editorType,\n                                data: {\n                                    action: \"inserted_image\"\n                                }\n                            }\n                        });\n                        this.addAltTextButton();\n                    }\n                    #setDimensions(width2, height1) {\n                        const [parentWidth1, parentHeight1] = this.parentDimensions;\n                        this.width = width2 / parentWidth1;\n                        this.height = height1 / parentHeight1;\n                        this.setDims(width2, height1);\n                        if (this._initialOptions?.isCentered) {\n                            this.center();\n                        } else {\n                            this.fixAndSetPosition();\n                        }\n                        this._initialOptions = null;\n                        if (this.#resizeTimeoutId !== null) {\n                            clearTimeout(this.#resizeTimeoutId);\n                        }\n                        const TIME_TO_WAIT1 = 200;\n                        this.#resizeTimeoutId = setTimeout(()=>{\n                            this.#resizeTimeoutId = null;\n                            this.#drawBitmap(width2, height1);\n                        }, TIME_TO_WAIT1);\n                    }\n                    #scaleBitmap(width2, height1) {\n                        const { width: bitmapWidth1, height: bitmapHeight1 } = this.#bitmap;\n                        let newWidth1 = bitmapWidth1;\n                        let newHeight1 = bitmapHeight1;\n                        let bitmap1 = this.#bitmap;\n                        while(newWidth1 > 2 * width2 || newHeight1 > 2 * height1){\n                            const prevWidth1 = newWidth1;\n                            const prevHeight1 = newHeight1;\n                            if (newWidth1 > 2 * width2) {\n                                newWidth1 = newWidth1 >= 16384 ? Math.floor(newWidth1 / 2) - 1 : Math.ceil(newWidth1 / 2);\n                            }\n                            if (newHeight1 > 2 * height1) {\n                                newHeight1 = newHeight1 >= 16384 ? Math.floor(newHeight1 / 2) - 1 : Math.ceil(newHeight1 / 2);\n                            }\n                            const offscreen1 = new OffscreenCanvas(newWidth1, newHeight1);\n                            const ctx1 = offscreen1.getContext(\"2d\");\n                            ctx1.drawImage(bitmap1, 0, 0, prevWidth1, prevHeight1, 0, 0, newWidth1, newHeight1);\n                            bitmap1 = offscreen1.transferToImageBitmap();\n                        }\n                        return bitmap1;\n                    }\n                    #drawBitmap(width2, height1) {\n                        width2 = Math.ceil(width2);\n                        height1 = Math.ceil(height1);\n                        const canvas1 = this.#canvas;\n                        if (!canvas1 || canvas1.width === width2 && canvas1.height === height1) {\n                            return;\n                        }\n                        canvas1.width = width2;\n                        canvas1.height = height1;\n                        const bitmap1 = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width2, height1);\n                        const ctx1 = canvas1.getContext(\"2d\");\n                        ctx1.filter = this._uiManager.hcmFilter;\n                        ctx1.drawImage(bitmap1, 0, 0, bitmap1.width, bitmap1.height, 0, 0, width2, height1);\n                    }\n                    #serializeBitmap(toUrl1) {\n                        if (toUrl1) {\n                            if (this.#isSvg) {\n                                const url1 = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                                if (url1) {\n                                    return url1;\n                                }\n                            }\n                            const canvas1 = document.createElement(\"canvas\");\n                            ({ width: canvas1.width, height: canvas1.height } = this.#bitmap);\n                            const ctx1 = canvas1.getContext(\"2d\");\n                            ctx1.drawImage(this.#bitmap, 0, 0);\n                            return canvas1.toDataURL();\n                        }\n                        if (this.#isSvg) {\n                            const [pageWidth1, pageHeight1] = this.pageDimensions;\n                            const width2 = Math.round(this.width * pageWidth1 * _display_utils1.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const height1 = Math.round(this.height * pageHeight1 * _display_utils1.PixelsPerInch.PDF_TO_CSS_UNITS);\n                            const offscreen1 = new OffscreenCanvas(width2, height1);\n                            const ctx1 = offscreen1.getContext(\"2d\");\n                            ctx1.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width2, height1);\n                            return offscreen1.transferToImageBitmap();\n                        }\n                        return structuredClone(this.#bitmap);\n                    }\n                    #createObserver() {\n                        this.#observer = new ResizeObserver((entries1)=>{\n                            const rect3 = entries1[0].contentRect;\n                            if (rect3.width && rect3.height) {\n                                this.#setDimensions(rect3.width, rect3.height);\n                            }\n                        });\n                        this.#observer.observe(this.div);\n                    }\n                    static deserialize(data1, parent1, uiManager1) {\n                        if (data1 instanceof _annotation_layer1.StampAnnotationElement) {\n                            return null;\n                        }\n                        const editor1 = super.deserialize(data1, parent1, uiManager1);\n                        const { rect: rect3, bitmapUrl: bitmapUrl1, bitmapId: bitmapId1, isSvg: isSvg1, accessibilityData: accessibilityData1 } = data1;\n                        if (bitmapId1 && uiManager1.imageManager.isValidId(bitmapId1)) {\n                            editor1.#bitmapId = bitmapId1;\n                        } else {\n                            editor1.#bitmapUrl = bitmapUrl1;\n                        }\n                        editor1.#isSvg = isSvg1;\n                        const [parentWidth1, parentHeight1] = editor1.pageDimensions;\n                        editor1.width = (rect3[2] - rect3[0]) / parentWidth1;\n                        editor1.height = (rect3[3] - rect3[1]) / parentHeight1;\n                        if (accessibilityData1) {\n                            editor1.altTextData = accessibilityData1;\n                        }\n                        return editor1;\n                    }\n                    serialize(isForCopying1 = false, context1 = null) {\n                        if (this.isEmpty()) {\n                            return null;\n                        }\n                        const serialized1 = {\n                            annotationType: _util1.AnnotationEditorType.STAMP,\n                            bitmapId: this.#bitmapId,\n                            pageIndex: this.pageIndex,\n                            rect: this.getRect(0, 0),\n                            rotation: this.rotation,\n                            isSvg: this.#isSvg,\n                            structTreeParentId: this._structTreeParentId\n                        };\n                        if (isForCopying1) {\n                            serialized1.bitmapUrl = this.#serializeBitmap(true);\n                            serialized1.accessibilityData = this.altTextData;\n                            return serialized1;\n                        }\n                        const { decorative: decorative1, altText: altText1 } = this.altTextData;\n                        if (!decorative1 && altText1) {\n                            serialized1.accessibilityData = {\n                                type: \"Figure\",\n                                alt: altText1\n                            };\n                        }\n                        if (context1 === null) {\n                            return serialized1;\n                        }\n                        context1.stamps ||= new Map();\n                        const area1 = this.#isSvg ? (serialized1.rect[2] - serialized1.rect[0]) * (serialized1.rect[3] - serialized1.rect[1]) : null;\n                        if (!context1.stamps.has(this.#bitmapId)) {\n                            context1.stamps.set(this.#bitmapId, {\n                                area: area1,\n                                serialized: serialized1\n                            });\n                            serialized1.bitmap = this.#serializeBitmap(false);\n                        } else if (this.#isSvg) {\n                            const prevData1 = context1.stamps.get(this.#bitmapId);\n                            if (area1 > prevData1.area) {\n                                prevData1.area = area1;\n                                prevData1.serialized.bitmap.close();\n                                prevData1.serialized.bitmap = this.#serializeBitmap(false);\n                            }\n                        }\n                        return serialized1;\n                    }\n                }\n                exports1.StampEditor = StampEditor1;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __w_pdfjs_require__(moduleId1) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule1 = __webpack_module_cache__[moduleId1];\n            /******/ if (cachedModule1 !== undefined) {\n                /******/ return cachedModule1.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId1] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId1](module1, module1.exports, __w_pdfjs_require__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n        (()=>{\n            var exports1 = __nested_webpack_exports__;\n            Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n            Object.defineProperty(exports1, \"AbortException\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.AbortException;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_editor_layer1.AnnotationEditorLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorParamsType\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.AnnotationEditorParamsType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorType\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.AnnotationEditorType;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationEditorUIManager\", {\n                enumerable: true,\n                get: function() {\n                    return _tools1.AnnotationEditorUIManager;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _annotation_layer1.AnnotationLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"AnnotationMode\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.AnnotationMode;\n                }\n            });\n            Object.defineProperty(exports1, \"CMapCompressionType\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.CMapCompressionType;\n                }\n            });\n            Object.defineProperty(exports1, \"DOMSVGFactory\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.DOMSVGFactory;\n                }\n            });\n            Object.defineProperty(exports1, \"FeatureTest\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.FeatureTest;\n                }\n            });\n            Object.defineProperty(exports1, \"GlobalWorkerOptions\", {\n                enumerable: true,\n                get: function() {\n                    return _worker_options1.GlobalWorkerOptions;\n                }\n            });\n            Object.defineProperty(exports1, \"ImageKind\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.ImageKind;\n                }\n            });\n            Object.defineProperty(exports1, \"InvalidPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.InvalidPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"MissingPDFException\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.MissingPDFException;\n                }\n            });\n            Object.defineProperty(exports1, \"OPS\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.OPS;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDataRangeTransport\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.PDFDataRangeTransport;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFDateString\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.PDFDateString;\n                }\n            });\n            Object.defineProperty(exports1, \"PDFWorker\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.PDFWorker;\n                }\n            });\n            Object.defineProperty(exports1, \"PasswordResponses\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.PasswordResponses;\n                }\n            });\n            Object.defineProperty(exports1, \"PermissionFlag\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.PermissionFlag;\n                }\n            });\n            Object.defineProperty(exports1, \"PixelsPerInch\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.PixelsPerInch;\n                }\n            });\n            Object.defineProperty(exports1, \"PromiseCapability\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.PromiseCapability;\n                }\n            });\n            Object.defineProperty(exports1, \"RenderingCancelledException\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.RenderingCancelledException;\n                }\n            });\n            Object.defineProperty(exports1, \"SVGGraphics\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.SVGGraphics;\n                }\n            });\n            Object.defineProperty(exports1, \"UnexpectedResponseException\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.UnexpectedResponseException;\n                }\n            });\n            Object.defineProperty(exports1, \"Util\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.Util;\n                }\n            });\n            Object.defineProperty(exports1, \"VerbosityLevel\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.VerbosityLevel;\n                }\n            });\n            Object.defineProperty(exports1, \"XfaLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _xfa_layer1.XfaLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"build\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.build;\n                }\n            });\n            Object.defineProperty(exports1, \"createValidAbsoluteUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.createValidAbsoluteUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getDocument\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.getDocument;\n                }\n            });\n            Object.defineProperty(exports1, \"getFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.getFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getPdfFilenameFromUrl\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.getPdfFilenameFromUrl;\n                }\n            });\n            Object.defineProperty(exports1, \"getXfaPageViewport\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.getXfaPageViewport;\n                }\n            });\n            Object.defineProperty(exports1, \"isDataScheme\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.isDataScheme;\n                }\n            });\n            Object.defineProperty(exports1, \"isPdfFile\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.isPdfFile;\n                }\n            });\n            Object.defineProperty(exports1, \"loadScript\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.loadScript;\n                }\n            });\n            Object.defineProperty(exports1, \"noContextMenu\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.noContextMenu;\n                }\n            });\n            Object.defineProperty(exports1, \"normalizeUnicode\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.normalizeUnicode;\n                }\n            });\n            Object.defineProperty(exports1, \"renderTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer1.renderTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"setLayerDimensions\", {\n                enumerable: true,\n                get: function() {\n                    return _display_utils1.setLayerDimensions;\n                }\n            });\n            Object.defineProperty(exports1, \"shadow\", {\n                enumerable: true,\n                get: function() {\n                    return _util1.shadow;\n                }\n            });\n            Object.defineProperty(exports1, \"updateTextLayer\", {\n                enumerable: true,\n                get: function() {\n                    return _text_layer1.updateTextLayer;\n                }\n            });\n            Object.defineProperty(exports1, \"version\", {\n                enumerable: true,\n                get: function() {\n                    return _api1.version;\n                }\n            });\n            var _util1 = __w_pdfjs_require__(1);\n            var _api1 = __w_pdfjs_require__(2);\n            var _display_utils1 = __w_pdfjs_require__(6);\n            var _text_layer1 = __w_pdfjs_require__(26);\n            var _annotation_editor_layer1 = __w_pdfjs_require__(27);\n            var _tools1 = __w_pdfjs_require__(5);\n            var _annotation_layer1 = __w_pdfjs_require__(29);\n            var _worker_options1 = __w_pdfjs_require__(14);\n            var _xfa_layer1 = __w_pdfjs_require__(32);\n            const pdfjsVersion1 = \"3.11.174\";\n            const pdfjsBuild1 = \"ce8716743\";\n        })();\n        /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=pdf.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBRUEsVUFBU0Esa0NBQWlDQyxLQUFJLEVBQUVDLFFBQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRixNQUFLSSxRQUFRLEdBQUdIO1NBQzdCLEVBSzJDQTtBQUNqRCxHQUFHTSxZQUFZO0lBQ2YsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7O1lBRXJDLEtBQUssR0FDTCxHQUFHLEdBQUksQ0FBQ0MsMEJBQXlCUDtnQkFJakNRLE9BQU9DLGNBQWMsQ0FBQ1QsVUFBUyxjQUFlO29CQUM1Q1UsT0FBTztnQkFDVDtnQkFDQVYsU0FBUVcsY0FBYyxHQUFHWCxTQUFRWSxJQUFJLEdBQUdaLFNBQVFhLHFCQUFxQixHQUFHYixTQUFRYywyQkFBMkIsR0FBR2QsU0FBUWUsaUJBQWlCLEdBQUdmLFNBQVFnQixtQkFBbUIsR0FBR2hCLFNBQVFpQixpQkFBaUIsR0FBR2pCLFNBQVFrQixjQUFjLEdBQUdsQixTQUFRbUIsaUJBQWlCLEdBQUduQixTQUFRb0IsaUJBQWlCLEdBQUdwQixTQUFRcUIsbUJBQW1CLEdBQUdyQixTQUFRc0IsR0FBRyxHQUFHdEIsU0FBUXVCLG1CQUFtQixHQUFHdkIsU0FBUXdCLHVCQUF1QixHQUFHeEIsU0FBUXlCLFdBQVcsR0FBR3pCLFNBQVEwQixtQkFBbUIsR0FBRzFCLFNBQVEyQixtQkFBbUIsR0FBRzNCLFNBQVE0QixTQUFTLEdBQUc1QixTQUFRNkIsZUFBZSxHQUFHN0IsU0FBUThCLFdBQVcsR0FBRzlCLFNBQVErQixXQUFXLEdBQUcvQixTQUFRZ0Msb0JBQW9CLEdBQUdoQyxTQUFRaUMsdUJBQXVCLEdBQUdqQyxTQUFRa0MsbUJBQW1CLEdBQUdsQyxTQUFRbUMsYUFBYSxHQUFHbkMsU0FBUW9D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QUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFHO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFPO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFRO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFPO29CQUFHO2lCQUFPO2dCQUN4ckIsU0FBUzdXLG1CQUFrQmtSLElBQUc7b0JBQzVCLElBQUlBLElBQUcsQ0FBQyxFQUFFLElBQUksUUFBUTt3QkFDcEIsSUFBSTRGO3dCQUNKLElBQUk1RixJQUFHLENBQUMsRUFBRSxLQUFLLFVBQVVBLElBQUcsQ0FBQyxFQUFFLEtBQUssUUFBUTs0QkFDMUM0RixZQUFXO3dCQUNiLE9BQU8sSUFBSTVGLElBQUcsQ0FBQyxFQUFFLEtBQUssVUFBVUEsSUFBRyxDQUFDLEVBQUUsS0FBSyxRQUFROzRCQUNqRDRGLFlBQVc7d0JBQ2IsT0FBTyxJQUFJNUYsSUFBRyxDQUFDLEVBQUUsS0FBSyxVQUFVQSxJQUFH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QkFDSCxPQUFPNnVGLE1BQUtydEYsT0FBTztnQkFDckI7WUFDRjtZQUNBLElBQUlDLFNBQVFsQixvQkFBb0I7WUFDaEMsSUFBSXN1RixRQUFPdHVGLG9CQUFvQjtZQUMvQixJQUFJb0Isa0JBQWlCcEIsb0JBQW9CO1lBQ3pDLElBQUl1dUYsZUFBY3Z1RixvQkFBb0I7WUFDdEMsSUFBSXF1Riw0QkFBMkJydUYsb0JBQW9CO1lBQ25ELElBQUk4ZixVQUFTOWYsb0JBQW9CO1lBQ2pDLElBQUkwcUUscUJBQW9CMXFFLG9CQUFvQjtZQUM1QyxJQUFJd0IsbUJBQWtCeEIsb0JBQW9CO1lBQzFDLElBQUltdUUsY0FBYW51RSxvQkFBb0I7WUFDckMsTUFBTXd1RixnQkFBZTtZQUNyQixNQUFNQyxjQUFhO1FBQ25CO1FBRUEsTUFBTSxHQUFJLE9BQU9MLDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQsSUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udC1kb29yLy4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLmpzPzdhYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMyBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicGRmanMtZGlzdC9idWlsZC9wZGZcIiwgW10sICgpID0+IHsgcmV0dXJuIChyb290LnBkZmpzTGliID0gZmFjdG9yeSgpKTsgfSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiXSA9IHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xufSkoZ2xvYmFsVGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi8sXG4vKiAxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5VdGlsID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IGV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBleHBvcnRzLlJlbmRlcmluZ0ludGVudEZsYWcgPSBleHBvcnRzLlByb21pc2VDYXBhYmlsaXR5ID0gZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IGV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBleHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBleHBvcnRzLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gZXhwb3J0cy5MSU5FX0ZBQ1RPUiA9IGV4cG9ydHMuTElORV9ERVNDRU5UX0ZBQ1RPUiA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW1hZ2VLaW5kID0gZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkZvcm1hdEVycm9yID0gZXhwb3J0cy5GZWF0dXJlVGVzdCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gZXhwb3J0cy5CQVNFTElORV9GQUNUT1IgPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBleHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBjcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuZXhwb3J0cy5nZXRNb2RpZmljYXRpb25EYXRlID0gZ2V0TW9kaWZpY2F0aW9uRGF0ZTtcbmV4cG9ydHMuZ2V0VXVpZCA9IGdldFV1aWQ7XG5leHBvcnRzLmdldFZlcmJvc2l0eUxldmVsID0gZ2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLmluZm8gPSBpbmZvO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuZXhwb3J0cy5pc05vZGVKUyA9IHZvaWQgMDtcbmV4cG9ydHMubm9ybWFsaXplVW5pY29kZSA9IG5vcm1hbGl6ZVVuaWNvZGU7XG5leHBvcnRzLm9iamVjdEZyb21NYXAgPSBvYmplY3RGcm9tTWFwO1xuZXhwb3J0cy5vYmplY3RTaXplID0gb2JqZWN0U2l6ZTtcbmV4cG9ydHMuc2V0VmVyYm9zaXR5TGV2ZWwgPSBzZXRWZXJib3NpdHlMZXZlbDtcbmV4cG9ydHMuc2hhZG93ID0gc2hhZG93O1xuZXhwb3J0cy5zdHJpbmczMiA9IHN0cmluZzMyO1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuc3RyaW5nVG9QREZTdHJpbmcgPSBzdHJpbmdUb1BERlN0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9VVEY4U3RyaW5nID0gc3RyaW5nVG9VVEY4U3RyaW5nO1xuZXhwb3J0cy51bnJlYWNoYWJsZSA9IHVucmVhY2hhYmxlO1xuZXhwb3J0cy51dGY4U3RyaW5nVG9TdHJpbmcgPSB1dGY4U3RyaW5nVG9TdHJpbmc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmV4cG9ydHMuaXNOb2RlSlMgPSBpc05vZGVKUztcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gSURFTlRJVFlfTUFUUklYO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbmNvbnN0IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gMTBlNjtcbmV4cG9ydHMuTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUgPSBNQVhfSU1BR0VfU0laRV9UT19DQUNIRTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmV4cG9ydHMuTElORV9GQUNUT1IgPSBMSU5FX0ZBQ1RPUjtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuZXhwb3J0cy5MSU5FX0RFU0NFTlRfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUjtcbmNvbnN0IEJBU0VMSU5FX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1IgLyBMSU5FX0ZBQ1RPUjtcbmV4cG9ydHMuQkFTRUxJTkVfRkFDVE9SID0gQkFTRUxJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5leHBvcnRzLlJlbmRlcmluZ0ludGVudEZsYWcgPSBSZW5kZXJpbmdJbnRlbnRGbGFnO1xuY29uc3QgQW5ub3RhdGlvbk1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0ZPUk1TOiAyLFxuICBFTkFCTEVfU1RPUkFHRTogM1xufTtcbmV4cG9ydHMuQW5ub3RhdGlvbk1vZGUgPSBBbm5vdGF0aW9uTW9kZTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2VkaXRvcl9cIjtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IEFubm90YXRpb25FZGl0b3JQcmVmaXg7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHtcbiAgRElTQUJMRTogLTEsXG4gIE5PTkU6IDAsXG4gIEZSRUVURVhUOiAzLFxuICBTVEFNUDogMTMsXG4gIElOSzogMTVcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGU7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xuY29uc3QgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5leHBvcnRzLlBlcm1pc3Npb25GbGFnID0gUGVybWlzc2lvbkZsYWc7XG5jb25zdCBUZXh0UmVuZGVyaW5nTW9kZSA9IHtcbiAgRklMTDogMCxcbiAgU1RST0tFOiAxLFxuICBGSUxMX1NUUk9LRTogMixcbiAgSU5WSVNJQkxFOiAzLFxuICBGSUxMX0FERF9UT19QQVRIOiA0LFxuICBTVFJPS0VfQUREX1RPX1BBVEg6IDUsXG4gIEZJTExfU1RST0tFX0FERF9UT19QQVRIOiA2LFxuICBBRERfVE9fUEFUSDogNyxcbiAgRklMTF9TVFJPS0VfTUFTSzogMyxcbiAgQUREX1RPX1BBVEhfRkxBRzogNFxufTtcbmV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZTtcbmNvbnN0IEltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcbmV4cG9ydHMuSW1hZ2VLaW5kID0gSW1hZ2VLaW5kO1xuY29uc3QgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IEFubm90YXRpb25UeXBlO1xuY29uc3QgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gQW5ub3RhdGlvblJlcGx5VHlwZTtcbmNvbnN0IEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IEFubm90YXRpb25GbGFnO1xuY29uc3QgQW5ub3RhdGlvbkZpZWxkRmxhZyA9IHtcbiAgUkVBRE9OTFk6IDB4MDAwMDAwMSxcbiAgUkVRVUlSRUQ6IDB4MDAwMDAwMixcbiAgTk9FWFBPUlQ6IDB4MDAwMDAwNCxcbiAgTVVMVElMSU5FOiAweDAwMDEwMDAsXG4gIFBBU1NXT1JEOiAweDAwMDIwMDAsXG4gIE5PVE9HR0xFVE9PRkY6IDB4MDAwNDAwMCxcbiAgUkFESU86IDB4MDAwODAwMCxcbiAgUFVTSEJVVFRPTjogMHgwMDEwMDAwLFxuICBDT01CTzogMHgwMDIwMDAwLFxuICBFRElUOiAweDAwNDAwMDAsXG4gIFNPUlQ6IDB4MDA4MDAwMCxcbiAgRklMRVNFTEVDVDogMHgwMTAwMDAwLFxuICBNVUxUSVNFTEVDVDogMHgwMjAwMDAwLFxuICBET05PVFNQRUxMQ0hFQ0s6IDB4MDQwMDAwMCxcbiAgRE9OT1RTQ1JPTEw6IDB4MDgwMDAwMCxcbiAgQ09NQjogMHgxMDAwMDAwLFxuICBSSUNIVEVYVDogMHgyMDAwMDAwLFxuICBSQURJT1NJTlVOSVNPTjogMHgyMDAwMDAwLFxuICBDT01NSVRPTlNFTENIQU5HRTogMHg0MDAwMDAwXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uRmllbGRGbGFnID0gQW5ub3RhdGlvbkZpZWxkRmxhZztcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5leHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlO1xuY29uc3QgQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgRTogXCJNb3VzZSBFbnRlclwiLFxuICBYOiBcIk1vdXNlIEV4aXRcIixcbiAgRDogXCJNb3VzZSBEb3duXCIsXG4gIFU6IFwiTW91c2UgVXBcIixcbiAgRm86IFwiRm9jdXNcIixcbiAgQmw6IFwiQmx1clwiLFxuICBQTzogXCJQYWdlT3BlblwiLFxuICBQQzogXCJQYWdlQ2xvc2VcIixcbiAgUFY6IFwiUGFnZVZpc2libGVcIixcbiAgUEk6IFwiUGFnZUludmlzaWJsZVwiLFxuICBLOiBcIktleXN0cm9rZVwiLFxuICBGOiBcIkZvcm1hdFwiLFxuICBWOiBcIlZhbGlkYXRlXCIsXG4gIEM6IFwiQ2FsY3VsYXRlXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSB7XG4gIFdDOiBcIldpbGxDbG9zZVwiLFxuICBXUzogXCJXaWxsU2F2ZVwiLFxuICBEUzogXCJEaWRTYXZlXCIsXG4gIFdQOiBcIldpbGxQcmludFwiLFxuICBEUDogXCJEaWRQcmludFwiXG59O1xuZXhwb3J0cy5Eb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgUGFnZUFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgTzogXCJQYWdlT3BlblwiLFxuICBDOiBcIlBhZ2VDbG9zZVwiXG59O1xuZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gUGFnZUFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsID0ge1xuICBFUlJPUlM6IDAsXG4gIFdBUk5JTkdTOiAxLFxuICBJTkZPUzogNVxufTtcbmV4cG9ydHMuVmVyYm9zaXR5TGV2ZWwgPSBWZXJib3NpdHlMZXZlbDtcbmNvbnN0IENNYXBDb21wcmVzc2lvblR5cGUgPSB7XG4gIE5PTkU6IDAsXG4gIEJJTkFSWTogMVxufTtcbmV4cG9ydHMuQ01hcENvbXByZXNzaW9uVHlwZSA9IENNYXBDb21wcmVzc2lvblR5cGU7XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbmNvbnN0IFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5leHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gUGFzc3dvcmRSZXNwb25zZXM7XG5sZXQgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmVyYm9zaXR5TGV2ZWwoKSB7XG4gIHJldHVybiB2ZXJib3NpdHk7XG59XG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coYEluZm86ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFkZERlZmF1bHRQcm90b2NvbCAmJiB1cmwuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgICBpZiAoZG90cz8ubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICB1cmwgPSBgaHR0cDovLyR7dXJsfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSwgbm9uU2VyaWFsaXphYmxlID0gZmFsc2UpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIHZhbHVlLFxuICAgIGVudW1lcmFibGU6ICFub25TZXJpYWxpemFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEJhc2VFeGNlcHRpb25DbG9zdXJlKCkge1xuICBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUV4Y2VwdGlvbikge1xuICAgICAgdW5yZWFjaGFibGUoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlRXhjZXB0aW9uLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oKTtcbmV4cG9ydHMuQmFzZUV4Y2VwdGlvbiA9IEJhc2VFeGNlcHRpb247XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IFBhc3N3b3JkRXhjZXB0aW9uO1xuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBVbmtub3duRXJyb3JFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5leHBvcnRzLkludmFsaWRQREZFeGNlcHRpb24gPSBJbnZhbGlkUERGRXhjZXB0aW9uO1xuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0cy5NaXNzaW5nUERGRXhjZXB0aW9uID0gTWlzc2luZ1BERkV4Y2VwdGlvbjtcbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5leHBvcnRzLkZvcm1hdEVycm9yID0gRm9ybWF0RXJyb3I7XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBBYm9ydEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG9iamVjdEZyb21NYXAobWFwKSB7XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBGZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0V2YWxTdXBwb3J0ZWRcIiwgaXNFdmFsU3VwcG9ydGVkKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXCIsIHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09IFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICAgIGlzV2luOiBmYWxzZSxcbiAgICAgICAgaXNNYWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgIGlzV2luOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc01hYzogbmF2aWdhdG9yLnBsYXRmb3JtLmluY2x1ZGVzKFwiTWFjXCIpXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuZXhwb3J0cy5GZWF0dXJlVGVzdCA9IEZlYXR1cmVUZXN0O1xuY29uc3QgaGV4TnVtYmVycyA9IFsuLi5BcnJheSgyNTYpLmtleXMoKV0ubWFwKG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs1XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgIGNvbnN0IHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIGNvbnN0IHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgY29uc3QgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChyLCBtKSB7XG4gICAgY29uc3QgcDEgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIsIG0pO1xuICAgIGNvbnN0IHAyID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLnNsaWNlKDIsIDQpLCBtKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMF0sIHJbM11dLCBtKTtcbiAgICBjb25zdCBwNCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMl0sIHJbMV1dLCBtKTtcbiAgICByZXR1cm4gW01hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5taW4ocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLCBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKV07XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICBjb25zdCB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgY29uc3QgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiogMiAtIDQgKiAoYSAqIGQgLSBjICogYikpIC8gMjtcbiAgICBjb25zdCBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgY29uc3Qgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuICAgIHJldHVybiBbTWF0aC5zcXJ0KHN4KSwgTWF0aC5zcXJ0KHN5KV07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICBjb25zdCB0dmFsdWVzID0gW10sXG4gICAgICBib3VuZHMgPSBbW10sIFtdXTtcbiAgICBsZXQgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaiA9IHR2YWx1ZXMubGVuZ3RoLFxuICAgICAgbXQ7XG4gICAgY29uc3QgamxlbiA9IGo7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDAgKyAzICogbXQgKiBtdCAqIHQgKiB4MSArIDMgKiBtdCAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkwICsgMyAqIG10ICogbXQgKiB0ICogeTEgKyAzICogbXQgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gICAgfVxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgYm91bmRzWzBdLmxlbmd0aCA9IGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcbiAgICByZXR1cm4gW01hdGgubWluKC4uLmJvdW5kc1swXSksIE1hdGgubWluKC4uLmJvdW5kc1sxXSksIE1hdGgubWF4KC4uLmJvdW5kc1swXSksIE1hdGgubWF4KC4uLmJvdW5kc1sxXSldO1xuICB9XG59XG5leHBvcnRzLlV0aWwgPSBVdGlsO1xuY29uc3QgUERGU3RyaW5nVHJhbnNsYXRlVGFibGUgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyZDgsIDB4MmM3LCAweDJjNiwgMHgyZDksIDB4MmRkLCAweDJkYiwgMHgyZGEsIDB4MmRjLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDIwMjIsIDB4MjAyMCwgMHgyMDIxLCAweDIwMjYsIDB4MjAxNCwgMHgyMDEzLCAweDE5MiwgMHgyMDQ0LCAweDIwMzksIDB4MjAzYSwgMHgyMjEyLCAweDIwMzAsIDB4MjAxZSwgMHgyMDFjLCAweDIwMWQsIDB4MjAxOCwgMHgyMDE5LCAweDIwMWEsIDB4MjEyMiwgMHhmYjAxLCAweGZiMDIsIDB4MTQxLCAweDE1MiwgMHgxNjAsIDB4MTc4LCAweDE3ZCwgMHgxMzEsIDB4MTQyLCAweDE1MywgMHgxNjEsIDB4MTdlLCAwLCAweDIwYWNdO1xuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyKSB7XG4gIGlmIChzdHJbMF0gPj0gXCJcXHhFRlwiKSB7XG4gICAgbGV0IGVuY29kaW5nO1xuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmJlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHN0cik7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgd2Fybihgc3RyaW5nVG9QREZTdHJpbmc6IFwiJHtleH1cIi5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHY/LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChhcnIxLCBhcnIyKSB7XG4gIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGRhdGUgPSBuZXcgRGF0ZSgpKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IFtkYXRlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0RhdGUoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENTZWNvbmRzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIildO1xuICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG59XG5jbGFzcyBQcm9taXNlQ2FwYWJpbGl0eSB7XG4gICNzZXR0bGVkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IGRhdGEgPT4ge1xuICAgICAgICB0aGlzLiNzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuI3NldHRsZWQgPSB0cnVlO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHNldHRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NldHRsZWQ7XG4gIH1cbn1cbmV4cG9ydHMuUHJvbWlzZUNhcGFiaWxpdHkgPSBQcm9taXNlQ2FwYWJpbGl0eTtcbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiB7XG4gICAgcmV0dXJuIHAxID8gcDEubm9ybWFsaXplKFwiTkZLQ1wiKSA6IE5vcm1hbGl6YXRpb25NYXAuZ2V0KHAyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRVdWlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5yYW5kb21VVUlEID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgYnVmW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcoYnVmKTtcbn1cbmNvbnN0IEFubm90YXRpb25QcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2lkX1wiO1xuZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gQW5ub3RhdGlvblByZWZpeDtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlJlbmRlclRhc2sgPSBleHBvcnRzLlBERldvcmtlclV0aWwgPSBleHBvcnRzLlBERldvcmtlciA9IGV4cG9ydHMuUERGUGFnZVByb3h5ID0gZXhwb3J0cy5QREZEb2N1bWVudFByb3h5ID0gZXhwb3J0cy5QREZEb2N1bWVudExvYWRpbmdUYXNrID0gZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBleHBvcnRzLkxvb3BiYWNrUG9ydCA9IGV4cG9ydHMuRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0RmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheVN2Zy5TVkdHcmFwaGljcztcbiAgfVxufSkpO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudDtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF9mb250X2xvYWRlciA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgX2Rpc3BsYXlOb2RlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgX2NhbnZhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciBfbWV0YWRhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbnZhciBfb3B0aW9uYWxfY29udGVudF9jb25maWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xudmFyIF9kaXNwbGF5RmV0Y2hfc3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgX2Rpc3BsYXlOZXR3b3JrID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgX2Rpc3BsYXlOb2RlX3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIF9kaXNwbGF5U3ZnID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG5jb25zdCBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmNvbnN0IERFTEFZRURfQ0xFQU5VUF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNhbnZhc0ZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01DYW52YXNGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IERlZmF1bHRDYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUZpbHRlckZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01GaWx0ZXJGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0RmlsdGVyRmFjdG9yeSA9IERlZmF1bHRGaWx0ZXJGYWN0b3J5O1xuY29uc3QgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3JjICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIG5lZWQgcGFyYW1ldGVyIG9iamVjdC5cIik7XG4gIH1cbiAgaWYgKCFzcmMudXJsICYmICFzcmMuZGF0YSAmJiAhc3JjLnJhbmdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBQREZEb2N1bWVudExvYWRpbmdUYXNrKCk7XG4gIGNvbnN0IHtcbiAgICBkb2NJZFxuICB9ID0gdGFzaztcbiAgY29uc3QgdXJsID0gc3JjLnVybCA/IGdldFVybFByb3Aoc3JjLnVybCkgOiBudWxsO1xuICBjb25zdCBkYXRhID0gc3JjLmRhdGEgPyBnZXREYXRhUHJvcChzcmMuZGF0YSkgOiBudWxsO1xuICBjb25zdCBodHRwSGVhZGVycyA9IHNyYy5odHRwSGVhZGVycyB8fCBudWxsO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBzcmMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlO1xuICBjb25zdCBwYXNzd29yZCA9IHNyYy5wYXNzd29yZCA/PyBudWxsO1xuICBjb25zdCByYW5nZVRyYW5zcG9ydCA9IHNyYy5yYW5nZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA/IHNyYy5yYW5nZSA6IG51bGw7XG4gIGNvbnN0IHJhbmdlQ2h1bmtTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMucmFuZ2VDaHVua1NpemUpICYmIHNyYy5yYW5nZUNodW5rU2l6ZSA+IDAgPyBzcmMucmFuZ2VDaHVua1NpemUgOiBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkU7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgISgwLCBfZGlzcGxheV91dGlscy5pc0RhdGFTY2hlbWUpKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFfdXRpbC5pc05vZGVKUztcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IF91dGlsLmlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFfdXRpbC5pc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogQ01hcFJlYWRlckZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBfZGlzcGxheV91dGlscy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSBzcmMuY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IGZpbHRlckZhY3RvcnkgPSBzcmMuZmlsdGVyRmFjdG9yeSB8fCBuZXcgRGVmYXVsdEZpbHRlckZhY3Rvcnkoe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkodmVyYm9zaXR5KTtcbiAgY29uc3QgdHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnlcbiAgfTtcbiAgaWYgKCF1c2VXb3JrZXJGZXRjaCkge1xuICAgIHRyYW5zcG9ydEZhY3RvcnkuY01hcFJlYWRlckZhY3RvcnkgPSBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pO1xuICAgIHRyYW5zcG9ydEZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pO1xuICB9XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZmV0Y2hEb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzMuMTEuMTc0JyxcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGlnbm9yZUVycm9ycyxcbiAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgZW5hYmxlWGZhLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIGZldGNoRG9jUGFyYW1zKTtcbiAgICBjb25zdCBuZXR3b3JrU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcmFuZ2VUcmFuc3BvcnQuaW5pdGlhbERhdGEsXG4gICAgICAgICAgcHJvZ3Jlc3NpdmVEb25lOiByYW5nZVRyYW5zcG9ydC5wcm9ncmVzc2l2ZURvbmUsXG4gICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHJhbmdlVHJhbnNwb3J0LmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0sIHJhbmdlVHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlUERGTmV0d29ya1N0cmVhbSA9IHBhcmFtcyA9PiB7XG4gICAgICAgICAgaWYgKF91dGlsLmlzTm9kZUpTKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9kaXNwbGF5Tm9kZV9zdHJlYW0uUERGTm9kZVN0cmVhbShwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkgPyBuZXcgX2Rpc3BsYXlGZXRjaF9zdHJlYW0uUERGRmV0Y2hTdHJlYW0ocGFyYW1zKSA6IG5ldyBfZGlzcGxheU5ldHdvcmsuUERGTmV0d29ya1N0cmVhbShwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gY3JlYXRlUERGTmV0d29ya1N0cmVhbSh7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldHdvcmtTdHJlYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbd29ya2VySWRQcm9taXNlLCBuZXR3b3JrU3RyZWFtUHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKFt3b3JrZXJJZCwgbmV0d29ya1N0cmVhbV0pIHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5KTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mZXRjaERvY3VtZW50KHdvcmtlciwgc291cmNlKSB7XG4gIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gIH1cbiAgY29uc3Qgd29ya2VySWQgPSBhd2FpdCB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBzb3VyY2UsIHNvdXJjZS5kYXRhID8gW3NvdXJjZS5kYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgfVxuICByZXR1cm4gd29ya2VySWQ7XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLCB3aW5kb3cubG9jYXRpb24pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpIHx8ICgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciBUeXBlZEFycmF5LCBcIiArIFwic3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERkRvY3VtZW50TG9hZGluZ1Rhc2sgPSBQREZEb2N1bWVudExvYWRpbmdUYXNrO1xuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICB9XG4gIGFkZFJhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9yYW5nZUxpc3RlbmVycykge1xuICAgICAgbGlzdGVuZXIoYmVnaW4sIGNodW5rKTtcbiAgICB9XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihsb2FkZWQsIHRvdGFsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRyYW5zcG9ydFJlYWR5KCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5leHBvcnRzLlBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IFBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0SmF2YVNjcmlwdFwiLCB7XG4gICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJgUERGRG9jdW1lbnRQcm94eS5nZXRKYXZhU2NyaXB0YCwgXCIgKyBcInBsZWFzZSB1c2UgYFBERkRvY3VtZW50UHJveHkuZ2V0SlNBY3Rpb25zYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SlNBY3Rpb25zKCkudGhlbihqcyA9PiB7XG4gICAgICAgICAgaWYgKCFqcykge1xuICAgICAgICAgICAgcmV0dXJuIGpzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBqc0FyciA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBqcykge1xuICAgICAgICAgICAganNBcnIucHVzaCguLi5qc1tuYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBqc0FycjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuICBnZXQgZmluZ2VycHJpbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50cztcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3V0bGluZSgpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuICBnZXRNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1ldGFkYXRhKCk7XG4gIH1cbiAgZ2V0TWFya0luZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNYXJrSW5mbygpO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cbiAgc2F2ZURvY3VtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cbiAgZ2V0RG93bmxvYWRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgfHwgdGhpcy5pc1B1cmVYZmEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5leHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBQREZEb2N1bWVudFByb3h5O1xuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgX2Rpc3BsYXlfdXRpbHMuUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIGludGVudEFyZ3MucmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGZpbHRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5O1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9zdGF0cz8udGltZShcIk92ZXJhbGxcIik7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSk7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCFvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlKSB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZygpO1xuICAgIH1cbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGludGVudFByaW50ID0gISEoaW50ZW50QXJncy5yZW5kZXJpbmdJbnRlbnQgJiBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgaWYgKHRoaXMuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyIHx8IGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoIWludGVudFByaW50KTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICB9LFxuICAgICAgb2JqczogdGhpcy5vYmpzLFxuICAgICAgY29tbW9uT2JqczogdGhpcy5jb21tb25PYmpzLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIG9wZXJhdG9yTGlzdDogaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBjYW52YXNGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5maWx0ZXJGYWN0b3J5LFxuICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAhaW50ZW50UHJpbnQsXG4gICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1ZyxcbiAgICAgIHBhZ2VDb2xvcnNcbiAgICB9KTtcbiAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgY29uc3QgcmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzay50YXNrO1xuICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKChbdHJhbnNwYXJlbmN5LCBvcHRpb25hbENvbnRlbnRDb25maWddKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJSZW5kZXJpbmdcIik7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2suaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgIH0pO1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9KS5jYXRjaChjb21wbGV0ZSk7XG4gICAgcmV0dXJuIHJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIHRydWUpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcExpc3RUYXNrO1xuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAoaW50ZW50U3RhdGUucmVuZGVyVGFza3MgfHw9IG5ldyBTZXQoKSkuYWRkKG9wTGlzdFRhc2spO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBpbmNsdWRlTWFya2VkQ29udGVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVOb3JtYWxpemF0aW9uID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQocGFyYW1zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRYZmEoKS50aGVuKHhmYSA9PiB7XG4gICAgICAgIHJldHVybiBfeGZhX3RleHQuWGZhVGV4dC50ZXh0Q29udGVudCh4ZmEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB7XG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9O1xuICAgICAgcHVtcCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRTdHJ1Y3RUcmVlKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cbiAgX2Rlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICBpZiAocmVzZXRTdGF0cyAmJiBzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9zdGF0cyAmJj0gbmV3IF9kaXNwbGF5X3V0aWxzLlN0YXRUaW1lcigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VjY2VzcztcbiAgfVxuICAjdHJ5Q2xlYW51cChkZWxheWVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVsYXllZCkge1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgICAgfSwgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI2Fib3J0RGVsYXllZENsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCk7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcFxuICAgIH0sIHRyYW5zZmVycyk7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHB1bXAoKTtcbiAgfVxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmV4cG9ydHMuUERGUGFnZVByb3h5ID0gUERGUGFnZVByb3h5O1xuY2xhc3MgTG9vcGJhY2tQb3J0IHtcbiAgI2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgI2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXIpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGRhdGE6IHN0cnVjdHVyZWRDbG9uZShvYmosIHRyYW5zZmVyID8ge1xuICAgICAgICB0cmFuc2ZlclxuICAgICAgfSA6IG51bGwpXG4gICAgfTtcbiAgICB0aGlzLiNkZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIHRoaXMuI2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcbmNvbnN0IFBERldvcmtlclV0aWwgPSB7XG4gIGlzV29ya2VyRGlzYWJsZWQ6IGZhbHNlLFxuICBmYWxsYmFja1dvcmtlclNyYzogbnVsbCxcbiAgZmFrZVdvcmtlcklkOiAwXG59O1xuZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gUERGV29ya2VyVXRpbDtcbntcbiAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmMgPSBcIi4vcGRmLndvcmtlci5qc1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHBkZmpzRmlsZVBhdGggPSBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjO1xuICAgIGlmIChwZGZqc0ZpbGVQYXRoKSB7XG4gICAgICBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjID0gcGRmanNGaWxlUGF0aC5yZXBsYWNlKC8oXFwuKD86bWluXFwuKT9qcykoXFw/LiopPyQvaSwgXCIud29ya2VyJDEkMlwiKTtcbiAgICB9XG4gIH1cbiAgUERGV29ya2VyVXRpbC5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAoYmFzZVVybCwgb3RoZXJVcmwpIHtcbiAgICBsZXQgYmFzZTtcbiAgICB0cnkge1xuICAgICAgYmFzZSA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2Uub3JpZ2luIHx8IGJhc2Uub3JpZ2luID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gIH07XG4gIFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gYGltcG9ydFNjcmlwdHMoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0pKTtcbiAgfTtcbn1cbmNsYXNzIFBERldvcmtlciB7XG4gIHN0YXRpYyAjd29ya2VyUG9ydHM7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lID0gbnVsbCxcbiAgICBwb3J0ID0gbnVsbCxcbiAgICB2ZXJib3NpdHkgPSAoMCwgX3V0aWwuZ2V0VmVyYm9zaXR5TGV2ZWwpKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgKFBERldvcmtlci4jd29ya2VyUG9ydHMgfHw9IG5ldyBXZWFrTWFwKCkpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgJiYgIVBERldvcmtlci5fbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICBsZXQge1xuICAgICAgICB3b3JrZXJTcmNcbiAgICAgIH0gPSBQREZXb3JrZXI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIVBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyVXRpbC5jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBERldvcmtlci5fc2V0dXBGYWtlV29ya2VyR2xvYmFsLnRoZW4oV29ya2VyTWVzc2FnZUhhbmRsZXIgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgICBjb25zdCBpZCA9IGBmYWtlJHtQREZXb3JrZXJVdGlsLmZha2VXb3JrZXJJZCsrfWA7XG4gICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3dlYldvcmtlcikge1xuICAgICAgdGhpcy5fd2ViV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB9XG4gICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uZGVsZXRlKHRoaXMuX3BvcnQpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVBvcnQocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFBvcnQgPSB0aGlzLiN3b3JrZXJQb3J0cz8uZ2V0KHBhcmFtcy5wb3J0KTtcbiAgICBpZiAoY2FjaGVkUG9ydCkge1xuICAgICAgaWYgKGNhY2hlZFBvcnQuX3BlbmRpbmdEZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblwiICsgXCJQbGVhc2UgcmVtZW1iZXIgdG8gYXdhaXQgYFBERkRvY3VtZW50TG9hZGluZ1Rhc2suZGVzdHJveSgpYC1jYWxscy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkUG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICBpZiAoUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRoaXMuX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIGlmIChtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGV2YWwoXCJyZXF1aXJlXCIpKHRoaXMud29ya2VyU3JjKTtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0ICgwLCBfZGlzcGxheV91dGlscy5sb2FkU2NyaXB0KSh0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd2luZG93LnBkZmpzV29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn1cbmV4cG9ydHMuUERGV29ya2VyID0gUERGV29ya2VyO1xuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnkpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IF9mb250X2xvYWRlci5Gb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgZGF0YSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgX2Fubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IF9hbm5vdGF0aW9uX3N0b3JhZ2UuU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgc3dpdGNoIChpbnRlbnQpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTlk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHJpbnRcIjpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoMCwgX3V0aWwud2FybikoYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX3N0b3JhZ2UuUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAoMCwgX3V0aWwud2FybikoYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgYW5ub3RhdGlvbk1vZGU6ICR7YW5ub3RhdGlvbk1vZGV9YCk7XG4gICAgfVxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXk6IGAke3JlbmRlcmluZ0ludGVudH1fJHthbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZS5oYXNofWAsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZVxuICAgIH07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHk/LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZCBkdXJpbmcgb25QYXNzd29yZCBjYWxsYmFja1wiKSk7XG4gICAgY29uc3Qgd2FpdE9uID0gW107XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG4gICAgdGhpcy4jcGFnZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoXCJhbm5vdGF0aW9uU3RvcmFnZVwiKSkge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9LCB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzZXR1cE1lc3NhZ2VIYW5kbGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLFxuICAgICAgbG9hZGluZ1Rhc2tcbiAgICB9ID0gdGhpcztcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICBjb25zdCBoZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgY29uc3QgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZWFkZXI7XG4gICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCFmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkIHx8ICFmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4odGhpcy5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZDogZnVsbFJlYWRlci5pc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgY29udGVudExlbmd0aDogZnVsbFJlYWRlci5jb250ZW50TGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiBoZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSYW5nZVJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlc29sdmUobmV3IFBERkRvY3VtZW50UHJveHkocGRmSW5mbywgdGhpcykpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jRXhjZXB0aW9uXCIsIGZ1bmN0aW9uIChleCkge1xuICAgICAgbGV0IHJlYXNvbjtcbiAgICAgIHN3aXRjaCAoZXgubmFtZSkge1xuICAgICAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLkludmFsaWRQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJEb2NFeGNlcHRpb24gLSBleHBlY3RlZCBhIHZhbGlkIEVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4Y2VwdGlvbiA9PiB7XG4gICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIGlmIChsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gcGFzc3dvcmQgPT4ge1xuICAgICAgICAgIGlmIChwYXNzd29yZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KHBhc3N3b3JkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEYXRhTG9hZGVkXCIsIGRhdGEgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KGRhdGEucGFnZUluZGV4KTtcbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbW1vbk9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9wYXJhbXM7XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpbnNwZWN0Rm9udCA9IHBhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IF9mb250X2xvYWRlci5Gb250RmFjZU9iamVjdChleHBvcnRlZERhdGEsIHtcbiAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCxcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZTogcGFyYW1zLmRpc2FibGVGb250RmFjZSxcbiAgICAgICAgICAgIGlnbm9yZUVycm9yczogcGFyYW1zLmlnbm9yZUVycm9ycyxcbiAgICAgICAgICAgIGluc3BlY3RGb250XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGZvbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRm9udFBhdGhcIjpcbiAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGlmIChpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhLmJpdG1hcCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgICAgIH0gPSBpbWFnZURhdGE7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IGltYWdlRGF0YS5kYXRhPy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBfdXRpbC5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSkge1xuICAgICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaFN0YW5kYXJkRm9udERhdGFcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXJzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm9iamVjdFwiIHx8IHJlZiA9PT0gbnVsbCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYubnVtKSB8fCByZWYubnVtIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYuZ2VuKSB8fCByZWYuZ2VuIDwgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBfbWV0YWRhdGEuTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH0gPSB0aGlzLl9wYXJhbXM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwibG9hZGluZ1BhcmFtc1wiLCB7XG4gICAgICBkaXNhYmxlQXV0b0ZldGNoLFxuICAgICAgZW5hYmxlWGZhXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICNlbnN1cmVPYmoob2JqSWQpIHtcbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gfHw9IHtcbiAgICAgIGNhcGFiaWxpdHk6IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgZGF0YTogbnVsbFxuICAgIH07XG4gIH1cbiAgZ2V0KG9iaklkLCBjYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmouY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIG9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkIHx8IGZhbHNlO1xuICB9XG4gIHJlc29sdmUob2JqSWQsIGRhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jZW5zdXJlT2JqKG9iaklkKTtcbiAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgb2JqLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBkYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG59XG5jbGFzcyBSZW5kZXJUYXNrIHtcbiAgI2ludGVybmFsUmVuZGVyVGFzayA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGludGVybmFsUmVuZGVyVGFzaykge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzayA9IGludGVybmFsUmVuZGVyVGFzaztcbiAgICB0aGlzLm9uQ29udGludWUgPSBudWxsO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwobnVsbCwgZXh0cmFEZWxheSk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRlQW5ub3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRlQW5ub3RzXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3Q7XG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzaztcbiAgICByZXR1cm4gc2VwYXJhdGVBbm5vdHMuZm9ybSB8fCBzZXBhcmF0ZUFubm90cy5jYW52YXMgJiYgYW5ub3RhdGlvbkNhbnZhc01hcD8uc2l6ZSA+IDA7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyVGFzayA9IFJlbmRlclRhc2s7XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNhbGxiYWNrLFxuICAgIHBhcmFtcyxcbiAgICBvYmpzLFxuICAgIGNvbW1vbk9ianMsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBvcGVyYXRvckxpc3QsXG4gICAgcGFnZUluZGV4LFxuICAgIGNhbnZhc0ZhY3RvcnksXG4gICAgZmlsdGVyRmFjdG9yeSxcbiAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICBwZGZCdWcgPSBmYWxzZSxcbiAgICBwYWdlQ29sb3JzID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMudGFzayA9IG5ldyBSZW5kZXJUYXNrKHRoaXMpO1xuICAgIHRoaXMuX2NhbmNlbEJvdW5kID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCA9IHRoaXMuX3NjaGVkdWxlTmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX25leHRCb3VuZCA9IHRoaXMuX25leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzQ29udGV4dC5jYW52YXM7XG4gIH1cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG4gIGluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IF9jYW52YXMuQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycyk7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KSk7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RlcHBlcj8udXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gIH1cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICB9XG4gIH1cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIpO1xuICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgdmVyc2lvbiA9ICczLjExLjE3NCc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuY29uc3QgYnVpbGQgPSAnY2U4NzE2NzQzJztcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZUVtcHR5ID0gZXhwb3J0cy5QcmludEFubm90YXRpb25TdG9yYWdlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuY29uc3QgU2VyaWFsaXphYmxlRW1wdHkgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFwOiBudWxsLFxuICBoYXNoOiBcIlwiLFxuICB0cmFuc2ZlcnM6IHVuZGVmaW5lZFxufSk7XG5leHBvcnRzLlNlcmlhbGl6YWJsZUVtcHR5ID0gU2VyaWFsaXphYmxlRW1wdHk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG4gIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuICBnZXRSYXdWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgfVxuICByZW1vdmUoa2V5KSB7XG4gICAgdGhpcy4jc3RvcmFnZS5kZWxldGUoa2V5KTtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuI3N0b3JhZ2UudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IFtlbnRyeSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKG9ialtlbnRyeV0gIT09IHZhbCkge1xuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBvYmpbZW50cnldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI3NldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciAmJiB0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IodmFsdWUuY29uc3RydWN0b3IuX3R5cGUpO1xuICAgIH1cbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuaGFzKGtleSk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemUgPiAwID8gKDAsIF91dGlsLm9iamVjdEZyb21NYXApKHRoaXMuI3N0b3JhZ2UpIDogbnVsbDtcbiAgfVxuICBzZXRBbGwob2JqKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlcnMgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaGFzQml0bWFwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2ZlcnMucHVzaCh2YWx1ZS5iaXRtYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXAuc2l6ZSA+IDAgPyB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoOiBoYXNoLmhleGRpZ2VzdCgpLFxuICAgICAgdHJhbnNmZXJzXG4gICAgfSA6IFNlcmlhbGl6YWJsZUVtcHR5O1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gQW5ub3RhdGlvblN0b3JhZ2U7XG5jbGFzcyBQcmludEFubm90YXRpb25TdG9yYWdlIGV4dGVuZHMgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjc2VyaWFsaXphYmxlO1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVycyA/IHtcbiAgICAgIHRyYW5zZmVyOiB0cmFuc2ZlcnNcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG59XG5leHBvcnRzLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBQcmludEFubm90YXRpb25TdG9yYWdlO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvciA9IHZvaWQgMDtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FsdFRleHQgPSBcIlwiO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2tlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjYm91bmRGb2N1c2luID0gdGhpcy5mb2N1c2luLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3Vzb3V0ID0gdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgX2wxMG5Qcm9taXNlID0gbnVsbDtcbiAgI2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICN6SW5kZXggPSBBbm5vdGF0aW9uRWRpdG9yLl96SW5kZXgrKztcbiAgc3RhdGljIF9ib3JkZXJMaW5lV2lkdGggPSAtMTtcbiAgc3RhdGljIF9jb2xvck1hbmFnZXIgPSBuZXcgX3Rvb2xzLkNvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBTTUFMTF9FRElUT1JfU0laRSA9IDA7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEFubm90YXRpb25FZGl0b3IuXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCBvcHRpb25zID0gbnVsbCkge1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlIHx8PSBuZXcgTWFwKFtcImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWxcIiwgXCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWxcIiwgXCJlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwXCJdLm1hcChzdHIgPT4gW3N0ciwgbDEwbi5nZXQoc3RyKV0pKTtcbiAgICBpZiAob3B0aW9ucz8uc3RyaW5ncykge1xuICAgICAgZm9yIChjb25zdCBzdHIgb2Ygb3B0aW9ucy5zdHJpbmdzKSB7XG4gICAgICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLnNldChzdHIsIGwxMG4uZ2V0KHN0cikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoICE9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLW91dGxpbmUtd2lkdGhcIikpIHx8IDA7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXMoX3R5cGUsIF92YWx1ZSkge31cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdGF0aWMgaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKG1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0IF9pc0RyYWdnYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNEcmFnZ2FibGU7XG4gIH1cbiAgc2V0IF9pc0RyYWdnYWJsZSh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRHJhZ2dhYmxlID0gdmFsdWU7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC50b2dnbGUoXCJkcmFnZ2FibGVcIiwgdmFsdWUpO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5DbGlja2VkKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9jdXNvdXQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKHRhcmdldD8uY2xvc2VzdChgIyR7dGhpcy5pZH1gKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5wYXJlbnQ/LmlzTXVsdGlwbGVTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gIH1cbiAgYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBzZXRBdCh4LCB5LCB0eCwgdHkpIHtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgI3RyYW5zbGF0ZShbd2lkdGgsIGhlaWdodF0sIHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFyZW50RGltZW5zaW9ucywgeCwgeSk7XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLiNnZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gICNnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgd2lkdGggKj0gcGFnZVdpZHRoO1xuICAgIGhlaWdodCAqPSBwYWdlSGVpZ2h0O1xuICAgIHggKj0gcGFnZVdpZHRoO1xuICAgIHkgKj0gcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIHdpZHRoLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gaGVpZ2h0LCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIGhlaWdodCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgod2lkdGgsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgod2lkdGgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KGhlaWdodCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heChoZWlnaHQsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSB3aWR0aCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy54ID0geCAvPSBwYWdlV2lkdGg7XG4gICAgdGhpcy55ID0geSAvPSBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy4jZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBwYWdlV2lkdGggKiBwYXJlbnRTY2FsZTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBwYWdlSGVpZ2h0ICogcGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQgPyBbTWF0aC5yb3VuZChzY2FsZWRXaWR0aCksIE1hdGgucm91bmQoc2NhbGVkSGVpZ2h0KV0gOiBbc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodF07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LmNsYXNzTGlzdC50b2dnbGUoXCJzbWFsbFwiLCB3aWR0aCA8IEFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUgfHwgaGVpZ2h0IDwgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSk7XG4gIH1cbiAgZml4RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSB3aWR0aC5lbmRzV2l0aChcIiVcIik7XG4gICAgY29uc3QgaGVpZ2h0UGVyY2VudCA9ICF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgaGVpZ2h0LmVuZHNXaXRoKFwiJVwiKTtcbiAgICBpZiAod2lkdGhQZXJjZW50ICYmIGhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICghd2lkdGhQZXJjZW50KSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KHdpZHRoKSAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiAhaGVpZ2h0UGVyY2VudCkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl07XG4gICAgaWYgKCF0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJ0b3BNaWRkbGVcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcIm1pZGRsZUxlZnRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSA9IHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBjb25zdCBwb2ludGVyTW92ZU9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICB0aGlzLnggPSBuZXdYO1xuICAgICAgICAgIHRoaXMueSA9IG5ld1k7XG4gICAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBzYXZlZFdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2F2ZWRIZWlnaHQ7XG4gICAgICAgICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgICAgICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogc2F2ZWRXaWR0aCwgcGFyZW50SGVpZ2h0ICogc2F2ZWRIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZCA9IHggPT4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IHJvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IHJvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WSk7XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGgubWF4KG1pbldpZHRoLCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpKSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoLm1heChtaW5IZWlnaHQsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkpKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHJvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGNvbnN0IG1zZyA9IGF3YWl0IEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWxcIik7XG4gICAgYWx0VGV4dC50ZXh0Q29udGVudCA9IG1zZztcbiAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKGFsdFRleHQpO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSkge1xuICAgICAgY29uc3QgUEVSQ0VOVCA9IDQwO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSA9IE1hdGgubWluKDEyOCwgTWF0aC5yb3VuZChhbHRUZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICogKDEgKyBQRVJDRU5UIC8gMTAwKSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWxcIikudGhlbihtc2cgPT4ge1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICB9KTtcbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIGNvbnN0IGlkID0gdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy5pZH1gO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgaWQpO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICAgIHN1YnR5cGU6IHRoaXMuZWRpdG9yVHlwZSxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICB0b29sdGlwLmlubmVyVGV4dCA9IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID8gYXdhaXQgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcFwiKSA6IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoe1xuICAgIGFsdFRleHQsXG4gICAgZGVjb3JhdGl2ZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIHRoaXMuI3NldEFsdFRleHRCdXR0b25TdGF0ZSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAoMCwgX3Rvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IHRydWU7XG4gICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRHJhZ2dhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLl91aU1hbmFnZXIuaXNTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBwb2ludGVyTW92ZU9wdGlvbnMsIHBvaW50ZXJNb3ZlQ2FsbGJhY2s7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHBvaW50ZXJNb3ZlT3B0aW9ucyA9IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHBvaW50ZXJNb3ZlQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGUubW92ZW1lbnRYLCBlLm1vdmVtZW50WSk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBwb2ludGVyTW92ZUNhbGxiYWNrLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuZW5kRHJhZ1Nlc3Npb24oKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaXNNYWNcbiAgICAgICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgfVxuICBtb3ZlSW5ET00oKSB7XG4gICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7fVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFuIGVkaXRvciBtdXN0IGJlIHNlcmlhbGl6YWJsZVwiKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHVpTWFuYWdlclxuICAgIH0pO1xuICAgIGVkaXRvci5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuI2tlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3IgPSBBbm5vdGF0aW9uRWRpdG9yO1xuY2xhc3MgRmFrZUVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgZGVsZXRlZDogdHJ1ZSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXhcbiAgICB9O1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBleHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSB2b2lkIDA7XG5leHBvcnRzLmJpbmRFdmVudHMgPSBiaW5kRXZlbnRzO1xuZXhwb3J0cy5vcGFjaXR5VG9IZXggPSBvcGFjaXR5VG9IZXg7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wYWNpdHlUb0hleChvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMSwgMjU1ICogb3BhY2l0eSkpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGAke191dGlsLkFubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSAoMCwgX3V0aWwuZ2V0VXVpZCkoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJhd0RhdGEpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZyb21VcmwoZGF0YS51cmwpO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnJlZkNvdW50ZXIgLT0gMTtcbiAgICBpZiAoZGF0YS5yZWZDb3VudGVyICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG8oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0uY21kKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cbn1cbmV4cG9ydHMuQ29tbWFuZE1hbmFnZXIgPSBDb21tYW5kTWFuYWdlcjtcbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGZvciAoY29uc3QgW2tleXMsIGNhbGxiYWNrLCBvcHRpb25zID0ge31dIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcbiAgICAgICAgaWYgKGlzTWFjICYmIGlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleS5zbGljZSg0KSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImN0cmxcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwibWV0YVwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goZXZlbnQua2V5KTtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmJ1ZmZlci5qb2luKFwiK1wiKTtcbiAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZXhlYyhzZWxmLCBldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxLZXlzLmhhcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSB0aGlzLmNhbGxiYWNrcy5nZXQodGhpcy4jc2VyaWFsaXplKGV2ZW50KSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBidWJibGVzID0gZmFsc2UsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgY2hlY2tlciA9IG51bGxcbiAgICAgIH1cbiAgICB9ID0gaW5mbztcbiAgICBpZiAoY2hlY2tlciAmJiAhY2hlY2tlcihzZWxmLCBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2suYmluZChzZWxmLCAuLi5hcmdzKSgpO1xuICAgIGlmICghYnViYmxlcykge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBLZXlib2FyZE1hbmFnZXI7XG5jbGFzcyBDb2xvck1hbmFnZXIge1xuICBzdGF0aWMgX2NvbG9yc01hcHBpbmcgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIFswLCAwLCAwXV0sIFtcIkNhbnZhc1wiLCBbMjU1LCAyNTUsIDI1NV1dXSk7XG4gIGdldCBfY29sb3JzKCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgbnVsbF0sIFtcIkNhbnZhc1wiLCBudWxsXV0pO1xuICAgICgwLCBfZGlzcGxheV91dGlscy5nZXRDb2xvclZhbHVlcykoY29sb3JzKTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRSR0IpKGNvbG9yKTtcbiAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKFwiKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSlcIikubWF0Y2hlcykge1xuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgUkdCXSBvZiB0aGlzLl9jb2xvcnMpIHtcbiAgICAgIGlmIChSR0IuZXZlcnkoKHgsIGkpID0+IHggPT09IHJnYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yTWFuYWdlci5fY29sb3JzTWFwcGluZy5nZXQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZ2I7XG4gIH1cbiAgZ2V0SGV4Q29kZShuYW1lKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fY29sb3JzLmdldChuYW1lKTtcbiAgICBpZiAoIXJnYikge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5yZ2IpO1xuICB9XG59XG5leHBvcnRzLkNvbG9yTWFuYWdlciA9IENvbG9yTWFuYWdlcjtcbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNhbHRUZXh0TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNjb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjaXNXYWl0aW5nID0gZmFsc2U7XG4gICNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICNtb2RlID0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgI3NlbGVjdGVkRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjYm91bmRCbHVyID0gdGhpcy5ibHVyLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3VzID0gdGhpcy5mb2N1cy5iaW5kKHRoaXMpO1xuICAjYm91bmRDb3B5ID0gdGhpcy5jb3B5LmJpbmQodGhpcyk7XG4gICNib3VuZEN1dCA9IHRoaXMuY3V0LmJpbmQodGhpcyk7XG4gICNib3VuZFBhc3RlID0gdGhpcy5wYXN0ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRLZXlkb3duID0gdGhpcy5rZXlkb3duLmJpbmQodGhpcyk7XG4gICNib3VuZE9uRWRpdGluZ0FjdGlvbiA9IHRoaXMub25FZGl0aW5nQWN0aW9uLmJpbmQodGhpcyk7XG4gICNib3VuZE9uUGFnZUNoYW5naW5nID0gdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjYm91bmRPblNjYWxlQ2hhbmdpbmcgPSB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjYm91bmRPblJvdGF0aW9uQ2hhbmdpbmcgPSB0aGlzLm9uUm90YXRpb25DaGFuZ2luZy5iaW5kKHRoaXMpO1xuICAjcHJldmlvdXNTdGF0ZXMgPSB7XG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcbiAgICBpc0VtcHR5OiB0cnVlLFxuICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogZmFsc2UsXG4gICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgfTtcbiAgI3RyYW5zbGF0aW9uID0gWzAsIDBdO1xuICAjdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI3ZpZXdlciA9IG51bGw7XG4gIHN0YXRpYyBUUkFOU0xBVEVfU01BTEwgPSAxO1xuICBzdGF0aWMgVFJBTlNMQVRFX0JJRyA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLnByb3RvdHlwZTtcbiAgICBjb25zdCBhcnJvd0NoZWNrZXIgPSBzZWxmID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQgJiYgc2VsZi4jY29udGFpbmVyLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgfTtcbiAgICBjb25zdCBzbWFsbCA9IHRoaXMuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IHRoaXMuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK2FcIiwgXCJtYWMrbWV0YSthXCJdLCBwcm90by5zZWxlY3RBbGxdLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kb10sIFtbXCJjdHJsK3lcIiwgXCJjdHJsK3NoaWZ0K3pcIiwgXCJtYWMrbWV0YStzaGlmdCt6XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgcHJvdG8ucmVkb10sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiLCBcIm1hYytEZWxldGVcIl0sIHByb3RvLmRlbGV0ZV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by51bnNlbGVjdEFsbF0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgdmlld2VyLCBhbHRUZXh0TWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlciA9IGFsdFRleHRNYW5hZ2VyO1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLiNib3VuZE9uRWRpdGluZ0FjdGlvbik7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblNjYWxlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblJvdGF0aW9uQ2hhbmdpbmcpO1xuICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlID0gcGRmRG9jdW1lbnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy4jZmlsdGVyRmFjdG9yeSA9IHBkZkRvY3VtZW50LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy4jcGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycyA9IHtcbiAgICAgIHJlYWxTY2FsZTogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTLFxuICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy4jYm91bmRPbkVkaXRpbmdBY3Rpb24pO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblBhZ2VDaGFuZ2luZyk7XG4gICAgdGhpcy5fZXZlbnRCdXMuX29mZihcInNjYWxlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblNjYWxlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuICBnZXQgaGNtRmlsdGVyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiZGlyZWN0aW9uXCIsIGdldENvbXB1dGVkU3R5bGUodGhpcy4jY29udGFpbmVyKS5kaXJlY3Rpb24pO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvcikge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IpO1xuICB9XG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cbiAgZm9jdXNNYWluQ29udGFpbmVyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5mb2N1cygpO1xuICB9XG4gIGZpbmRQYXJlbnQoeCwgeSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IGxheWVyWCxcbiAgICAgICAgeTogbGF5ZXJZLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gbGF5ZXIuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHggPj0gbGF5ZXJYICYmIHggPD0gbGF5ZXJYICsgd2lkdGggJiYgeSA+PSBsYXllclkgJiYgeSA8PSBsYXllclkgKyBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkaXNhYmxlVXNlclNlbGVjdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKHtcbiAgICBzY2FsZVxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlID0gc2NhbGUgKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFM7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZSkge1xuICAgICAgZWRpdG9yLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIH1cbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzRW1wdHkoKSAmJiB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSAmJiAhdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRm9jdXMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEJsdXIpO1xuICB9XG4gICNyZW1vdmVGb2N1c01hbmFnZXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEZvY3VzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRCbHVyKTtcbiAgfVxuICBibHVyKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleWRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleWRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjYWRkQ29weVBhc3RlTGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuI2JvdW5kQ29weSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCB0aGlzLiNib3VuZEN1dCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuI2JvdW5kUGFzdGUpO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy4jYm91bmRDb3B5KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuI2JvdW5kQ3V0KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy4jYm91bmRQYXN0ZSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmN1cnJlbnRMYXllcjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RWRpdG9ycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWRFZGl0b3IgPSBsYXllci5kZXNlcmlhbGl6ZShlZGl0b3IpO1xuICAgICAgICBpZiAoIWRlc2VyaWFsaXplZEVkaXRvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdFZGl0b3JzLnB1c2goZGVzZXJpYWxpemVkRWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKG5ld0VkaXRvcnMpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kLFxuICAgICAgICB1bmRvLFxuICAgICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgIH1cbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmdldEFjdGl2ZSgpPy5zaG91bGRHZXRLZXlib2FyZEV2ZW50cygpKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG4gIG9uRWRpdGluZ0FjdGlvbihkZXRhaWxzKSB7XG4gICAgaWYgKFtcInVuZG9cIiwgXCJyZWRvXCIsIFwiZGVsZXRlXCIsIFwic2VsZWN0QWxsXCJdLmluY2x1ZGVzKGRldGFpbHMubmFtZSkpIHtcbiAgICAgIHRoaXNbZGV0YWlscy5uYW1lXSgpO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcbiAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9yc3RhdGVzY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgZGV0YWlsczogT2JqZWN0LmFzc2lnbih0aGlzLiNwcmV2aW91c1N0YXRlcywgZGV0YWlscylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjZGlzcGF0Y2hVcGRhdGVVSShkZXRhaWxzKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJhbm5vdGF0aW9uZWRpdG9ycGFyYW1zY2hhbmdlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzXG4gICAgfSk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiB0aGlzLiNtb2RlICE9PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FLFxuICAgICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMYXllcigpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldCh0aGlzLiNjdXJyZW50UGFnZUluZGV4KTtcbiAgfVxuICBnZXRMYXllcihwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICB9XG4gIGdldCBjdXJyZW50UGFnZUluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50UGFnZUluZGV4O1xuICB9XG4gIGFkZExheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLnNldChsYXllci5wYWdlSW5kZXgsIGxheWVyKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5kZWxldGUobGF5ZXIucGFnZUluZGV4KTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUsIGVkaXRJZCA9IG51bGwpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICBpZiAobW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICB0aGlzLiNlbmFibGVBbGwoKTtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgfVxuICAgIGlmICghZWRpdElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgaWYgKG1vZGUgPT09IHRoaXMuI21vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuQ1JFQVRFKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMYXllci5hZGROZXdFZGl0b3IodHlwZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlV2FpdGluZyhtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI2lzV2FpdGluZyA9PT0gbXVzdFdhaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaXNXYWl0aW5nID0gbXVzdFdhaXQ7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgICBsYXllci5kaXNhYmxlQ2xpY2soKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyLmVuYWJsZUNsaWNrKCk7XG4gICAgICB9XG4gICAgICBsYXllci5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIndhaXRpbmdcIiwgbXVzdFdhaXQpO1xuICAgIH1cbiAgfVxuICAjZW5hYmxlQWxsKCkge1xuICAgIGlmICghdGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNkaXNhYmxlQWxsKCkge1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RWRpdG9ycyhwYWdlSW5kZXgpIHtcbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5wYWdlSW5kZXggPT09IHBhZ2VJbmRleCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcnM7XG4gIH1cbiAgZ2V0RWRpdG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbEVkaXRvcnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG4gIHJlbW92ZUVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlbGVjdGVkKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBmb3IgKGNvbnN0IGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkICE9PSBlZGl0b3IpIHtcbiAgICAgICAgZWQudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSAhPT0gMDtcbiAgfVxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgcmVkbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5yZWRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmFkZChwYXJhbXMpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgfVxuICBoYXNTb21ldGhpbmdUb0NvbnRyb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciB8fCB0aGlzLmhhc1NlbGVjdGlvbjtcbiAgfVxuICAjc2VsZWN0RWRpdG9ycyhlZGl0b3JzKSB7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0QWxsKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLmNvbW1pdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG4gIHVuc2VsZWN0QWxsKCkge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVkaXRvci5jb21taXRPclJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCBub0NvbW1pdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFub0NvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdICs9IHg7XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMV0gKz0geTtcbiAgICBjb25zdCBbdG90YWxYLCB0b3RhbFldID0gdGhpcy4jdHJhbnNsYXRpb247XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDEwMDA7XG4gICAgaWYgKHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gPSB0aGlzLiN0cmFuc2xhdGlvblsxXSA9IDA7XG4gICAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh0b3RhbFgsIHRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHgsIHkpO1xuICAgIH1cbiAgfVxuICBzZXRVcERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMuc2V0KGVkaXRvciwge1xuICAgICAgICBzYXZlZFg6IGVkaXRvci54LFxuICAgICAgICBzYXZlZFk6IGVkaXRvci55LFxuICAgICAgICBzYXZlZFBhZ2VJbmRleDogZWRpdG9yLnBhZ2VJbmRleCxcbiAgICAgICAgbmV3WDogMCxcbiAgICAgICAgbmV3WTogMCxcbiAgICAgICAgbmV3UGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVuZERyYWdTZXNzaW9uKCkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuI2RyYWdnaW5nRWRpdG9ycztcbiAgICB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAgIGxldCBtdXN0QmVBZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBbe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBwYWdlSW5kZXhcbiAgICB9LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgICB2YWx1ZS5uZXdYID0geDtcbiAgICAgIHZhbHVlLm5ld1kgPSB5O1xuICAgICAgdmFsdWUubmV3UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgbXVzdEJlQWRkZWRJblVuZG9TdGFjayB8fD0geCAhPT0gdmFsdWUuc2F2ZWRYIHx8IHkgIT09IHZhbHVlLnNhdmVkWSB8fCBwYWdlSW5kZXggIT09IHZhbHVlLnNhdmVkUGFnZUluZGV4O1xuICAgIH1cbiAgICBpZiAoIW11c3RCZUFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbW92ZSA9IChlZGl0b3IsIHgsIHksIHBhZ2VJbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgZWRpdG9yLl9zZXRQYXJlbnRBbmRQb3NpdGlvbihwYXJlbnQsIHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkaXRvci5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICAgICAgZWRpdG9yLnggPSB4O1xuICAgICAgICAgIGVkaXRvci55ID0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgbmV3WCxcbiAgICAgICAgICBuZXdZLFxuICAgICAgICAgIG5ld1BhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgbmV3WCwgbmV3WSwgbmV3UGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbZWRpdG9yLCB7XG4gICAgICAgICAgc2F2ZWRYLFxuICAgICAgICAgIHNhdmVkWSxcbiAgICAgICAgICBzYXZlZFBhZ2VJbmRleFxuICAgICAgICB9XSBvZiBtYXApIHtcbiAgICAgICAgICBtb3ZlKGVkaXRvciwgc2F2ZWRYLCBzYXZlZFksIHNhdmVkUGFnZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNkcmFnZ2luZ0VkaXRvcnMua2V5cygpKSB7XG4gICAgICBlZGl0b3IuZHJhZyh0eCwgdHkpO1xuICAgIH1cbiAgfVxuICByZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IucGFyZW50ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExheWVyKGVkaXRvci5wYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgICAgIHBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IucGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBpc0FjdGl2ZShlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3I7XG4gIH1cbiAgZ2V0QWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3I7XG4gIH1cbiAgZ2V0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbW9kZTtcbiAgfVxuICBnZXQgaW1hZ2VNYW5hZ2VyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImltYWdlTWFuYWdlclwiLCBuZXcgSW1hZ2VNYW5hZ2VyKCkpO1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhdFRpbWVyID0gZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBleHBvcnRzLlBpeGVsc1BlckluY2ggPSBleHBvcnRzLlBhZ2VWaWV3cG9ydCA9IGV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IGV4cG9ydHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBleHBvcnRzLkRPTUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuZ2V0Q29sb3JWYWx1ZXMgPSBnZXRDb2xvclZhbHVlcztcbmV4cG9ydHMuZ2V0Q3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm07XG5leHBvcnRzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbVVybCA9IGdldEZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuZ2V0UGRmRmlsZW5hbWVGcm9tVXJsID0gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5nZXRSR0IgPSBnZXRSR0I7XG5leHBvcnRzLmdldFhmYVBhZ2VWaWV3cG9ydCA9IGdldFhmYVBhZ2VWaWV3cG9ydDtcbmV4cG9ydHMuaXNEYXRhU2NoZW1lID0gaXNEYXRhU2NoZW1lO1xuZXhwb3J0cy5pc1BkZkZpbGUgPSBpc1BkZkZpbGU7XG5leHBvcnRzLmlzVmFsaWRGZXRjaFVybCA9IGlzVmFsaWRGZXRjaFVybDtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG5leHBvcnRzLm5vQ29udGV4dE1lbnUgPSBub0NvbnRleHRNZW51O1xuZXhwb3J0cy5zZXRMYXllckRpbWVuc2lvbnMgPSBzZXRMYXllckRpbWVuc2lvbnM7XG52YXIgX2Jhc2VfZmFjdG9yeSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY2xhc3MgUGl4ZWxzUGVySW5jaCB7XG4gIHN0YXRpYyBDU1MgPSA5Ni4wO1xuICBzdGF0aWMgUERGID0gNzIuMDtcbiAgc3RhdGljIFBERl9UT19DU1NfVU5JVFMgPSB0aGlzLkNTUyAvIHRoaXMuUERGO1xufVxuZXhwb3J0cy5QaXhlbHNQZXJJbmNoID0gUGl4ZWxzUGVySW5jaDtcbmNsYXNzIERPTUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VGaWx0ZXJGYWN0b3J5IHtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI2hjbUZpbHRlcjtcbiAgI2hjbUtleTtcbiAgI2hjbVVybDtcbiAgI2hjbUhpZ2hsaWdodEZpbHRlcjtcbiAgI2hjbUhpZ2hsaWdodEtleTtcbiAgI2hjbUhpZ2hsaWdodFVybDtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jZG9jSWQgPSBkb2NJZDtcbiAgICB0aGlzLiNkb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgZ2V0ICNjYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jX2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0ICNkZWZzKCkge1xuICAgIGlmICghdGhpcy4jX2RlZnMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZGl2O1xuICAgICAgc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBzdHlsZS5jb250YWluID0gXCJzdHJpY3RcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgc3R5bGUudG9wID0gc3R5bGUubGVmdCA9IDA7XG4gICAgICBzdHlsZS56SW5kZXggPSAtMTtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICAgIHRoaXMuI19kZWZzID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJkZWZzXCIpO1xuICAgICAgZGl2LmFwcGVuZChzdmcpO1xuICAgICAgc3ZnLmFwcGVuZCh0aGlzLiNfZGVmcyk7XG4gICAgICB0aGlzLiNkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jX2RlZnM7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgdGFibGVSLCB0YWJsZUcsIHRhYmxlQiwga2V5O1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGtleSA9IHRhYmxlUiA9IHRhYmxlRyA9IHRhYmxlQiA9IGJ1ZmZlci5qb2luKFwiLFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICAgIGNvbnN0IGJ1ZmZlclIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IGJ1ZmZlckcgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyUltpXSA9IG1hcFJbaV0gLyAyNTU7XG4gICAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgICBidWZmZXJCW2ldID0gbWFwQltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIHRhYmxlUiA9IGJ1ZmZlclIuam9pbihcIixcIik7XG4gICAgICB0YWJsZUcgPSBidWZmZXJHLmpvaW4oXCIsXCIpO1xuICAgICAgdGFibGVCID0gYnVmZmVyQi5qb2luKFwiLFwiKTtcbiAgICAgIGtleSA9IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGlmICh0aGlzLiNoY21LZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgdGhpcy4jaGNtS2V5ID0ga2V5O1xuICAgIHRoaXMuI2hjbVVybCA9IFwibm9uZVwiO1xuICAgIHRoaXMuI2hjbUZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICBjb25zdCBmZ1JHQiA9IHRoaXMuI2dldFJHQihmZ0NvbG9yKTtcbiAgICBmZ0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZmdSR0IpO1xuICAgIGNvbnN0IGJnUkdCID0gdGhpcy4jZ2V0UkdCKGJnQ29sb3IpO1xuICAgIGJnQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5iZ1JHQik7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgaWYgKGZnQ29sb3IgPT09IFwiIzAwMDAwMFwiICYmIGJnQ29sb3IgPT09IFwiI2ZmZmZmZlwiIHx8IGZnQ29sb3IgPT09IGJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDI1NTsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0gaSAvIDI1NTtcbiAgICAgIG1hcFtpXSA9IHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gbWFwLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2ZpbHRlcmA7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgdGhpcy4jaGNtVXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGlmICh0aGlzLiNoY21IaWdobGlnaHRLZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbUhpZ2hsaWdodFVybDtcbiAgICB9XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0S2V5ID0ga2V5O1xuICAgIHRoaXMuI2hjbUhpZ2hsaWdodFVybCA9IFwibm9uZVwiO1xuICAgIHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICAgIH1cbiAgICBjb25zdCBbZmdSR0IsIGJnUkdCXSA9IFtmZ0NvbG9yLCBiZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGxldCBmZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGZnUkdCWzBdICsgMC43MTUyICogZmdSR0JbMV0gKyAwLjA3MjIgKiBmZ1JHQlsyXSk7XG4gICAgbGV0IGJnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogYmdSR0JbMF0gKyAwLjcxNTIgKiBiZ1JHQlsxXSArIDAuMDcyMiAqIGJnUkdCWzJdKTtcbiAgICBsZXQgW25ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbbmV3RmdDb2xvciwgbmV3QmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBpZiAoYmdHcmF5IDwgZmdHcmF5KSB7XG4gICAgICBbZmdHcmF5LCBiZ0dyYXksIG5ld0ZnUkdCLCBuZXdCZ1JHQl0gPSBbYmdHcmF5LCBmZ0dyYXksIG5ld0JnUkdCLCBuZXdGZ1JHQl07XG4gICAgfVxuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBcIlwiO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGZnLCBiZywgbikgPT4ge1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBjb25zdCBzdGVwID0gKGJnR3JheSAtIGZnR3JheSkgLyBuO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBmZyAvIDI1NTtcbiAgICAgIGNvbnN0IG5ld1N0ZXAgPSAoYmcgLSBmZykgLyAoMjU1ICogbik7XG4gICAgICBsZXQgcHJldiA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGgucm91bmQoZmdHcmF5ICsgaSAqIHN0ZXApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld1N0YXJ0ICsgaSAqIG5ld1N0ZXA7XG4gICAgICAgIGZvciAobGV0IGogPSBwcmV2OyBqIDw9IGs7IGorKykge1xuICAgICAgICAgIGFycltqXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBrICsgMTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSBwcmV2OyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW3ByZXYgLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9oaWdobGlnaHRfZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKG5ld0ZnUkdCWzBdLCBuZXdCZ1JHQlswXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzFdLCBuZXdCZ1JHQlsxXSwgNSksIGdldFN0ZXBzKG5ld0ZnUkdCWzJdLCBuZXdCZ1JHQlsyXSwgNSksIGZpbHRlcik7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsID0gYHVybCgjJHtpZH0pYDtcbiAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7XG4gICAgaWYgKGtlZXBIQ00gJiYgKHRoaXMuI2hjbVVybCB8fCB0aGlzLiNoY21IaWdobGlnaHRVcmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNfZGVmcykge1xuICAgICAgdGhpcy4jX2RlZnMucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgdGhpcy4jX2RlZnMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jX2NhY2hlKSB7XG4gICAgICB0aGlzLiNfY2FjaGUuY2xlYXIoKTtcbiAgICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2lkID0gMDtcbiAgfVxuICAjYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwIDAgMCAxIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjY3JlYXRlRmlsdGVyKGlkKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmaWx0ZXJcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcInNSR0JcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICB0aGlzLiNkZWZzLmFwcGVuZChmaWx0ZXIpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBmdW5jLCB0YWJsZSkge1xuICAgIGNvbnN0IGZlRnVuYyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIGZ1bmMpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZGlzY3JldGVcIik7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInRhYmxlVmFsdWVzXCIsIHRhYmxlKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZChmZUZ1bmMpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oclRhYmxlLCBnVGFibGUsIGJUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY1JcIiwgclRhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNHXCIsIGdUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQlwiLCBiVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NRmlsdGVyRmFjdG9yeSA9IERPTUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxufVxuZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gRE9NQ2FudmFzRmFjdG9yeTtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIGFzVHlwZWRBcnJheSA9IGZhbHNlKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBhc1R5cGVkQXJyYXkgPyBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSA6ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIGlmIChhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChhc1R5cGVkQXJyYXkgJiYgcmVxdWVzdC5yZXNwb25zZSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghYXNUeXBlZEFycmF5ICYmIHJlcXVlc3QucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgZGF0YSA9ICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBET01DTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNNYXBEYXRhOiBkYXRhLFxuICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgPSBET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsLCB0cnVlKTtcbiAgfVxufVxuZXhwb3J0cy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVNWR0ZhY3Rvcnkge1xuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NU1ZHRmFjdG9yeSA9IERPTVNWR0ZhY3Rvcnk7XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlld0JveFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInJhd0RpbXNcIiwge1xuICAgICAgcGFnZVdpZHRoOiB2aWV3Qm94WzJdIC0gdmlld0JveFswXSxcbiAgICAgIHBhZ2VIZWlnaHQ6IHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdLFxuICAgICAgcGFnZVg6IHZpZXdCb3hbMF0sXG4gICAgICBwYWdlWTogdmlld0JveFsxXVxuICAgIH0pO1xuICB9XG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG59XG5leHBvcnRzLlBhZ2VWaWV3cG9ydCA9IFBhZ2VWaWV3cG9ydDtcbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIF91dGlsLkJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5leHBvcnRzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwsIG9ubHlTdHJpcFBhdGggPSBmYWxzZSkge1xuICBpZiAoIW9ubHlTdHJpcFBhdGgpIHtcbiAgICBbdXJsXSA9IHVybC5zcGxpdCgvWyM/XS8sIDEpO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgICgwLCBfdXRpbC53YXJuKSgnZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUpIHtcbiAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHN1Z2dlc3RlZEZpbGVuYW1lWzBdO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKGRlY29kZVVSSUNvbXBvbmVudChzdWdnZXN0ZWRGaWxlbmFtZSkpWzBdO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VnZ2VzdGVkRmlsZW5hbWUgfHwgZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBUaW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydGVkW25hbWVdID0gRGF0ZS5ub3coKTtcbiAgfVxuICB0aW1lRW5kKG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy50aW1lcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgZW5kOiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBvdXRCdWYgPSBbXTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmFtZS5sZW5ndGgsIGxvbmdlc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZFxuICAgIH0gb2YgdGhpcy50aW1lcykge1xuICAgICAgb3V0QnVmLnB1c2goYCR7bmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZW5kIC0gc3RhcnR9bXNcXG5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICB9XG59XG5leHBvcnRzLlN0YXRUaW1lciA9IFN0YXRUaW1lcjtcbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHNyYywgcmVtb3ZlU2NyaXB0RWxlbWVudCA9IGZhbHNlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBpZiAocmVtb3ZlU2NyaXB0RWxlbWVudCkge1xuICAgICAgICBzY3JpcHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGV2dCk7XG4gICAgfTtcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoYENhbm5vdCBsb2FkIHNjcmlwdCBhdDogJHtzY3JpcHQuc3JjfWApKTtcbiAgICB9O1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuYXBwZW5kKHNjcmlwdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5sZXQgcGRmRGF0ZVN0cmluZ1JlZ2V4O1xuY2xhc3MgUERGRGF0ZVN0cmluZyB7XG4gIHN0YXRpYyB0b0RhdGVPYmplY3QoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBkZkRhdGVTdHJpbmdSZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBkZkRhdGVTdHJpbmdSZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG4gICAgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgIGhvdXIgKz0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgfSBlbHNlIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiK1wiKSB7XG4gICAgICBob3VyIC09IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgfVxufVxuZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gUERGRGF0ZVN0cmluZztcbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICAoMCwgX3V0aWwud2FybikoYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdyA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlV2lkdGh9cHhgLFxuICAgICAgaCA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlSGVpZ2h0fXB4YDtcbiAgICBjb25zdCB3aWR0aFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKCR7d30sIDFweClgIDogYGNhbGMoJHt3fSlgLFxuICAgICAgaGVpZ2h0U3RyID0gdXNlUm91bmQgPyBgcm91bmQoJHtofSwgMXB4KWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5CYXNlU1ZHRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUZpbHRlckZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlRmlsdGVyRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7fVxufVxuZXhwb3J0cy5CYXNlRmlsdGVyRmFjdG9yeSA9IEJhc2VGaWx0ZXJGYWN0b3J5O1xuY2xhc3MgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ2FudmFzRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuICAgIH07XG4gIH1cbiAgcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZGVzdHJveShjYW52YXNBbmRDb250ZXh0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzID0gbnVsbDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBCYXNlQ2FudmFzRmFjdG9yeTtcbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSB0cnVlXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUNNYXBSZWFkZXJGYWN0b3J5LlwiKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIENNYXAgXCJiYXNlVXJsXCIgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCAnICsgJ3RoZSBcImNNYXBVcmxcIiBhbmQgXCJjTWFwUGFja2VkXCIgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgY29uc3QgY29tcHJlc3Npb25UeXBlID0gdGhpcy5pc0NvbXByZXNzZWQgPyBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSA6IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hEYXRhYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeS5cIik7XG4gICAgfVxuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIH1cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhbmRhcmQgZm9udCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwic3RhbmRhcmRGb250RGF0YVVybFwiIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaERhdGEodXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU1ZHRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTVkdGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHNraXBEaW1lbnNpb25zID0gZmFsc2UpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZGltZW5zaW9uc1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fY3JlYXRlU1ZHKFwic3ZnOnN2Z1wiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcbiAgICBpZiAoIXNraXBEaW1lbnNpb25zKSB7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVTVkcodHlwZSk7XG4gIH1cbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlU1ZHRmFjdG9yeSA9IEJhc2VTVkdGYWN0b3J5O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTXVybXVySGFzaDNfNjQgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgZGF0YSBmb3JtYXQgaW4gTXVybXVySGFzaDNfNjRfdXBkYXRlLiBcIiArIFwiSW5wdXQgbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCxcbiAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGNvbnN0IEMxID0gMHhjYzllMmQ1MSxcbiAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgQzJfTE9XID0gQzIgJiBNQVNLX0xPVztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGsxID0gMDtcbiAgICBzd2l0Y2ggKHRhaWxMZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAyXSA8PCAxNjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNF07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGlmIChibG9ja0NvdW50cyAmIDEpIHtcbiAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoMiBePSBrMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgxID0gaDE7XG4gICAgdGhpcy5oMiA9IGgyO1xuICB9XG4gIGhleGRpZ2VzdCgpIHtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cbmV4cG9ydHMuTXVybXVySGFzaDNfNjQgPSBNdXJtdXJIYXNoM182NDtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZvbnRMb2FkZXIgPSBleHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNsYXNzIEZvbnRMb2FkZXIge1xuICAjc3lzdGVtRm9udHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBzdHlsZUVsZW1lbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMubG9hZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5sb2FkVGVzdEZvbnRJZCA9IDA7XG4gIH1cbiAgYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgcmVtb3ZlTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZCh0aGlzLnN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSB0aGlzLnN0eWxlRWxlbWVudC5zaGVldDtcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgbmF0aXZlRm9udEZhY2Ugb2YgdGhpcy5uYXRpdmVGb250RmFjZXMpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jc3lzdGVtRm9udHMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkU3lzdGVtRm9udChpbmZvKSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLmRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250LnN5c3RlbUZvbnRJbmZvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9Nb3ppbGxhXFwvNS4wLio/cnY6XFxkKy4qPyBHZWNrby8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBXCIgKyBcIkZRQUFCRGdBQUFBZVQxTXZNbFlOWXdrQUFBRWdBQUFBWUdOdFlYQUJEUUxVQUFBQ05BQUFBVUpvWldGay94VkZEUUFBXCIgKyBcIkFMd0FBQUEyYUdobFlRZGtBK29BQUFEMEFBQUFKR2h0ZEhnRDZBQUFBQUFFV0FBQUFBWnRZWGh3QUFKUUFBQUFBUmdBXCIgKyBcIkFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxXCIgKyBcIkFBc0Q2QUFBQUFET0JPVExBQUFBQU00S0hEd0FBQUFBQStnRElRQUFBQWdBQWdBQUFBQUFBQUFCQUFBRElRQUFBRm9EXCIgKyBcIjZBQUFBQUFENkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQVVBQUFBZ0FBQUFRRDZBSDBBQVVBQUFLS0Fyd0FBQUNNXCIgKyBcIkFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzREXCIgKyBcIklQODRBRm9ESVFBQUFBQUFBUUFBQUFBQUFBQUFBQ0FBSUFBQkFBQUFEZ0N1QUFFQUFBQUFBQUFBQVFBQUFBRUFBQUFBXCIgKyBcIkFBRUFBUUFBQUFFQUFBQUFBQUlBQVFBQUFBRUFBQUFBQUFNQUFRQUFBQUVBQUFBQUFBUUFBUUFBQUFFQUFBQUFBQVVBXCIgKyBcIkFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCXCIgKyBcIkFBTUFBUVFKQUFNQUFnQUJBQU1BQVFRSkFBUUFBZ0FCQUFNQUFRUUpBQVVBQWdBQkFBTUFBUVFKQUFZQUFnQUJXQUJZXCIgKyBcIkFBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUFBQUFBRHdBQXdBQkFBQUFIQUFFQUNBQUFBQUVBQVFBQVFBQUFDNy8vd0FBXCIgKyBcIkFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBRC9nd0F5QUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDXCIgKyBcIkFRRUJJVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWUFBQUJBUUFBRHdBQ0FRRUVFL3QzXCIgKyBcIkRvdjZmQUg2ZkFUK2ZQcDgrbndIRG9zTUN2bTFDdm0xREF6NmZCUUFBQUFBQUFBQkFBQUFBTW1KYnpFQUFBQUF6Z1RqXCIgKyBcIkZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCAoMCwgX3V0aWwuc3RyaW5nMzIpKGNoZWNrc3VtKSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgY29uc3QgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7bG9hZFRlc3RGb250SWR9XCI7c3JjOiR7dXJsfX1gO1xuICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtmb250LmxvYWRlZE5hbWUsIGxvYWRUZXN0Rm9udElkXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICBkaXYuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCB7XG4gICAgaXNFdmFsU3VwcG9ydGVkID0gdHJ1ZSxcbiAgICBkaXNhYmxlRm9udEZhY2UgPSBmYWxzZSxcbiAgICBpZ25vcmVFcnJvcnMgPSBmYWxzZSxcbiAgICBpbnNwZWN0Rm9udCA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAoY29uc3QgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cbiAgICB0aGlzLmlzRXZhbFN1cHBvcnRlZCA9IGlzRXZhbFN1cHBvcnRlZCAhPT0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRm9udEZhY2UgPSBkaXNhYmxlRm9udEZhY2UgPT09IHRydWU7XG4gICAgdGhpcy5pZ25vcmVFcnJvcnMgPSBpZ25vcmVFcnJvcnMgPT09IHRydWU7XG4gICAgdGhpcy5faW5zcGVjdEZvbnQgPSBpbnNwZWN0Rm9udDtcbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gKDAsIF91dGlsLmJ5dGVzVG9TdHJpbmcpKHRoaXMuZGF0YSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGxldCBjbWRzO1xuICAgIHRyeSB7XG4gICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICghdGhpcy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9XG4gICAgICAoMCwgX3V0aWwud2FybikoYGdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFwiJHtleH1cIi5gKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiAoYywgc2l6ZSkge307XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRXZhbFN1cHBvcnRlZCAmJiBfdXRpbC5GZWF0dXJlVGVzdC5pc0V2YWxTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IGpzQnVmID0gW107XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgY21kcykge1xuICAgICAgICBjb25zdCBhcmdzID0gY3VycmVudC5hcmdzICE9PSB1bmRlZmluZWQgPyBjdXJyZW50LmFyZ3Muam9pbihcIixcIikgOiBcIlwiO1xuICAgICAgICBqc0J1Zi5wdXNoKFwiYy5cIiwgY3VycmVudC5jbWQsIFwiKFwiLCBhcmdzLCBcIik7XFxuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IG5ldyBGdW5jdGlvbihcImNcIiwgXCJzaXplXCIsIGpzQnVmLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBjbWRzKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmNtZCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgY3VycmVudC5hcmdzID0gW3NpemUsIC1zaXplXTtcbiAgICAgICAgfVxuICAgICAgICBjW2N1cnJlbnQuY21kXS5hcHBseShjLCBjdXJyZW50LmFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSBGb250RmFjZU9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Ob2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLk5vZGVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xudmFyIF9iYXNlX2ZhY3RvcnkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbjtcbjtcbmNvbnN0IGZldGNoRGF0YSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICBmcy5yZWFkRmlsZSh1cmwsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgfSk7XG4gIH0pO1xufTtcbmNsYXNzIE5vZGVGaWx0ZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlRmlsdGVyRmFjdG9yeSB7fVxuZXhwb3J0cy5Ob2RlRmlsdGVyRmFjdG9yeSA9IE5vZGVGaWx0ZXJGYWN0b3J5O1xuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDYW52YXNGYWN0b3J5IHtcbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhc1wiKTtcbiAgICByZXR1cm4gQ2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxufVxuZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IE5vZGVDYW52YXNGYWN0b3J5O1xuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IE5vZGVDTWFwUmVhZGVyRmFjdG9yeTtcbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cbmV4cG9ydHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkNhbnZhc0dyYXBoaWNzID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3BhdHRlcm5faGVscGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG52YXIgX2ltYWdlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgTUFYX0dST1VQX1NJWkUgPSA0MDk2O1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgTUFYX1NJWkVfVE9fQ09NUElMRSA9IDEwMDA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiBjdHhTYXZlKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgIGRlc3RDdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc3RvcmUoKTtcbiAgfTtcbiAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZGVzdEN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNsYXRlKHgsIHkpO1xuICB9O1xuICBjdHguc2NhbGUgPSBmdW5jdGlvbiBjdHhTY2FsZSh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFJlc2V0VHJhbnNmb3JtKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gY3R4Um90YXRlKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcDFbMF0sIHAyWzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwMVswXSwgcDJbMF0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcDFbMV0sIHAyWzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIF91dGlsLlV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIG1pbk1heFsxXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IF91dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIGJveFswXSwgYm94WzJdKTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgYm94WzBdLCBib3hbMl0pO1xuICAgICAgbWluTWF4WzJdID0gTWF0aC5taW4obWluTWF4WzJdLCBib3hbMV0sIGJveFszXSk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIGJveFsxXSwgYm94WzNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNUUk9LRSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBzY2FsZVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBzY2FsZVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9XG4gIHVwZGF0ZUNsaXBGcm9tUGF0aCgpIHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSBfdXRpbC5VdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuICBpc0VtcHR5Q2xpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveCA9IGJveDtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAwO1xuICAgIHRoaXMubWF4WSA9IDA7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIHRyYW5zZm9ybSkpO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlciwgMCwgZGVzdC5ieXRlTGVuZ3RoID4+IDIpO1xuICAgIGNvbnN0IGRlc3QzMkRhdGFMZW5ndGggPSBkZXN0MzIubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxTcmNEaWZmID0gd2lkdGggKyA3ID4+IDM7XG4gICAgY29uc3Qgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IGJsYWNrID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSAyNTU7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgY3R4LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMDtcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSAoMCwgX2ltYWdlX3V0aWxzLmNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKSh7XG4gICAgICBzcmMsXG4gICAgICBzcmNQb3MsXG4gICAgICBkZXN0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNDaHVua0hlaWdodCxcbiAgICAgIG5vbkJsYWNrQ29sb3I6IDBcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCIsIFwiZmlsdGVyXCJdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0Q3R4W3Byb3BlcnR5XSA9IHNvdXJjZUN0eFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gIGN0eC5maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHgubGluZVdpZHRoID0gMTtcbiAgY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcbiAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG4gIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gYnl0ZXNbaV07XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBieXRlc1tpIC0gM10gPSByMDtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgfSBlbHNlIGlmIChhbHBoYSA8IDI1NSkge1xuICAgICAgY29uc3QgYWxwaGFfID0gMjU1IC0gYWxwaGE7XG4gICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMV0gPSBieXRlc1tpIC0gMV0gKiBhbHBoYSArIGIwICogYWxwaGFfID4+IDg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tBbHBoYShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGNvbnN0IHNjYWxlID0gMSAvIDI1NTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICBsYXllckRhdGFbaV0gPSBsYXllckRhdGFbaV0gKiBhbHBoYSAqIHNjYWxlIHwgMDtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrTHVtaW5vc2l0eShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB5ID0gbWFza0RhdGFbaSAtIDNdICogNzcgKyBtYXNrRGF0YVtpIC0gMl0gKiAxNTIgKyBtYXNrRGF0YVtpIC0gMV0gKiAyODtcbiAgICBsYXllckRhdGFbaV0gPSB0cmFuc2Zlck1hcCA/IGxheWVyRGF0YVtpXSAqIHRyYW5zZmVyTWFwW3kgPj4gOF0gPj4gOCA6IGxheWVyRGF0YVtpXSAqIHkgPj4gMTY7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICBjb25zdCBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gIGNvbnN0IHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gIGNvbnN0IGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gIGNvbnN0IGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gIGNvbnN0IGNvbXBvc2VGbiA9IHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiID8gY29tcG9zZVNNYXNrTHVtaW5vc2l0eSA6IGNvbXBvc2VTTWFza0FscGhhO1xuICBjb25zdCBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgY29uc3QgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WCwgcm93ICsgKGxheWVyT2Zmc2V0WSAtIG1hc2tPZmZzZXRZKSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcbiAgICBjb25zdCBsYXllckRhdGEgPSBsYXllckN0eC5nZXRJbWFnZURhdGEobGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFksIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICBjb21wb3NlU01hc2tCYWNrZHJvcChtYXNrRGF0YS5kYXRhLCByMCwgZzAsIGIwKTtcbiAgICB9XG4gICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgbGF5ZXJDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgbGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFkpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIGxheWVyQm94KSB7XG4gIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgY29uc3QgbGF5ZXJXaWR0aCA9IGxheWVyQm94WzJdIC0gbGF5ZXJPZmZzZXRYO1xuICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBnZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGNvbnN0IHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICBzY2FsZVswXSA9IE1hdGguZnJvdW5kKHNjYWxlWzBdKTtcbiAgc2NhbGVbMV0gPSBNYXRoLmZyb3VuZChzY2FsZVsxXSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIGlmIChpbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDw9IGFjdHVhbFNjYWxlIHx8IHNjYWxlWzFdIDw9IGFjdHVhbFNjYWxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuY29uc3QgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbmNvbnN0IE5PUk1BTF9DTElQID0ge307XG5jb25zdCBFT19DTElQID0ge307XG5jbGFzcyBDYW52YXNHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgZmlsdGVyRmFjdG9yeSwge1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyxcbiAgICBtYXJrZWRDb250ZW50U3RhY2sgPSBudWxsXG4gIH0sIGFubm90YXRpb25DYW52YXNNYXAsIHBhZ2VDb2xvcnMpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgdGhpcy5ncm91cExldmVsID0gMDtcbiAgICB0aGlzLnNtYXNrU3RhY2sgPSBbXTtcbiAgICB0aGlzLnNtYXNrQ291bnRlciA9IDA7XG4gICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjayA9IG1hcmtlZENvbnRlbnRTdGFjayB8fCBbXTtcbiAgICB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyA9IG9wdGlvbmFsQ29udGVudENvbmZpZztcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzID0gbmV3IENhY2hlZENhbnZhc2VzKHRoaXMuY2FudmFzRmFjdG9yeSk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVggPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVZID0gMTtcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmcgPSBbLTEsIDBdO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0T2JqZWN0KGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoe1xuICAgIHRyYW5zZm9ybSxcbiAgICB2aWV3cG9ydCxcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBiYWNrZ3JvdW5kID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmN0eC5jYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBzYXZlZEZpbGxTdHlsZSA9IHRoaXMuY3R4LmZpbGxTdHlsZTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kIHx8IFwiI2ZmZmZmZlwiO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHNhdmVkRmlsbFN0eWxlO1xuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLigwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVggPSB0cmFuc2Zvcm1bMF07XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWSA9IHRyYW5zZm9ybVswXTtcbiAgICB9XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnZpZXdwb3J0LnRyYW5zZm9ybSk7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gdmlld3BvcnQuc2NhbGU7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgaWYgKGZuSWQgIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgIHRoaXNbZm5JZF0uYXBwbHkodGhpcywgYXJnc0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgYXJnc0FycmF5W2ldKSB7XG4gICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuICBlbmREcmF3aW5nKCkge1xuICAgIHRoaXMuI3Jlc3RvcmVJbml0aWFsU3RhdGUoKTtcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgY2FjaGUgb2YgdGhpcy5fY2FjaGVkQml0bWFwc01hcC52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBjYW52YXMgb2YgY2FjaGUudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICB9XG4gICNkcmF3RmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnBhZ2VDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGhjbUZpbHRlcklkID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLnBhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy5wYWdlQ29sb3JzLmJhY2tncm91bmQpO1xuICAgICAgaWYgKGhjbUZpbHRlcklkICE9PSBcIm5vbmVcIikge1xuICAgICAgICBjb25zdCBzYXZlZEZpbHRlciA9IHRoaXMuY3R4LmZpbHRlcjtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gaGNtRmlsdGVySWQ7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLmN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBzYXZlZEZpbHRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NjYWxlSW1hZ2UoaW1nLCBpbnZlcnNlVHJhbnNmb3JtKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbWcud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICBsZXQgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVswXSwgaW52ZXJzZVRyYW5zZm9ybVsxXSksIDEpO1xuICAgIGxldCBoZWlnaHRTY2FsZSA9IE1hdGgubWF4KE1hdGguaHlwb3QoaW52ZXJzZVRyYW5zZm9ybVsyXSwgaW52ZXJzZVRyYW5zZm9ybVszXSksIDEpO1xuICAgIGxldCBwYWludFdpZHRoID0gd2lkdGgsXG4gICAgICBwYWludEhlaWdodCA9IGhlaWdodDtcbiAgICBsZXQgdG1wQ2FudmFzSWQgPSBcInByZXNjYWxlMVwiO1xuICAgIGxldCB0bXBDYW52YXMsIHRtcEN0eDtcbiAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgbGV0IG5ld1dpZHRoID0gcGFpbnRXaWR0aCxcbiAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQ7XG4gICAgICBpZiAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEpIHtcbiAgICAgICAgbmV3V2lkdGggPSBwYWludFdpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludFdpZHRoIC8gMikgLSAxIHx8IDEgOiBNYXRoLmNlaWwocGFpbnRXaWR0aCAvIDIpO1xuICAgICAgICB3aWR0aFNjYWxlIC89IHBhaW50V2lkdGggLyBuZXdXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihwYWludEhlaWdodCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50SGVpZ2h0KSAvIDI7XG4gICAgICAgIGhlaWdodFNjYWxlIC89IHBhaW50SGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXModG1wQ2FudmFzSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGltZyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBwYWludFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRtcENhbnZhc0lkID0gdG1wQ2FudmFzSWQgPT09IFwicHJlc2NhbGUxXCIgPyBcInByZXNjYWxlMlwiIDogXCJwcmVzY2FsZTFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGltZyxcbiAgICAgIHBhaW50V2lkdGgsXG4gICAgICBwYWludEhlaWdodFxuICAgIH07XG4gIH1cbiAgX2NyZWF0ZU1hc2tDYW52YXMoaW1nKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nO1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhY2hlZEltYWdlLFxuICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDYW52YXMuY29udGV4dCwgaW1nKTtcbiAgICB9XG4gICAgbGV0IG1hc2tUb0NhbnZhcyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFsxIC8gd2lkdGgsIDAsIDAsIC0xIC8gaGVpZ2h0LCAwLCAwXSk7XG4gICAgbWFza1RvQ2FudmFzID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuICAgIGNvbnN0IGNvcmQxID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIG1hc2tUb0NhbnZhcyk7XG4gICAgY29uc3QgY29yZDIgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzKTtcbiAgICBjb25zdCByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtjb3JkMVswXSwgY29yZDFbMV0sIGNvcmQyWzBdLCBjb3JkMlsxXV0pO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLnJvdW5kKHJlY3RbMl0gLSByZWN0WzBdKSB8fCAxO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5yb3VuZChyZWN0WzNdIC0gcmVjdFsxXSkgfHwgMTtcbiAgICBjb25zdCBmaWxsQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJmaWxsQ2FudmFzXCIsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBmaWxsQ3R4ID0gZmlsbENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLm1pbihjb3JkMVswXSwgY29yZDJbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLm1pbihjb3JkMVsxXSwgY29yZDJbMV0pO1xuICAgIGZpbGxDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZmlsbEN0eC50cmFuc2Zvcm0oLi4ubWFza1RvQ2FudmFzKTtcbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShmaWxsQ3R4KSk7XG4gICAgICBzY2FsZWQgPSBzY2FsZWQuaW1nO1xuICAgICAgaWYgKGNhY2hlICYmIGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzY2FsZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsQ3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IF91dGlsLlV0aWwudHJhbnNmb3JtKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCksIFsxLCAwLCAwLCAxLCAtb2Zmc2V0WCwgLW9mZnNldFldKTtcbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICBmaWxsQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChjYWNoZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5kZWxldGUoXCJmaWxsQ2FudmFzXCIpO1xuICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBmaWxsQ2FudmFzLmNhbnZhcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGZpbGxDYW52YXMuY2FudmFzLFxuICAgICAgb2Zmc2V0WDogTWF0aC5yb3VuZChvZmZzZXRYKSxcbiAgICAgIG9mZnNldFk6IE1hdGgucm91bmQob2Zmc2V0WSlcbiAgICB9O1xuICB9XG4gIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCkge1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gIH1cbiAgc2V0TGluZUNhcChzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG4gIHNldExpbmVKb2luKHN0eWxlKSB7XG4gICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaFBoYXNlO1xuICAgIH1cbiAgfVxuICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcIkxXXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1MXCI6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRkxcIjpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5maWxsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gdmFsdWUgPyB0aGlzLnRlbXBTTWFzayA6IG51bGw7XG4gICAgICAgICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkRmlsdGVyKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluU01hc2tNb2RlKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3VzcGVuZGVkQ3R4O1xuICB9XG4gIGNoZWNrU01hc2tTdGF0ZSgpIHtcbiAgICBjb25zdCBpblNNYXNrTW9kZSA9IHRoaXMuaW5TTWFza01vZGU7XG4gICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiAhaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuYmVnaW5TTWFza01vZGUoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgfVxuICB9XG4gIGJlZ2luU01hc2tNb2RlKCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpblNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgYWxyZWFkeSBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNldFRyYW5zZm9ybSguLi4oMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG4gIGVuZFNNYXNrTW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZFNNYXNrTW9kZSBjYWxsZWQgd2hpbGUgbm90IGluIHNtYXNrIG1vZGVcIik7XG4gICAgfVxuICAgIHRoaXMuY3R4Ll9yZW1vdmVNaXJyb3JpbmcoKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuICBjb21wb3NlKGRpcnR5Qm94KSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkaXJ0eUJveCkge1xuICAgICAgZGlydHlCb3ggPSBbMCwgMCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlCb3hbMF0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzBdKTtcbiAgICAgIGRpcnR5Qm94WzFdID0gTWF0aC5mbG9vcihkaXJ0eUJveFsxXSk7XG4gICAgICBkaXJ0eUJveFsyXSA9IE1hdGguY2VpbChkaXJ0eUJveFsyXSk7XG4gICAgICBkaXJ0eUJveFszXSA9IE1hdGguY2VpbChkaXJ0eUJveFszXSk7XG4gICAgfVxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIGNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgICAgdGhpcy5zdXNwZW5kZWRDdHguc2F2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICB9XG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzLCBtaW5NYXgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGxldCB4ID0gY3VycmVudC54LFxuICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICBsZXQgc3RhcnRYLCBzdGFydFk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGNvbnN0IGlzU2NhbGluZ01hdHJpeCA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0gPT09IDAgJiYgY3VycmVudFRyYW5zZm9ybVszXSA9PT0gMCB8fCBjdXJyZW50VHJhbnNmb3JtWzFdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bMl0gPT09IDA7XG4gICAgY29uc3QgbWluTWF4Rm9yQmV6aWVyID0gaXNTY2FsaW5nTWF0cml4ID8gbWluTWF4LnNsaWNlKDApIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGlpID0gb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgW3gsIHksIHh3LCB5aF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubGluZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10pO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCB4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgY3VycmVudC51cGRhdGVTY2FsaW5nUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgIH1cbiAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gIH1cbiAgc3Ryb2tlKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuU1RST0tFKTtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICB9XG4gIGNsb3NlU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfVxuICBmaWxsKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpO1xuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgoaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGVuZFBhdGgoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGNsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG4gIGVvQ2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXRoLnRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgIHBhdGguYWRkVG9QYXRoKGN0eCwgcGF0aC5mb250U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldExlYWRpbmcobGVhZGluZykge1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGZvbnRPYmoubG9hZGVkTmFtZSB8fCBcInNhbnMtc2VyaWZcIjtcbiAgICBjb25zdCB0eXBlZmFjZSA9IGZvbnRPYmouc3lzdGVtRm9udEluZm8/LmNzcyB8fCBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKHNpemUgPCBNSU5fRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1BWF9GT05UX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgfVxuICBzZXRUZXh0UmlzZShyaXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgfVxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgcGFpbnRDaGFyKGNoYXJhY3RlciwgeCwgeSwgcGF0dGVyblRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IGFkZFRvUGF0aDtcbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgIGFkZFRvUGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG4gICAgICBpZiAocGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGFkZFRvUGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5UcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICB9XG4gICAgbGV0IGxpbmVXaWR0aCA9IGN1cnJlbnQubGluZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gY3VycmVudC50ZXh0TWF0cml4U2NhbGU7XG4gICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVdpZHRoIC89IHNjYWxlO1xuICAgIH1cbiAgICBpZiAoZm9udFNpemVTY2FsZSAhPT0gMS4wKSB7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICBsaW5lV2lkdGggLz0gZm9udFNpemVTY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBpZiAoZm9udC5pc0ludmFsaWRQREZqc0ZvbnQpIHtcbiAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgICAgY2hhcnMucHVzaChnbHlwaC51bmljb2RlKTtcbiAgICAgICAgd2lkdGggKz0gZ2x5cGgud2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFRleHQoY2hhcnMuam9pbihcIlwiKSwgMCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAqIHRleHRIU2NhbGU7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgeCA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gbWVhc3VyZWRXaWR0aCkge1xuICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgaWYgKHNpbXBsZUZpbGxUZXh0ICYmICFhY2NlbnQpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhaW50Q2hhcihjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihhY2NlbnQuZm9udENoYXIsIHNjYWxlZEFjY2VudFgsIHNjYWxlZEFjY2VudFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtnbHlwaC53aWR0aCwgMF0sIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSB0cmFuc2Zvcm1lZFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cbiAgc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMoeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIHRoaXMuY3R4LnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBjb2xvciA9IElSWzFdO1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhbnZhc0dyYXBoaWNzKGN0eCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGF0dGVybiA9IG5ldyBfcGF0dGVybl9oZWxwZXIuVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCwgbWF0cml4ID0gbnVsbCkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSAoMCwgX3BhdHRlcm5faGVscGVyLmdldFNoYWRpbmdQYXR0ZXJuKSh0aGlzLmdldE9iamVjdChvYmpJZCkpO1xuICAgICAgdGhpcy5jYWNoZWRQYXR0ZXJucy5zZXQob2JqSWQsIHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAobWF0cml4KSB7XG4gICAgICBwYXR0ZXJuLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2hhZGluZ0ZpbGwob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TSEFESU5HKTtcbiAgICBjb25zdCBpbnYgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCk7XG4gICAgaWYgKGludikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gY3R4LmNhbnZhcztcbiAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbmxpbmVJbWFnZVwiKTtcbiAgfVxuICBiZWdpbkltYWdlRGF0YSgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgdGhpcy5jdHgucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCksIGJib3gpO1xuICAgICAgdGhpcy5jbGlwKCk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gIH1cbiAgYmVnaW5Hcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICBpZiAoIWdyb3VwLmlzb2xhdGVkKSB7XG4gICAgICAoMCwgX3V0aWwuaW5mbykoXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIktub2Nrb3V0IGdyb3VwcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KTtcbiAgICBpZiAoZ3JvdXAubWF0cml4KSB7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zZm9ybSguLi5ncm91cC5tYXRyaXgpO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLmJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdW5kaW5nIGJveCBpcyByZXF1aXJlZC5cIik7XG4gICAgfVxuICAgIGxldCBib3VuZHMgPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KSk7XG4gICAgY29uc3QgY2FudmFzQm91bmRzID0gWzAsIDAsIGN1cnJlbnRDdHguY2FudmFzLndpZHRoLCBjdXJyZW50Q3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIGJvdW5kcyA9IF91dGlsLlV0aWwuaW50ZXJzZWN0KGJvdW5kcywgY2FudmFzQm91bmRzKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IoYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcihib3VuZHNbMV0pO1xuICAgIGxldCBkcmF3bldpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYLCAxKTtcbiAgICBsZXQgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIGxldCBzY2FsZVggPSAxLFxuICAgICAgc2NhbGVZID0gMTtcbiAgICBpZiAoZHJhd25XaWR0aCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICBzY2FsZVggPSBkcmF3bldpZHRoIC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bldpZHRoID0gTUFYX0dST1VQX1NJWkU7XG4gICAgfVxuICAgIGlmIChkcmF3bkhlaWdodCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICBzY2FsZVkgPSBkcmF3bkhlaWdodCAvIE1BWF9HUk9VUF9TSVpFO1xuICAgICAgZHJhd25IZWlnaHQgPSBNQVhfR1JPVVBfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3goWzAsIDAsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0XSk7XG4gICAgbGV0IGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICBjb25zdCBncm91cEN0eCA9IHNjcmF0Y2hDYW52YXMuY29udGV4dDtcbiAgICBncm91cEN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICBncm91cEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBncm91cEN0eC50cmFuc2Zvcm0oLi4uY3VycmVudFRyYW5zZm9ybSk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnNtYXNrU3RhY2sucHVzaCh7XG4gICAgICAgIGNhbnZhczogc2NyYXRjaENhbnZhcy5jYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdXJyZW50Q3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIGN1cnJlbnRDdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cbiAgZW5kR3JvdXAoZ3JvdXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncm91cExldmVsLS07XG4gICAgY29uc3QgZ3JvdXBDdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLmN1cnJlbnRNdHgpO1xuICAgICAgY29uc3QgZGlydHlCb3ggPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4KTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShncm91cEN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKGRpcnR5Qm94KTtcbiAgICB9XG4gIH1cbiAgYmVnaW5Bbm5vdGF0aW9uKGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLnRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlY3QpICYmIHJlY3QubGVuZ3RoID09PSA0KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgICBpZiAoaGFzT3duQ2FudmFzICYmIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0uc2xpY2UoKTtcbiAgICAgICAgdHJhbnNmb3JtWzRdIC09IHJlY3RbMF07XG4gICAgICAgIHRyYW5zZm9ybVs1XSAtPSByZWN0WzFdO1xuICAgICAgICByZWN0ID0gcmVjdC5zbGljZSgpO1xuICAgICAgICByZWN0WzBdID0gcmVjdFsxXSA9IDA7XG4gICAgICAgIHJlY3RbMl0gPSB3aWR0aDtcbiAgICAgICAgcmVjdFszXSA9IGhlaWdodDtcbiAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCAtc2NhbGVZLCAwLCBoZWlnaHQgKiBzY2FsZVkpO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuY3R4LnJlY3QocmVjdFswXSwgcmVjdFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IG5ldyBDYW52YXNFeHRyYVN0YXRlKHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICB9XG4gIGVuZEFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KGltZykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb3VudCA9IGltZy5jb3VudDtcbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBpbWcuY291bnQgPSBjb3VudDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBnbHlwaCA9IHRoaXMucHJvY2Vzc2luZ1R5cGUzO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQgPSBjb21waWxlVHlwZTNHbHlwaChpbWcpO1xuICAgICAgfVxuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjb25zdCBtYXNrQ2FudmFzID0gbWFzay5jYW52YXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KGltZywgc2NhbGVYLCBza2V3WCA9IDAsIHNrZXdZID0gMCwgc2NhbGVZLCBwb3NpdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgbWFzay5vZmZzZXRYIC0gY3VycmVudFRyYW5zZm9ybVs0XSwgbWFzay5vZmZzZXRZIC0gY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY29uc3QgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIHRyYW5zKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobWFzay5jYW52YXMsIHgsIHkpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3QoZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9iaklkLCBzY2FsZVgsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKTtcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKGN0eCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzICE9PSBcIm5vbmVcIikge1xuICAgICAgY3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgICBjdHguZHJhd0ltYWdlKGN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY3R4LmNhbnZhcztcbiAgfVxuICBhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9PT0gXCJub25lXCIpIHtcbiAgICAgIHJldHVybiBpbWdEYXRhLmJpdG1hcDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gaW1nRGF0YTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIHRtcEN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgIHRtcEN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwKTtcbiAgICB0bXBDdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgcmV0dXJuIHRtcENhbnZhcy5jYW52YXM7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmaWx0ZXJcbiAgICAgIH0gPSBjdHg7XG4gICAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwKGltZ0RhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkID0gdGhpcy5fc2NhbGVJbWFnZShpbWdUb1BhaW50LCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNjYWxlZC5pbWcsIDAsIDAsIHNjYWxlZC5wYWludFdpZHRoLCBzY2FsZWQucGFpbnRIZWlnaHQsIDAsIC1oZWlnaHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAoaW1nRGF0YSwgbWFwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGEuYml0bWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIGNvbnN0IGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgdywgaCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIG1hcmtQb2ludCh0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKHRhZywgcHJvcGVydGllcykge31cbiAgYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzKHRhZywgcHJvcGVydGllcykge1xuICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLmlzVmlzaWJsZShwcm9wZXJ0aWVzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KCkge31cbiAgZW5kQ29tcGF0KCkge31cbiAgY29uc3VtZVBhdGgoY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZUNsaXBGcm9tUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY29tcG9zZShjbGlwQm94KTtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gRU9fQ0xJUCkge1xuICAgICAgICAgIGN0eC5jbGlwKFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgfVxuICBnZXRTaW5nbGVQaXhlbFdpZHRoKCkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCkge1xuICAgICAgY29uc3QgbSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICBpZiAobVsxXSA9PT0gMCAmJiBtWzJdID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSAxIC8gTWF0aC5taW4oTWF0aC5hYnMobVswXSksIE1hdGguYWJzKG1bM10pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKG1bMF0gKiBtWzNdIC0gbVsyXSAqIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QobVswXSwgbVsyXSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChtWzFdLCBtWzNdKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IE1hdGgubWF4KG5vcm1YLCBub3JtWSkgLyBhYnNEZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG4gIGdldFNjYWxlRm9yU3Ryb2tpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPT09IC0xKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmVXaWR0aFxuICAgICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZFxuICAgICAgfSA9IHRoaXMuY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgbGV0IHNjYWxlWCwgc2NhbGVZO1xuICAgICAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguYWJzKGEpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguYWJzKGQpO1xuICAgICAgICBpZiAobm9ybVggPT09IG5vcm1ZKSB7XG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gMSAvIG5vcm1YO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IHNjYWxlZExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkTGluZVdpZHRoIDogMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhhICogZCAtIGIgKiBjKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSAvIGFic0RldDtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCAvIGFic0RldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiYXNlQXJlYSA9IGxpbmVXaWR0aCAqIGFic0RldDtcbiAgICAgICAgICBzY2FsZVggPSBub3JtWSA+IGJhc2VBcmVhID8gbm9ybVkgLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggPiBiYXNlQXJlYSA/IG5vcm1YIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gc2NhbGVYO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1sxXSA9IHNjYWxlWTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cbiAgcmVzY2FsZUFuZFN0cm9rZShzYXZlUmVzdG9yZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVXaWR0aFxuICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IHRoaXMuZ2V0U2NhbGVGb3JTdHJva2luZygpO1xuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXNoZXMgPSBjdHguZ2V0TGluZURhc2goKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IENhbnZhc0dyYXBoaWNzO1xuZm9yIChjb25zdCBvcCBpbiBfdXRpbC5PUFMpIHtcbiAgaWYgKENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtfdXRpbC5PUFNbb3BdXSA9IENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZVtvcF07XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gZXhwb3J0cy5QYXRoVHlwZSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0U2hhZGluZ1BhdHRlcm4gPSBnZXRTaGFkaW5nUGF0dGVybjtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY29uc3QgUGF0aFR5cGUgPSB7XG4gIEZJTEw6IFwiRmlsbFwiLFxuICBTVFJPS0U6IFwiU3Ryb2tlXCIsXG4gIFNIQURJTkc6IFwiU2hhZGluZ1wiXG59O1xuZXhwb3J0cy5QYXRoVHlwZSA9IFBhdGhUeXBlO1xuZnVuY3Rpb24gYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpIHtcbiAgaWYgKCFiYm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuY2xhc3MgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VTaGFkaW5nUGF0dGVybikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTaGFkaW5nUGF0dGVybi5cIik7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSkgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwob3duZXJCQm94WzJdIC0gb3duZXJCQm94WzBdKSB8fCAxO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKG93bmVyQkJveFszXSAtIG93bmVyQkJveFsxXSkgfHwgMTtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdG1wQ3R4LnJlY3QoMCwgMCwgdG1wQ3R4LmNhbnZhcy53aWR0aCwgdG1wQ3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdG1wQ3R4LnRyYW5zbGF0ZSgtb3duZXJCQm94WzBdLCAtb3duZXJCQm94WzFdKTtcbiAgICAgIGludmVyc2UgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShpbnZlcnNlLCBbMSwgMCwgMCwgMSwgb3duZXJCQm94WzBdLCBvd25lckJCb3hbMV1dKTtcbiAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuICAgICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICBjb2xvcnMgPSBjb250ZXh0LmNvbG9ycztcbiAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGEsXG4gICAgcm93U2l6ZSA9IGRhdGEud2lkdGggKiA0O1xuICBsZXQgdG1wO1xuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuICBpZiAoY29vcmRzW3AxICsgMV0gPiBjb29yZHNbcDIgKyAxXSkge1xuICAgIHRtcCA9IHAxO1xuICAgIHAxID0gcDI7XG4gICAgcDIgPSB0bXA7XG4gICAgdG1wID0gYzE7XG4gICAgYzEgPSBjMjtcbiAgICBjMiA9IHRtcDtcbiAgfVxuICBjb25zdCB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYzFyID0gY29sb3JzW2MxXSxcbiAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgY29uc3QgYzJyID0gY29sb3JzW2MyXSxcbiAgICBjMmcgPSBjb2xvcnNbYzIgKyAxXSxcbiAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICBjM2IgPSBjb2xvcnNbYzMgKyAyXTtcbiAgY29uc3QgbWluWSA9IE1hdGgucm91bmQoeTEpLFxuICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG4gIGZvciAobGV0IHkgPSBtaW5ZOyB5IDw9IG1heFk7IHkrKykge1xuICAgIGlmICh5IDwgeTIpIHtcbiAgICAgIGNvbnN0IGsgPSB5IDwgeTEgPyAwIDogKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogaztcbiAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogaztcbiAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogaztcbiAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogaztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5MiA9PT0geTMpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICB9XG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG4gICAgbGV0IGs7XG4gICAgaWYgKHkgPCB5MSkge1xuICAgICAgayA9IDA7XG4gICAgfSBlbHNlIGlmICh5ID4geTMpIHtcbiAgICAgIGsgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Myk7XG4gICAgfVxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcbiAgICBmb3IgKGxldCB4ID0geDFfOyB4IDw9IHgyXzsgeCsrKSB7XG4gICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG4gICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGsgPiAxKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfVxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KSB7XG4gIGNvbnN0IHBzID0gZmlndXJlLmNvb3JkcztcbiAgY29uc3QgY3MgPSBmaWd1cmUuY29sb3JzO1xuICBsZXQgaSwgaWk7XG4gIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICBjYXNlIFwibGF0dGljZVwiOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGZpZ3VyZVwiKTtcbiAgfVxufVxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlTWVzaENhbnZhcyhjb21iaW5lZFNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzKSB7XG4gICAgY29uc3QgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgY29uc3QgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1swXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzFdKTtcbiAgICBjb25zdCBib3VuZHNXaWR0aCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbMl0pIC0gb2Zmc2V0WDtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzV2lkdGggKiBjb21iaW5lZFNjYWxlWzBdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc0hlaWdodCAqIGNvbWJpbmVkU2NhbGVbMV0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGJvdW5kc0hlaWdodCAvIGhlaWdodDtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgY29vcmRzOiB0aGlzLl9jb29yZHMsXG4gICAgICBjb2xvcnM6IHRoaXMuX2NvbG9ycyxcbiAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogLW9mZnNldFksXG4gICAgICBzY2FsZVg6IDEgLyBzY2FsZVgsXG4gICAgICBzY2FsZVk6IDEgLyBzY2FsZVlcbiAgICB9O1xuICAgIGNvbnN0IHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgcGFkZGVkSGVpZ2h0ID0gaGVpZ2h0ICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGxldCBzY2FsZTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjb25zdCBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuX2NyZWF0ZU1lc2hDYW52YXMoc2NhbGUsIHBhdGhUeXBlID09PSBQYXRoVHlwZS5TSEFESU5HID8gbnVsbCA6IHRoaXMuX2JhY2tncm91bmQsIG93bmVyLmNhY2hlZENhbnZhc2VzKTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ub3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gIH1cbn1cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U2hhZGluZ1BhdHRlcm4oSVIpIHtcbiAgc3dpdGNoIChJUlswXSkge1xuICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgcmV0dXJuIG5ldyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgcmV0dXJuIG5ldyBEdW1teVNoYWRpbmdQYXR0ZXJuKCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7SVJbMF19YCk7XG59XG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcbmNsYXNzIFRpbGluZ1BhdHRlcm4ge1xuICBzdGF0aWMgTUFYX1BBVFRFUk5fU0laRSA9IDMwMDA7XG4gIGNvbnN0cnVjdG9yKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM10gfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gdGhpcy5vcGVyYXRvckxpc3Q7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuYmJveDtcbiAgICBjb25zdCB4c3RlcCA9IHRoaXMueHN0ZXA7XG4gICAgY29uc3QgeXN0ZXAgPSB0aGlzLnlzdGVwO1xuICAgIGNvbnN0IHBhaW50VHlwZSA9IHRoaXMucGFpbnRUeXBlO1xuICAgIGNvbnN0IHRpbGluZ1R5cGUgPSB0aGlzLnRpbGluZ1R5cGU7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgICgwLCBfdXRpbC5pbmZvKShcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgY29uc3QgY3VyTWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZSA9IFttYXRyaXhTY2FsZVswXSAqIGN1ck1hdHJpeFNjYWxlWzBdLCBtYXRyaXhTY2FsZVsxXSAqIGN1ck1hdHJpeFNjYWxlWzFdXTtcbiAgICBjb25zdCBkaW14ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeHN0ZXAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVswXSk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHlzdGVwLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0LCBjb21iaW5lZFNjYWxlWzFdKTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIGRpbXguc2l6ZSwgZGlteS5zaXplLCB0cnVlKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBncmFwaGljcyA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeS5jcmVhdGVDYW52YXNHcmFwaGljcyh0bXBDdHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICBsZXQgYWRqdXN0ZWRYMCA9IHgwO1xuICAgIGxldCBhZGp1c3RlZFkwID0geTA7XG4gICAgbGV0IGFkanVzdGVkWDEgPSB4MTtcbiAgICBsZXQgYWRqdXN0ZWRZMSA9IHkxO1xuICAgIGlmICh4MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWDAgPSAwO1xuICAgICAgYWRqdXN0ZWRYMSArPSBNYXRoLmFicyh4MCk7XG4gICAgfVxuICAgIGlmICh5MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWTAgPSAwO1xuICAgICAgYWRqdXN0ZWRZMSArPSBNYXRoLmFicyh5MCk7XG4gICAgfVxuICAgIHRtcEN0eC50cmFuc2xhdGUoLShkaW14LnNjYWxlICogYWRqdXN0ZWRYMCksIC0oZGlteS5zY2FsZSAqIGFkanVzdGVkWTApKTtcbiAgICBncmFwaGljcy50cmFuc2Zvcm0oZGlteC5zY2FsZSwgMCwgMCwgZGlteS5zY2FsZSwgMCwgMCk7XG4gICAgdG1wQ3R4LnNhdmUoKTtcbiAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCBhZGp1c3RlZFgwLCBhZGp1c3RlZFkwLCBhZGp1c3RlZFgxLCBhZGp1c3RlZFkxKTtcbiAgICBncmFwaGljcy5iYXNlVHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiB0bXBDYW52YXMuY2FudmFzLFxuICAgICAgc2NhbGVYOiBkaW14LnNjYWxlLFxuICAgICAgc2NhbGVZOiBkaW15LnNjYWxlLFxuICAgICAgb2Zmc2V0WDogYWRqdXN0ZWRYMCxcbiAgICAgIG9mZnNldFk6IGFkanVzdGVkWTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG4gICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gc2l6ZSAvIHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIGdyYXBoaWNzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZ3JhcGhpY3MuY3R4KSwgW3gwLCB5MCwgeDEsIHkxXSk7XG4gICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgIGdyYXBoaWNzLmVuZFBhdGgoKTtcbiAgfVxuICBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ3JhcGhpY3MuY3R4LFxuICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG4gICAgc3dpdGNoIChwYWludFR5cGUpIHtcbiAgICAgIGNhc2UgUGFpbnRUeXBlLkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN1cnJlbnQuZmlsbENvbG9yID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgIGNvbnN0IGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBfdXRpbC5Gb3JtYXRFcnJvcihgVW5zdXBwb3J0ZWQgcGFpbnQgdHlwZTogJHtwYWludFR5cGV9YCk7XG4gICAgfVxuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgbWF0cml4ID0gaW52ZXJzZTtcbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hdHJpeCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgbWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLmNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmV4cG9ydHMuVGlsaW5nUGF0dGVybiA9IFRpbGluZ1BhdHRlcm47XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEgPSBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQTtcbmV4cG9ydHMuY29udmVydFRvUkdCQSA9IGNvbnZlcnRUb1JHQkE7XG5leHBvcnRzLmdyYXlUb1JHQkEgPSBncmF5VG9SR0JBO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zLmtpbmQpIHtcbiAgICBjYXNlIF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShwYXJhbXMpO1xuICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0UkdCVG9SR0JBKHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbm9uQmxhY2tDb2xvciA9IDB4ZmZmZmZmZmYsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBibGFjayA9IF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gIGNvbnN0IFt6ZXJvTWFwcGluZywgb25lTWFwcGluZ10gPSBpbnZlcnNlRGVjb2RlID8gW25vbkJsYWNrQ29sb3IsIGJsYWNrXSA6IFtibGFjaywgbm9uQmxhY2tDb2xvcl07XG4gIGNvbnN0IHdpZHRoSW5Tb3VyY2UgPSB3aWR0aCA+PiAzO1xuICBjb25zdCB3aWR0aFJlbWFpbmRlciA9IHdpZHRoICYgNztcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgZGVzdCA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGxldCBkZXN0UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIGZvciAoY29uc3QgbWF4ID0gc3JjUG9zICsgd2lkdGhJblNvdXJjZTsgc3JjUG9zIDwgbWF4OyBzcmNQb3MrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1BvcysrXSA6IDI1NTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoUmVtYWluZGVyOyBqKyspIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAxIDw8IDcgLSBqID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UkdCVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICBkZXN0UG9zID0gMCxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbjMyID0gc3JjLmxlbmd0aCA+PiAyO1xuICBjb25zdCBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyLCBzcmNQb3MsIGxlbjMyKTtcbiAgaWYgKF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxID4+PiAyNCB8IHMyIDw8IDggfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA+Pj4gMTYgfCBzMyA8PCAxNiB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzID4+PiA4IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGkgKiA0LCBqaiA9IHNyYy5sZW5ndGg7IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gfCBzcmNbaiArIDFdIDw8IDggfCBzcmNbaiArIDJdIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxIDw8IDI0IHwgczIgPj4+IDggfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA8PCAxNiB8IHMzID4+PiAxNiB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzIDw8IDggfCAweGZmO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSA8PCAyNCB8IHNyY1tqICsgMV0gPDwgMTYgfCBzcmNbaiArIDJdIDw8IDggfCAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBncmF5VG9SR0JBKHNyYywgZGVzdCkge1xuICBpZiAoX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgZGVzdFtpXSA9IHNyY1tpXSAqIDB4MTAxMDEwMCB8IDB4MDAwMDAwZmY7XG4gICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IG51bGw7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IFwiXCI7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHJlYXNvbiA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwpKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAocmVhc29uLm5hbWUpIHtcbiAgICBjYXNlIFwiQWJvcnRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLmNvZGUpO1xuICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLmRldGFpbHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG59XG5jbGFzcyBNZXNzYWdlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZU5hbWUsIHRhcmdldE5hbWUsIGNvbU9iaikge1xuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBkYXRhLmNhbGxiYWNrSWQ7XG4gICAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGNhbGxiYWNrICR7Y2FsbGJhY2tJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgY29uc3QgY2JTb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgICAgICBjb25zdCBjYlRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICAgIH07XG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxuICBvbihhY3Rpb25OYW1lLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgYWggPSB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgaWYgKGFoW2FjdGlvbk5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIGFscmVhZHkgYW4gYWN0aW9uTmFtZSBjYWxsZWQgXCIke2FjdGlvbk5hbWV9XCJgKTtcbiAgICB9XG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG4gIHNlbmQoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgZGF0YVxuICAgIH0sIHRyYW5zZmVycyk7XG4gIH1cbiAgc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZTogdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgZGF0YVxuICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNlbmRXaXRoU3RyZWFtKGFjdGlvbk5hbWUsIGRhdGEsIHF1ZXVlaW5nU3RyYXRlZ3ksIHRyYW5zZmVycykge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCA9IHB1bGxDYXBhYmlsaXR5O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRVJST1IsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2lua0NhcGFiaWxpdHk6IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpLFxuICAgICAgb25QdWxsOiBudWxsLFxuICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICBpc0NhbmNlbGxlZDogZmFsc2UsXG4gICAgICBkZXNpcmVkU2l6ZTogZGF0YS5kZXNpcmVkU2l6ZSxcbiAgICAgIHJlYWR5OiBudWxsXG4gICAgfTtcbiAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdID0gc3RyZWFtU2luaztcbiAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhLCBzdHJlYW1TaW5rKSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgIHN0cmVhbVNpbmsgPSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTEw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPD0gMCAmJiBkYXRhLmRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vblB1bGw/LigpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lbnF1ZXVlKGRhdGEuY2h1bmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25DYW5jZWw/Lih3cmFwUmVhc29uKGRhdGEucmVhc29uKSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgfVxuICB9XG4gIGFzeW5jICNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKFtzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbD8ucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsPy5wcm9taXNlXSk7XG4gICAgZGVsZXRlIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG59XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gTWVzc2FnZUhhbmRsZXI7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgTWV0YWRhdGEge1xuICAjbWV0YWRhdGFNYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyc2VkRGF0YSxcbiAgICByYXdEYXRhXG4gIH0pIHtcbiAgICB0aGlzLiNtZXRhZGF0YU1hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhTWFwLmdldChuYW1lKSA/PyBudWxsO1xuICB9XG4gIGdldEFsbCgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLm9iamVjdEZyb21NYXApKHRoaXMuI21ldGFkYXRhTWFwKTtcbiAgfVxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9tdXJtdXJoYXNoID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICN2aXNpYmxlID0gdHJ1ZTtcbiAgY29uc3RydWN0b3IobmFtZSwgaW50ZW50KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgfVxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgfVxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLiN2aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxufVxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEdldEhhc2ggPSBudWxsO1xuICAjZ3JvdXBzID0gbmV3IE1hcCgpO1xuICAjaW5pdGlhbEhhc2ggPSBudWxsO1xuICAjb3JkZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy4jb3JkZXIgPSBkYXRhLm9yZGVyO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZGF0YS5ncm91cHMpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5zZXQoZ3JvdXAuaWQsIG5ldyBPcHRpb25hbENvbnRlbnRHcm91cChncm91cC5uYW1lLCBncm91cC5pbnRlbnQpKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHRoaXMuI2dyb3Vwcy52YWx1ZXMoKSkge1xuICAgICAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9uIG9mIGRhdGEub24pIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob24pLl9zZXRWaXNpYmxlKElOVEVSTkFMLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsSGFzaCA9IHRoaXMuZ2V0SGFzaCgpO1xuICB9XG4gICNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGFycmF5KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICBsZXQgc3RhdGU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI2dyb3Vwcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNncm91cHMuZ2V0KGVsZW1lbnQpLnZpc2libGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZGVmaW5lZC5cIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChncm91cC5pZCkudmlzaWJsZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihncm91cC5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAoMCwgX3V0aWwud2FybikoYFVua25vd24gb3B0aW9uYWwgY29udGVudCBwb2xpY3kgJHtncm91cC5wb2xpY3l9LmApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICgwLCBfdXRpbC53YXJuKShgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0VmlzaWJpbGl0eShpZCwgdmlzaWJsZSA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNncm91cHMuZ2V0KGlkKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luaXRpYWxIYXNoID09PSBudWxsIHx8IHRoaXMuZ2V0SGFzaCgpID09PSB0aGlzLiNpbml0aWFsSGFzaDtcbiAgfVxuICBnZXRPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLiNncm91cHMua2V5cygpXTtcbiAgfVxuICBnZXRHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5zaXplID4gMCA/ICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxufVxuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSBPcHRpb25hbENvbnRlbnRDb25maWc7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBsZW5ndGgsXG4gICAgaW5pdGlhbERhdGEsXG4gICAgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsXG4gICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsLFxuICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgIGRpc2FibGVTdHJlYW0gPSBmYWxzZVxuICB9LCBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KShwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGNodW5rID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cbiAgX29uUmVjZWl2ZURhdGEoe1xuICAgIGJlZ2luLFxuICAgIGNodW5rXG4gIH0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgY2h1bmsuYnl0ZUxlbmd0aCA9PT0gY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPyBjaHVuay5idWZmZXIgOiBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIGlmIChiZWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNvbWUoZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlUmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKGV2dC50b3RhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnNbMF0/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LnByb2dyZXNzaXZlRG9uZSgpO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHRydWU7XG4gIH1cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHF1ZXVlZENodW5rcywgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9kb25lID0gcHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZSkoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZGZXRjaFN0cmVhbSA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbjtcbmZ1bmN0aW9uIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB3aXRoQ3JlZGVudGlhbHMsIGFib3J0Q29udHJvbGxlcikge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzLFxuICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGhlYWRlcnMuYXBwZW5kKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gICgwLCBfdXRpbC53YXJuKShgZ2V0QXJyYXlCdWZmZXIgLSB1bmV4cGVjdGVkIGRhdGEgZm9ybWF0OiAke3ZhbH1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCkuYnVmZmVyO1xufVxuY2xhc3MgUERGRmV0Y2hTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gUERGRmV0Y2hTdHJlYW07XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cykocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX3N0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCh0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICB0aGlzLl9oZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIGBieXRlcz0ke2JlZ2lufS0ke2VuZCAtIDF9YCk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cykocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KS5jYXRjaCh0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogZ2V0QXJyYXlCdWZmZXIodmFsdWUpLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9yZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3I7XG5leHBvcnRzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyO1xuZXhwb3J0cy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzO1xuZXhwb3J0cy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzID0gdmFsaWRhdGVSZXNwb25zZVN0YXR1cztcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIGdldFJlc3BvbnNlSGVhZGVyLFxuICBpc0h0dHAsXG4gIHJhbmdlQ2h1bmtTaXplLFxuICBkaXNhYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSAoMCwgX2NvbnRlbnRfZGlzcG9zaXRpb24uZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKShjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKCgwLCBfZGlzcGxheV91dGlscy5pc1BkZkZpbGUpKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgaWYgKHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXI7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOZXR3b3JrU3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuO1xuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuICgwLCBfdXRpbC5zdHJpbmdUb0J5dGVzKShkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgYXJncyA9IHt9KSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIGFyZ3MuaHR0cEhlYWRlcnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGxpc3RlbmVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZFxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgfVxuICByZXF1ZXN0RnVsbChsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdGhpcy5odHRwSGVhZGVycykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIocHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBnZXRBcnJheUJ1ZmZlcih4aHIpO1xuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZS51cmwsIHtcbiAgICAgIGh0dHBIZWFkZXJzOiBzb3VyY2UuaHR0cEhlYWRlcnMsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNvdXJjZS53aXRoQ3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IFBERk5ldHdvcmtTdHJlYW07XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RGdWxsKGFyZ3MpO1xuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gZnVsbFJlcXVlc3RYaHIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgYXJncyk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX2Nsb3NlKCkge1xuICAgIHRoaXMub25DbG9zZWQ/Lih0aGlzKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBjb25zdCBjaHVuayA9IGRhdGEuY2h1bms7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOb2RlU3RyZWFtID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuO1xuY29uc3QgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5mdW5jdGlvbiBwYXJzZVVybChzb3VyY2VVcmwpIHtcbiAgY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cbiAgaWYgKC9eW2Etel06Wy9cXFxcXS9pLnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiB1cmwucGFyc2UoYGZpbGU6Ly8vJHtzb3VyY2VVcmx9YCk7XG4gIH1cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCkge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9IFwiZmlsZTpcIjtcbiAgfVxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCkgOiBuZXcgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG4gICAgcmV0dXJuIHJhbmdlUmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuY2xhc3MgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhwYXJzZWRVcmwsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHBhcnNlZFVybC5hdXRoLFxuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0cmVhbS5oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIHRoaXMuX2h0dHBIZWFkZXJzID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHJlYW0uaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RyZWFtLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5faHR0cEhlYWRlcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuX2h0dHBIZWFkZXJzLlJhbmdlID0gYGJ5dGVzPSR7c3RhcnR9LSR7ZW5kIC0gMX1gO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHRoaXMuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5fdXJsLnBhdGgpO1xuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgZnMubHN0YXQocGF0aCwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7cGF0aH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSB2b2lkIDA7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbjtcbmNvbnN0IFNWR19ERUZBVUxUUyA9IHtcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBmaWxsQ29sb3I6IFwiIzAwMDAwMFwiXG59O1xuY29uc3QgWE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbmNvbnN0IFhMSU5LX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgY3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRlbnRUeXBlID0gXCJcIiwgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgaWYgKFVSTC5jcmVhdGVPYmplY3RVUkwgJiYgdHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgIWZvcmNlRGF0YVNjaGVtYSkge1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtkYXRhXSwge1xuICAgICAgdHlwZTogY29udGVudFR5cGVcbiAgICB9KSk7XG4gIH1cbiAgY29uc3QgZGlnaXRzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICBsZXQgYnVmZmVyID0gYGRhdGE6JHtjb250ZW50VHlwZX07YmFzZTY0LGA7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgIGNvbnN0IGIxID0gZGF0YVtpXSAmIDB4ZmY7XG4gICAgY29uc3QgYjIgPSBkYXRhW2kgKyAxXSAmIDB4ZmY7XG4gICAgY29uc3QgYjMgPSBkYXRhW2kgKyAyXSAmIDB4ZmY7XG4gICAgY29uc3QgZDEgPSBiMSA+PiAyLFxuICAgICAgZDIgPSAoYjEgJiAzKSA8PCA0IHwgYjIgPj4gNDtcbiAgICBjb25zdCBkMyA9IGkgKyAxIDwgaWkgPyAoYjIgJiAweGYpIDw8IDIgfCBiMyA+PiA2IDogNjQ7XG4gICAgY29uc3QgZDQgPSBpICsgMiA8IGlpID8gYjMgJiAweDNmIDogNjQ7XG4gICAgYnVmZmVyICs9IGRpZ2l0c1tkMV0gKyBkaWdpdHNbZDJdICsgZGlnaXRzW2QzXSArIGRpZ2l0c1tkNF07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5jb25zdCBjb252ZXJ0SW1nRGF0YVRvUG5nID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBQTkdfSEVBREVSID0gbmV3IFVpbnQ4QXJyYXkoWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdKTtcbiAgY29uc3QgQ0hVTktfV1JBUFBFUl9TSVpFID0gMTI7XG4gIGNvbnN0IGNyY1RhYmxlID0gbmV3IEludDMyQXJyYXkoMjU2KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIGxldCBjID0gaTtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IDg7IGgrKykge1xuICAgICAgYyA9IGMgJiAxID8gMHhlZGI4ODMyMCBeIGMgPj4gMSAmIDB4N2ZmZmZmZmYgOiBjID4+IDEgJiAweDdmZmZmZmZmO1xuICAgIH1cbiAgICBjcmNUYWJsZVtpXSA9IGM7XG4gIH1cbiAgZnVuY3Rpb24gY3JjMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBjcmMgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgYSA9IChjcmMgXiBkYXRhW2ldKSAmIDB4ZmY7XG4gICAgICBjb25zdCBiID0gY3JjVGFibGVbYV07XG4gICAgICBjcmMgPSBjcmMgPj4+IDggXiBiO1xuICAgIH1cbiAgICByZXR1cm4gY3JjIF4gLTE7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVQbmdDaHVuayh0eXBlLCBib2R5LCBkYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgcCA9IG9mZnNldDtcbiAgICBjb25zdCBsZW4gPSBib2R5Lmxlbmd0aDtcbiAgICBkYXRhW3BdID0gbGVuID4+IDI0ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IGxlbiA+PiAxNiAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSBsZW4gJiAweGZmO1xuICAgIHAgKz0gNDtcbiAgICBkYXRhW3BdID0gdHlwZS5jaGFyQ29kZUF0KDApICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IHR5cGUuY2hhckNvZGVBdCgxKSAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSB0eXBlLmNoYXJDb2RlQXQoMikgJiAweGZmO1xuICAgIGRhdGFbcCArIDNdID0gdHlwZS5jaGFyQ29kZUF0KDMpICYgMHhmZjtcbiAgICBwICs9IDQ7XG4gICAgZGF0YS5zZXQoYm9keSwgcCk7XG4gICAgcCArPSBib2R5Lmxlbmd0aDtcbiAgICBjb25zdCBjcmMgPSBjcmMzMihkYXRhLCBvZmZzZXQgKyA0LCBwKTtcbiAgICBkYXRhW3BdID0gY3JjID4+IDI0ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAxXSA9IGNyYyA+PiAxNiAmIDB4ZmY7XG4gICAgZGF0YVtwICsgMl0gPSBjcmMgPj4gOCAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSBjcmMgJiAweGZmO1xuICB9XG4gIGZ1bmN0aW9uIGFkbGVyMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBhID0gMTtcbiAgICBsZXQgYiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGEgPSAoYSArIChkYXRhW2ldICYgMHhmZikpICUgNjU1MjE7XG4gICAgICBiID0gKGIgKyBhKSAlIDY1NTIxO1xuICAgIH1cbiAgICByZXR1cm4gYiA8PCAxNiB8IGE7XG4gIH1cbiAgZnVuY3Rpb24gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpIHtcbiAgICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgaW5wdXQgPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUpID49IDggPyBsaXRlcmFscyA6IEJ1ZmZlci5mcm9tKGxpdGVyYWxzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHJlcXVpcmUoXCJ6bGliXCIpLmRlZmxhdGVTeW5jKGlucHV0LCB7XG4gICAgICAgIGxldmVsOiA5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXRwdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gb3V0cHV0IDogbmV3IFVpbnQ4QXJyYXkob3V0cHV0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJOb3QgY29tcHJlc3NpbmcgUE5HIGJlY2F1c2UgemxpYi5kZWZsYXRlU3luYyBpcyB1bmF2YWlsYWJsZTogXCIgKyBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgfVxuICBmdW5jdGlvbiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscykge1xuICAgIGxldCBsZW4gPSBsaXRlcmFscy5sZW5ndGg7XG4gICAgY29uc3QgbWF4QmxvY2tMZW5ndGggPSAweGZmZmY7XG4gICAgY29uc3QgZGVmbGF0ZUJsb2NrcyA9IE1hdGguY2VpbChsZW4gLyBtYXhCbG9ja0xlbmd0aCk7XG4gICAgY29uc3QgaWRhdCA9IG5ldyBVaW50OEFycmF5KDIgKyBsZW4gKyBkZWZsYXRlQmxvY2tzICogNSArIDQpO1xuICAgIGxldCBwaSA9IDA7XG4gICAgaWRhdFtwaSsrXSA9IDB4Nzg7XG4gICAgaWRhdFtwaSsrXSA9IDB4OWM7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgd2hpbGUgKGxlbiA+IG1heEJsb2NrTGVuZ3RoKSB7XG4gICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zLCBwb3MgKyBtYXhCbG9ja0xlbmd0aCksIHBpKTtcbiAgICAgIHBpICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgcG9zICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgbGVuIC09IG1heEJsb2NrTGVuZ3RoO1xuICAgIH1cbiAgICBpZGF0W3BpKytdID0gMHgwMTtcbiAgICBpZGF0W3BpKytdID0gbGVuICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gbGVuID4+IDggJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSB+bGVuICYgMHhmZmZmICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gKH5sZW4gJiAweGZmZmYpID4+IDggJiAweGZmO1xuICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcyksIHBpKTtcbiAgICBwaSArPSBsaXRlcmFscy5sZW5ndGggLSBwb3M7XG4gICAgY29uc3QgYWRsZXIgPSBhZGxlcjMyKGxpdGVyYWxzLCAwLCBsaXRlcmFscy5sZW5ndGgpO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAyNCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDE2ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gOCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyICYgMHhmZjtcbiAgICByZXR1cm4gaWRhdDtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgbGV0IGJpdERlcHRoLCBjb2xvclR5cGUsIGxpbmVTaXplO1xuICAgIGNvbnN0IGJ5dGVzID0gaW1nRGF0YS5kYXRhO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICAgIGNvbG9yVHlwZSA9IDA7XG4gICAgICAgIGJpdERlcHRoID0gMTtcbiAgICAgICAgbGluZVNpemUgPSB3aWR0aCArIDcgPj4gMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICAgIGNvbG9yVHlwZSA9IDI7XG4gICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gNjtcbiAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgY29uc3QgbGl0ZXJhbHMgPSBuZXcgVWludDhBcnJheSgoMSArIGxpbmVTaXplKSAqIGhlaWdodCk7XG4gICAgbGV0IG9mZnNldExpdGVyYWxzID0gMCxcbiAgICAgIG9mZnNldEJ5dGVzID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICBsaXRlcmFsc1tvZmZzZXRMaXRlcmFscysrXSA9IDA7XG4gICAgICBsaXRlcmFscy5zZXQoYnl0ZXMuc3ViYXJyYXkob2Zmc2V0Qnl0ZXMsIG9mZnNldEJ5dGVzICsgbGluZVNpemUpLCBvZmZzZXRMaXRlcmFscyk7XG4gICAgICBvZmZzZXRCeXRlcyArPSBsaW5lU2l6ZTtcbiAgICAgIG9mZnNldExpdGVyYWxzICs9IGxpbmVTaXplO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQICYmIGlzTWFzaykge1xuICAgICAgb2Zmc2V0TGl0ZXJhbHMgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBvZmZzZXRMaXRlcmFscysrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVTaXplOyBpKyspIHtcbiAgICAgICAgICBsaXRlcmFsc1tvZmZzZXRMaXRlcmFscysrXSBePSAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGloZHIgPSBuZXcgVWludDhBcnJheShbd2lkdGggPj4gMjQgJiAweGZmLCB3aWR0aCA+PiAxNiAmIDB4ZmYsIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIGhlaWdodCA+PiAyNCAmIDB4ZmYsIGhlaWdodCA+PiAxNiAmIDB4ZmYsIGhlaWdodCA+PiA4ICYgMHhmZiwgaGVpZ2h0ICYgMHhmZiwgYml0RGVwdGgsIGNvbG9yVHlwZSwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuICAgIGNvbnN0IGlkYXQgPSBkZWZsYXRlU3luYyhsaXRlcmFscyk7XG4gICAgY29uc3QgcG5nTGVuZ3RoID0gUE5HX0hFQURFUi5sZW5ndGggKyBDSFVOS19XUkFQUEVSX1NJWkUgKiAzICsgaWhkci5sZW5ndGggKyBpZGF0Lmxlbmd0aDtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkocG5nTGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBkYXRhLnNldChQTkdfSEVBREVSLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBQTkdfSEVBREVSLmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSUhEUlwiLCBpaGRyLCBkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpaGRyLmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSURBVEFcIiwgaWRhdCwgZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gQ0hVTktfV1JBUFBFUl9TSVpFICsgaWRhdC5sZW5ndGg7XG4gICAgd3JpdGVQbmdDaHVuayhcIklFTkRcIiwgbmV3IFVpbnQ4QXJyYXkoMCksIGRhdGEsIG9mZnNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBcImltYWdlL3BuZ1wiLCBmb3JjZURhdGFTY2hlbWEpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiBjb252ZXJ0SW1nRGF0YVRvUG5nKGltZ0RhdGEsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKSB7XG4gICAgY29uc3Qga2luZCA9IGltZ0RhdGEua2luZCA9PT0gdW5kZWZpbmVkID8gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQIDogaW1nRGF0YS5raW5kO1xuICAgIHJldHVybiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spO1xuICB9O1xufSgpO1xuY2xhc3MgU1ZHRXh0cmFTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQ7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVYID0gMDtcbiAgICB0aGlzLmxpbmVZID0gMDtcbiAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmxpbmVKb2luID0gXCJcIjtcbiAgICB0aGlzLmxpbmVDYXAgPSBcIlwiO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IDA7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBbXTtcbiAgICB0aGlzLmRhc2hQaGFzZSA9IDA7XG4gICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNsaXBVcmwgPSBudWxsO1xuICAgIHRoaXMuY2xpcEdyb3VwID0gbnVsbDtcbiAgICB0aGlzLm1hc2tJZCA9IFwiXCI7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gIH1cbiAgc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wTGlzdFRvVHJlZShvcExpc3QpIHtcbiAgbGV0IG9wVHJlZSA9IFtdO1xuICBjb25zdCB0bXAgPSBbXTtcbiAgZm9yIChjb25zdCBvcExpc3RFbGVtZW50IG9mIG9wTGlzdCkge1xuICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInNhdmVcIikge1xuICAgICAgb3BUcmVlLnB1c2goe1xuICAgICAgICBmbklkOiA5MixcbiAgICAgICAgZm46IFwiZ3JvdXBcIixcbiAgICAgICAgaXRlbXM6IFtdXG4gICAgICB9KTtcbiAgICAgIHRtcC5wdXNoKG9wVHJlZSk7XG4gICAgICBvcFRyZWUgPSBvcFRyZWUuYXQoLTEpLml0ZW1zO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInJlc3RvcmVcIikge1xuICAgICAgb3BUcmVlID0gdG1wLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcFRyZWUucHVzaChvcExpc3RFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wVHJlZTtcbn1cbmZ1bmN0aW9uIHBmKHZhbHVlKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGNvbnN0IHMgPSB2YWx1ZS50b0ZpeGVkKDEwKTtcbiAgbGV0IGkgPSBzLmxlbmd0aCAtIDE7XG4gIGlmIChzW2ldICE9PSBcIjBcIikge1xuICAgIHJldHVybiBzO1xuICB9XG4gIGRvIHtcbiAgICBpLS07XG4gIH0gd2hpbGUgKHNbaV0gPT09IFwiMFwiKTtcbiAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIHNbaV0gPT09IFwiLlwiID8gaSA6IGkgKyAxKTtcbn1cbmZ1bmN0aW9uIHBtKG0pIHtcbiAgaWYgKG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgIGlmIChtWzBdID09PSAxICYmIG1bM10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYHNjYWxlKCR7cGYobVswXSl9ICR7cGYobVszXSl9KWA7XG4gICAgfVxuICAgIGlmIChtWzBdID09PSBtWzNdICYmIG1bMV0gPT09IC1tWzJdKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5hY29zKG1bMF0pICogMTgwIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiBgcm90YXRlKCR7cGYoYSl9KWA7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1bMF0gPT09IDEgJiYgbVsxXSA9PT0gMCAmJiBtWzJdID09PSAwICYmIG1bM10gPT09IDEpIHtcbiAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3BmKG1bNF0pfSAke3BmKG1bNV0pfSlgO1xuICB9XG4gIHJldHVybiBgbWF0cml4KCR7cGYobVswXSl9ICR7cGYobVsxXSl9ICR7cGYobVsyXSl9ICR7cGYobVszXSl9ICR7cGYobVs0XSl9IGAgKyBgJHtwZihtWzVdKX0pYDtcbn1cbmxldCBjbGlwQ291bnQgPSAwO1xubGV0IG1hc2tDb3VudCA9IDA7XG5sZXQgc2hhZGluZ0NvdW50ID0gMDtcbmNsYXNzIFNWR0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY29tbW9uT2Jqcywgb2JqcywgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgU1ZHIGJhY2stZW5kIGlzIG5vIGxvbmdlciBtYWludGFpbmVkIGFuZCAqbWF5KiBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCk7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IFNWR0V4dHJhU3RhdGUoKTtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgdGhpcy5leHRyYVN0YWNrID0gW107XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZW1iZWRGb250cyA9IGZhbHNlO1xuICAgIHRoaXMuZW1iZWRkZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jc3NTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5mb3JjZURhdGFTY2hlbWEgPSAhIWZvcmNlRGF0YVNjaGVtYTtcbiAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3AgaW4gX3V0aWwuT1BTKSB7XG4gICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZ1tfdXRpbC5PUFNbb3BdXSA9IG9wO1xuICAgIH1cbiAgfVxuICBnZXRPYmplY3QoZGF0YSwgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5leHRyYVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuICByZXN0b3JlKCkge1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmV4dHJhU3RhY2sucG9wKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBncm91cChpdGVtcykge1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuZXhlY3V0ZU9wVHJlZShpdGVtcyk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgbG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChmbkFycmF5W2ldICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICBjb25zdCBvYmpzUG9vbCA9IG9iai5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMgOiB0aGlzLm9ianM7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBvYmpzUG9vbC5nZXQob2JqLCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMucHVzaChwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBnZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydCkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy5faW5pdGlhbGl6ZSh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgfSk7XG4gIH1cbiAgY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBvcGVyYXRvcklkTWFwcGluZyA9IHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nO1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGNvbnN0IG9wTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZuQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICBvcExpc3QucHVzaCh7XG4gICAgICAgIGZuSWQsXG4gICAgICAgIGZuOiBvcGVyYXRvcklkTWFwcGluZ1tmbklkXSxcbiAgICAgICAgYXJnczogYXJnc0FycmF5W2ldXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wTGlzdFRvVHJlZShvcExpc3QpO1xuICB9XG4gIGV4ZWN1dGVPcFRyZWUob3BUcmVlKSB7XG4gICAgZm9yIChjb25zdCBvcFRyZWVFbGVtZW50IG9mIG9wVHJlZSkge1xuICAgICAgY29uc3QgZm4gPSBvcFRyZWVFbGVtZW50LmZuO1xuICAgICAgY29uc3QgZm5JZCA9IG9wVHJlZUVsZW1lbnQuZm5JZDtcbiAgICAgIGNvbnN0IGFyZ3MgPSBvcFRyZWVFbGVtZW50LmFyZ3M7XG4gICAgICBzd2l0Y2ggKGZuSWQgfCAwKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmJlZ2luVGV4dDpcbiAgICAgICAgICB0aGlzLmJlZ2luVGV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5kZXBlbmRlbmN5OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nOlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZyhhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZ01vdmVUZXh0OlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZ01vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGb250OlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1RleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1NwYWNlZFRleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kVGV4dDpcbiAgICAgICAgICB0aGlzLmVuZFRleHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRleHQ6XG4gICAgICAgICAgdGhpcy5tb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Q2hhclNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRDaGFyU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0V29yZFNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRXb3JkU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0SFNjYWxlOlxuICAgICAgICAgIHRoaXMuc2V0SFNjYWxlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0TWF0cml4OlxuICAgICAgICAgIHRoaXMuc2V0VGV4dE1hdHJpeChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJpc2U6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmlzZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJlbmRlcmluZ01vZGU6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmVuZGVyaW5nTW9kZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZVdpZHRoOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lSm9pbjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lQ2FwOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TWl0ZXJMaW1pdDpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxSR0JDb2xvcjpcbiAgICAgICAgICB0aGlzLnNldEZpbGxSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlUkdCQ29sb3I6XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yTihhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hhZGluZ0ZpbGw6XG4gICAgICAgICAgdGhpcy5zaGFkaW5nRmlsbChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RGFzaDpcbiAgICAgICAgICB0aGlzLnNldERhc2goYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFJlbmRlcmluZ0ludGVudDpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmxhdG5lc3M6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0R1N0YXRlOlxuICAgICAgICAgIHRoaXMuc2V0R1N0YXRlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsOlxuICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGw6XG4gICAgICAgICAgdGhpcy5lb0ZpbGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc3Ryb2tlOlxuICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmVvRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbGlwOlxuICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvQ2xpcDpcbiAgICAgICAgICB0aGlzLmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6XG4gICAgICAgICAgdGhpcy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludEltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0OlxuICAgICAgICAgIHRoaXMucGFpbnRJbWFnZU1hc2tYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0QmVnaW46XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0QmVnaW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RFbmQ6XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0RW5kKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUVPRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRU9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm5leHRMaW5lOlxuICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMudHJhbnNmb3JtOlxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jb25zdHJ1Y3RQYXRoOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0UGF0aChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kUGF0aDpcbiAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICB0aGlzLmdyb3VwKG9wVHJlZUVsZW1lbnQuaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBvcGVyYXRvciAke2ZufWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRXb3JkU3BhY2luZyh3b3JkU3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHdvcmRTcGFjaW5nO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKGNoYXJTcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gY2hhclNwYWNpbmc7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBjdXJyZW50LmxpbmVNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgY3VycmVudC5saW5lTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dGV4dFwiKTtcbiAgICBjdXJyZW50LnR4dGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCArPSB4O1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgKz0geTtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICBpZiAoZ2x5cGggPT09IG51bGwpIHtcbiAgICAgICAgeCArPSBmb250RGlyZWN0aW9uICogd29yZFNwYWNpbmc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgIHZ4ID0gLXZ4ICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSB7XG4gICAgICAgIGN1cnJlbnQueGNvb3Jkcy5wdXNoKGN1cnJlbnQueCArIHNjYWxlZFgpO1xuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjdXJyZW50Lnljb29yZHMucHVzaCgtY3VycmVudC55ICsgc2NhbGVkWSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC50c3Bhbi50ZXh0Q29udGVudCArPSBjaGFyYWN0ZXI7XG4gICAgICB9IGVsc2Uge31cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGN1cnJlbnQueGNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGN1cnJlbnQueWNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICBpZiAoY3VycmVudC5mb250U3R5bGUgIT09IFNWR19ERUZBVUxUUy5mb250U3R5bGUpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXN0eWxlXCIsIGN1cnJlbnQuZm9udFN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZm9udFdlaWdodCAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXdlaWdodFwiLCBjdXJyZW50LmZvbnRXZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgIGlmIChjdXJyZW50LmZpbGxDb2xvciAhPT0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcikge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEgpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICB9XG4gICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGhTY2FsZSA9IDEgLyAoY3VycmVudC50ZXh0TWF0cml4U2NhbGUgfHwgMSk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQudHNwYW4sIGxpbmVXaWR0aFNjYWxlKTtcbiAgICB9XG4gICAgbGV0IHRleHRNYXRyaXggPSBjdXJyZW50LnRleHRNYXRyaXg7XG4gICAgaWYgKGN1cnJlbnQudGV4dFJpc2UgIT09IDApIHtcbiAgICAgIHRleHRNYXRyaXggPSB0ZXh0TWF0cml4LnNsaWNlKCk7XG4gICAgICB0ZXh0TWF0cml4WzVdICs9IGN1cnJlbnQudGV4dFJpc2U7XG4gICAgfVxuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBgJHtwbSh0ZXh0TWF0cml4KX0gc2NhbGUoJHtwZih0ZXh0SFNjYWxlKX0sIC0xKWApO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhYTUxfTlMsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgICBjdXJyZW50LnR4dGdycC5hcHBlbmQoY3VycmVudC50eHRFbGVtZW50KTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIGFkZEZvbnRTdHlsZShmb250T2JqKSB7XG4gICAgaWYgKCFmb250T2JqLmRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEZvbnRTdHlsZTogTm8gZm9udCBkYXRhIGF2YWlsYWJsZSwgXCIgKyAnZW5zdXJlIHRoYXQgdGhlIFwiZm9udEV4dHJhUHJvcGVydGllc1wiIEFQSSBwYXJhbWV0ZXIgaXMgc2V0LicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuY3NzU3R5bGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdHlsZVwiKTtcbiAgICAgIHRoaXMuY3NzU3R5bGUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kKHRoaXMuY3NzU3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZm9udE9iai5kYXRhLCBmb250T2JqLm1pbWV0eXBlLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSk7XG4gICAgdGhpcy5jc3NTdHlsZS50ZXh0Q29udGVudCArPSBgQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIiR7Zm9udE9iai5sb2FkZWROYW1lfVwiO2AgKyBgIHNyYzogdXJsKCR7dXJsfSk7IH1cXG5gO1xuICB9XG4gIHNldEZvbnQoZGV0YWlscykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGV0YWlsc1swXSk7XG4gICAgbGV0IHNpemUgPSBkZXRhaWxzWzFdO1xuICAgIGN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgaWYgKHRoaXMuZW1iZWRGb250cyAmJiAhZm9udE9iai5taXNzaW5nRmlsZSAmJiAhdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0pIHtcbiAgICAgIHRoaXMuYWRkRm9udFN0eWxlKGZvbnRPYmopO1xuICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0gPSBmb250T2JqO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICBjdXJyZW50LmZvbnRXZWlnaHQgPSBib2xkO1xuICAgIGN1cnJlbnQuZm9udFN0eWxlID0gaXRhbGljO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyAmJiBjdXJyZW50LnR4dEVsZW1lbnQ/Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC50eHRFbGVtZW50O1xuICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5jdXJyZW50Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXRTdHJva2VBbHBoYShzdHJva2VBbHBoYSkge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHN0cm9rZUFscGhhO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgfVxuICBzZXRGaWxsQWxwaGEoZmlsbEFscGhhKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IGZpbGxBbHBoYTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICB0aGlzLmN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihhcmdzKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgfVxuICBzaGFkaW5nRmlsbChhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB4MSAtIHgwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHkxIC0geTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSk7XG4gICAgaWYgKHRoaXMuY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIHRoaXMuY3VycmVudC5maWxsQWxwaGEpO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgfVxuICBfbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAoYXJnc1swXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKTtcbiAgfVxuICBfbWFrZVRpbGluZ1BhdHRlcm4oYXJncykge1xuICAgIGNvbnN0IGNvbG9yID0gYXJnc1sxXTtcbiAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBhcmdzWzJdO1xuICAgIGNvbnN0IG1hdHJpeCA9IGFyZ3NbM10gfHwgX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBhcmdzWzRdO1xuICAgIGNvbnN0IHhzdGVwID0gYXJnc1s1XTtcbiAgICBjb25zdCB5c3RlcCA9IGFyZ3NbNl07XG4gICAgY29uc3QgcGFpbnRUeXBlID0gYXJnc1s3XTtcbiAgICBjb25zdCB0aWxpbmdJZCA9IGBzaGFkaW5nJHtzaGFkaW5nQ291bnQrK31gO1xuICAgIGNvbnN0IFt0eDAsIHR5MCwgdHgxLCB0eTFdID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFsuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MCwgeTBdLCBtYXRyaXgpLCAuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MSwgeTFdLCBtYXRyaXgpXSk7XG4gICAgY29uc3QgW3hzY2FsZSwgeXNjYWxlXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KTtcbiAgICBjb25zdCB0eHN0ZXAgPSB4c3RlcCAqIHhzY2FsZTtcbiAgICBjb25zdCB0eXN0ZXAgPSB5c3RlcCAqIHlzY2FsZTtcbiAgICBjb25zdCB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHRpbGluZ0lkKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB0eXN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYCR7dHgwfWApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYCR7dHkwfWApO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnO1xuICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtTWF0cml4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodHgxIC0gdHgwLCB0eTEgLSB0eTApO1xuICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeDtcbiAgICBpZiAocGFpbnRUeXBlID09PSAyKSB7XG4gICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdHJhbnNmb3JtTWF0cml4O1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgdGlsaW5nLmFwcGVuZChiYm94LmNoaWxkTm9kZXNbMF0pO1xuICAgIHRoaXMuZGVmcy5hcHBlbmQodGlsaW5nKTtcbiAgICByZXR1cm4gYHVybCgjJHt0aWxpbmdJZH0pYDtcbiAgfVxuICBfbWFrZVNoYWRpbmdQYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGFyZ3MgPSB0aGlzLm9ianMuZ2V0KGFyZ3MpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgICBjb25zdCBzaGFkaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcbiAgICAgICAgY29uc3QgY29sb3JTdG9wcyA9IGFyZ3NbM107XG4gICAgICAgIGxldCBncmFkaWVudDtcbiAgICAgICAgc3dpdGNoIChhcmdzWzFdKSB7XG4gICAgICAgICAgY2FzZSBcImF4aWFsXCI6XG4gICAgICAgICAgICBjb25zdCBwb2ludDAgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQxID0gYXJnc1s1XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZWFyR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDFcIiwgcG9pbnQwWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTFcIiwgcG9pbnQwWzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDJcIiwgcG9pbnQxWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTJcIiwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyYWRpYWxcIjpcbiAgICAgICAgICAgIGNvbnN0IGZvY2FsUG9pbnQgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUG9pbnQgPSBhcmdzWzVdO1xuICAgICAgICAgICAgY29uc3QgZm9jYWxSYWRpdXMgPSBhcmdzWzZdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gYXJnc1s3XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmFkaWFsR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgY2lyY2xlUG9pbnRbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBjaXJjbGVQb2ludFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnhcIiwgZm9jYWxQb2ludFswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZ5XCIsIGZvY2FsUG9pbnRbMV0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmclwiLCBmb2NhbFJhZGl1cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFJhZGlhbEF4aWFsIHR5cGU6ICR7YXJnc1sxXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0b3BcIik7XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9mZnNldFwiLCBjb2xvclN0b3BbMF0pO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdG9wLWNvbG9yXCIsIGNvbG9yU3RvcFsxXSk7XG4gICAgICAgICAgZ3JhZGllbnQuYXBwZW5kKHN0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmcy5hcHBlbmQoZ3JhZGllbnQpO1xuICAgICAgICByZXR1cm4gYHVybCgjJHtzaGFkaW5nSWR9KWA7XG4gICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIHBhdHRlcm4gTWVzaFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7YXJnc1swXX1gKTtcbiAgICB9XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIHRoaXMuY3VycmVudC5kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gICAgdGhpcy5jdXJyZW50LmRhc2hQaGFzZSA9IGRhc2hQaGFzZTtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBkID0gW107XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBzd2l0Y2ggKG9wIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5aCksIFwiTFwiLCBwZih4KSwgcGYoeWgpLCBcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGQucHVzaChcIkxcIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMjpcbiAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKHgpLCBwZih5KSwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSkpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoeCksIHBmKHkpLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGQucHVzaChcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGQgPSBkLmpvaW4oXCIgXCIpO1xuICAgIGlmIChjdXJyZW50LnBhdGggJiYgb3BzLmxlbmd0aCA+IDAgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMucmVjdGFuZ2xlICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLm1vdmVUbykge1xuICAgICAgZCA9IGN1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIikgKyBkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXRoXCIpO1xuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoY3VycmVudC5wYXRoKTtcbiAgICB9XG4gICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnBhdGg7XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgZW5kUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQucGF0aCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xpcElkID0gYGNsaXBwYXRoJHtjbGlwQ291bnQrK31gO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Y2xpcFBhdGhcIik7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjbGlwSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG4gICAgY29uc3QgY2xpcEVsZW1lbnQgPSBjdXJyZW50LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwRWxlbWVudCk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgaWYgKGN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgY3VycmVudC5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgZm9yIChjb25zdCBwcmV2IG9mIHRoaXMuZXh0cmFTdGFjaykge1xuICAgICAgICBwcmV2LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCBjdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgIH1cbiAgICBjdXJyZW50LmFjdGl2ZUNsaXBVcmwgPSBgdXJsKCMke2NsaXBJZH0pYDtcbiAgICB0aGlzLnRncnAgPSBudWxsO1xuICB9XG4gIGNsaXAodHlwZSkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSB0eXBlO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnBhdGgpIHtcbiAgICAgIGNvbnN0IGQgPSBgJHtjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpfVpgO1xuICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICB9XG4gIH1cbiAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRUZXh0UmlzZSh0ZXh0UmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHRleHRSaXNlO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKHRleHRSZW5kZXJpbmdNb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gdGV4dFJlbmRlcmluZ01vZGU7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcIkxXXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1MXCI6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRkxcIjpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZUFscGhhKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5zZXRGaWxsQWxwaGEodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBncmFwaGljIHN0YXRlIG9wZXJhdG9yICR7a2V5fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWxsKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHN0cm9rZSgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC5lbGVtZW50KTtcbiAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHJva2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGxpbmVXaWR0aFNjYWxlID0gMSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IGRhc2hBcnJheSA9IGN1cnJlbnQuZGFzaEFycmF5O1xuICAgIGlmIChsaW5lV2lkdGhTY2FsZSAhPT0gMSAmJiBkYXNoQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVXaWR0aFNjYWxlICogdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZVwiLCBjdXJyZW50LnN0cm9rZUNvbG9yKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW9wYWNpdHlcIiwgY3VycmVudC5zdHJva2VBbHBoYSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1taXRlcmxpbWl0XCIsIHBmKGN1cnJlbnQubWl0ZXJMaW1pdCkpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWNhcFwiLCBjdXJyZW50LmxpbmVDYXApO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWpvaW5cIiwgY3VycmVudC5saW5lSm9pbik7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS13aWR0aFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQubGluZVdpZHRoKSArIFwicHhcIik7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgZGFzaEFycmF5Lm1hcChwZikuam9pbihcIiBcIikpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQuZGFzaFBoYXNlKSArIFwicHhcIik7XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50Py5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICAgIHRoaXMuZmlsbCgpO1xuICB9XG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmN1cnJlbnQuZWxlbWVudD8uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfVxuICBjbG9zZUZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMXB4XCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCIxcHhcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgdGhpcy5jdXJyZW50LmZpbGxDb2xvcik7XG4gICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQocmVjdCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBEZXBlbmRlbnQgaW1hZ2Ugd2l0aCBvYmplY3QgSUQgJHtvYmpJZH0gaXMgbm90IHJlYWR5IHlldGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgaW1nU3JjID0gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSwgISFtYXNrKTtcbiAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgY29uc3QgaW1nRWwgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzppbWFnZVwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgXCJ4bGluazpocmVmXCIsIGltZ1NyYyk7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWhlaWdodCkpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpICsgXCJweFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpICsgXCJweFwiKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBgc2NhbGUoJHtwZigxIC8gd2lkdGgpfSAke3BmKC0xIC8gaGVpZ2h0KX0pYCk7XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIG1hc2suYXBwZW5kKGltZ0VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoaW1nRWwpO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgY29uc3QgaW1nRGF0YSA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwicGFpbnRJbWFnZU1hc2tYT2JqZWN0OiBJbWFnZUJpdG1hcCBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCwgXCIgKyBcImVuc3VyZSB0aGF0IHRoZSBgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRgIEFQSSBwYXJhbWV0ZXIgaXMgZGlzYWJsZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSBjdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjdXJyZW50Lm1hc2tJZCA9IGBtYXNrJHttYXNrQ291bnQrK31gO1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzptYXNrXCIpO1xuICAgIG1hc2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjdXJyZW50Lm1hc2tJZCk7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGZpbGxDb2xvcik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm1hc2tcIiwgYHVybCgjJHtjdXJyZW50Lm1hc2tJZH0pYCk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZChtYXNrKTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRyaXgpICYmIG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgIH1cbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgY29uc3QgY2xpcHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGJib3hbMF0pO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGJib3hbMV0pO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgICB0aGlzLmN1cnJlbnQuZWxlbWVudCA9IGNsaXByZWN0O1xuICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge31cbiAgX2luaXRpYWxpemUodmlld3BvcnQpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHQpO1xuICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZmluaXRpb25zKTtcbiAgICB0aGlzLmRlZnMgPSBkZWZpbml0aW9ucztcbiAgICBjb25zdCByb290R3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgIHJvb3RHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh2aWV3cG9ydC50cmFuc2Zvcm0pKTtcbiAgICBzdmcuYXBwZW5kKHJvb3RHcm91cCk7XG4gICAgdGhpcy5zdmcgPSByb290R3JvdXA7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBfZW5zdXJlQ2xpcEdyb3VwKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmNsaXBHcm91cCkge1xuICAgICAgY29uc3QgY2xpcEdyb3VwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIGNsaXBHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCB0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICB0aGlzLnN2Zy5hcHBlbmQoY2xpcEdyb3VwKTtcbiAgICAgIHRoaXMuY3VycmVudC5jbGlwR3JvdXAgPSBjbGlwR3JvdXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwO1xuICB9XG4gIF9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpIHtcbiAgICBpZiAoIXRoaXMudGdycCkge1xuICAgICAgdGhpcy50Z3JwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIHRoaXMudGdycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUNsaXBHcm91cCgpLmFwcGVuZCh0aGlzLnRncnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdmcuYXBwZW5kKHRoaXMudGdycCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRncnA7XG4gIH1cbn1cbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcztcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YZmFUZXh0ID0gdm9pZCAwO1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cbmV4cG9ydHMuWGZhVGV4dCA9IFhmYVRleHQ7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IHZvaWQgMDtcbmV4cG9ydHMucmVuZGVyVGV4dExheWVyID0gcmVuZGVyVGV4dExheWVyO1xuZXhwb3J0cy51cGRhdGVUZXh0TGF5ZXIgPSB1cGRhdGVUZXh0TGF5ZXI7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9BU0NFTlQgPSAwLjg7XG5jb25zdCBhc2NlbnRDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEN0eChzaXplLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICBsZXQgY3R4O1xuICBpZiAoaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgJiYgX3V0aWwuRmVhdHVyZVRlc3QuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpIHtcbiAgICBjdHggPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHNpemUsIHNpemUpLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSBzaXplO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGN0eDtcbn1cbmZ1bmN0aW9uIGdldEFzY2VudChmb250RmFtaWx5LCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICBjb25zdCBjYWNoZWRBc2NlbnQgPSBhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gIGlmIChjYWNoZWRBc2NlbnQpIHtcbiAgICByZXR1cm4gY2FjaGVkQXNjZW50O1xuICB9XG4gIGNvbnN0IGN0eCA9IGdldEN0eChERUZBVUxUX0ZPTlRfU0laRSwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICBjdHguZm9udCA9IGAke0RFRkFVTFRfRk9OVF9TSVpFfXB4ICR7Zm9udEZhbWlseX1gO1xuICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIpO1xuICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gIGxldCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICByZXR1cm4gcmF0aW87XG4gIH1cbiAgY3R4LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBjdHguc3Ryb2tlVGV4dChcImdcIiwgMCwgMCk7XG4gIGxldCBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgZGVzY2VudCA9IDA7XG4gIGZvciAobGV0IGkgPSBwaXhlbHMubGVuZ3RoIC0gMSAtIDM7IGkgPj0gMDsgaSAtPSA0KSB7XG4gICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBjdHguc3Ryb2tlVGV4dChcIkFcIiwgMCwgREVGQVVMVF9GT05UX1NJWkUpO1xuICBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgYXNjZW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgYXNjZW50ID0gREVGQVVMVF9GT05UX1NJWkUgLSBNYXRoLmZsb29yKGkgLyA0IC8gREVGQVVMVF9GT05UX1NJWkUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gIGlmIChhc2NlbnQpIHtcbiAgICBjb25zdCByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgREVGQVVMVF9GT05UX0FTQ0VOVCk7XG4gIHJldHVybiBERUZBVUxUX0ZPTlRfQVNDRU5UO1xufVxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0YXNrLCBnZW9tLCBzdHlsZXMpIHtcbiAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICBhbmdsZTogMCxcbiAgICBjYW52YXNXaWR0aDogMCxcbiAgICBoYXNUZXh0OiBnZW9tLnN0ciAhPT0gXCJcIixcbiAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgIGZvbnRTaXplOiAwXG4gIH07XG4gIHRhc2suX3RleHREaXZzLnB1c2godGV4dERpdik7XG4gIGNvbnN0IHR4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGFzay5fdHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodHhbMV0sIHR4WzBdKTtcbiAgY29uc3Qgc3R5bGUgPSBzdHlsZXNbZ2VvbS5mb250TmFtZV07XG4gIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICB9XG4gIGNvbnN0IGZvbnRIZWlnaHQgPSBNYXRoLmh5cG90KHR4WzJdLCB0eFszXSk7XG4gIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogZ2V0QXNjZW50KHN0eWxlLmZvbnRGYW1pbHksIHRhc2suX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKTtcbiAgbGV0IGxlZnQsIHRvcDtcbiAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgbGVmdCA9IHR4WzRdO1xuICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gdHhbNF0gKyBmb250QXNjZW50ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgfVxuICBjb25zdCBzY2FsZUZhY3RvclN0ciA9IFwiY2FsYyh2YXIoLS1zY2FsZS1mYWN0b3IpKlwiO1xuICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gIGlmICh0YXNrLl9jb250YWluZXIgPT09IHRhc2suX3Jvb3RDb250YWluZXIpIHtcbiAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIGxlZnQgLyB0YXNrLl9wYWdlV2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRhc2suX3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gIH0gZWxzZSB7XG4gICAgZGl2U3R5bGUubGVmdCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7bGVmdC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICB9XG4gIGRpdlN0eWxlLmZvbnRTaXplID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtmb250SGVpZ2h0LnRvRml4ZWQoMil9cHgpYDtcbiAgZGl2U3R5bGUuZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHk7XG4gIHRleHREaXZQcm9wZXJ0aWVzLmZvbnRTaXplID0gZm9udEhlaWdodDtcbiAgdGV4dERpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gIHRleHREaXYuZGlyID0gZ2VvbS5kaXI7XG4gIGlmICh0YXNrLl9mb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IGdlb20uZm9udE5hbWU7XG4gIH1cbiAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgfVxuICBsZXQgc2hvdWxkU2NhbGVUZXh0ID0gZmFsc2U7XG4gIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChnZW9tLnN0ciAhPT0gXCIgXCIgJiYgZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuICAgIGlmIChhYnNTY2FsZVggIT09IGFic1NjYWxlWSAmJiBNYXRoLm1heChhYnNTY2FsZVgsIGFic1NjYWxlWSkgLyBNYXRoLm1pbihhYnNTY2FsZVgsIGFic1NjYWxlWSkgPiAxLjUpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoO1xuICB9XG4gIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gIGlmICh0YXNrLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2KTtcbiAgfVxufVxuZnVuY3Rpb24gbGF5b3V0KHBhcmFtcykge1xuICBjb25zdCB7XG4gICAgZGl2LFxuICAgIHNjYWxlLFxuICAgIHByb3BlcnRpZXMsXG4gICAgY3R4LFxuICAgIHByZXZGb250U2l6ZSxcbiAgICBwcmV2Rm9udEZhbWlseVxuICB9ID0gcGFyYW1zO1xuICBjb25zdCB7XG4gICAgc3R5bGVcbiAgfSA9IGRpdjtcbiAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG4gIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRGYW1pbHlcbiAgICB9ID0gc3R5bGU7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzV2lkdGgsXG4gICAgICBmb250U2l6ZVxuICAgIH0gPSBwcm9wZXJ0aWVzO1xuICAgIGlmIChwcmV2Rm9udFNpemUgIT09IGZvbnRTaXplIHx8IHByZXZGb250RmFtaWx5ICE9PSBmb250RmFtaWx5KSB7XG4gICAgICBjdHguZm9udCA9IGAke2ZvbnRTaXplICogc2NhbGV9cHggJHtmb250RmFtaWx5fWA7XG4gICAgICBwYXJhbXMucHJldkZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICBwYXJhbXMucHJldkZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aFxuICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y2FudmFzV2lkdGggKiBzY2FsZSAvIHdpZHRofSlgO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcGVydGllcy5hbmdsZSAhPT0gMCkge1xuICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHtwcm9wZXJ0aWVzLmFuZ2xlfWRlZykgJHt0cmFuc2Zvcm19YDtcbiAgfVxuICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcih0YXNrKSB7XG4gIGlmICh0YXNrLl9jYW5jZWxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0ZXh0RGl2cyA9IHRhc2suX3RleHREaXZzO1xuICBjb25zdCBjYXBhYmlsaXR5ID0gdGFzay5fY2FwYWJpbGl0eTtcbiAgY29uc3QgdGV4dERpdnNMZW5ndGggPSB0ZXh0RGl2cy5sZW5ndGg7XG4gIGlmICh0ZXh0RGl2c0xlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdGFzay5faXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIGZvciAoY29uc3QgdGV4dERpdiBvZiB0ZXh0RGl2cykge1xuICAgICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2KTtcbiAgICB9XG4gIH1cbiAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG59XG5jbGFzcyBUZXh0TGF5ZXJSZW5kZXJUYXNrIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRleHRDb250ZW50U291cmNlLFxuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydCxcbiAgICB0ZXh0RGl2cyxcbiAgICB0ZXh0RGl2UHJvcGVydGllcyxcbiAgICB0ZXh0Q29udGVudEl0ZW1zU3RyLFxuICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXG4gIH0pIHtcbiAgICB0aGlzLl90ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIHRoaXMuX2lzUmVhZGFibGVTdHJlYW0gPSB0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fdGV4dERpdnMgPSB0ZXh0RGl2cyB8fCBbXTtcbiAgICB0aGlzLl90ZXh0Q29udGVudEl0ZW1zU3RyID0gdGV4dENvbnRlbnRJdGVtc1N0ciB8fCBbXTtcbiAgICB0aGlzLl9pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA9IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkO1xuICAgIHRoaXMuX2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISFnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQ7XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0RGl2UHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzIHx8IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fbGF5b3V0VGV4dFBhcmFtcyA9IHtcbiAgICAgIHByZXZGb250U2l6ZTogbnVsbCxcbiAgICAgIHByZXZGb250RmFtaWx5OiBudWxsLFxuICAgICAgZGl2OiBudWxsLFxuICAgICAgc2NhbGU6IHZpZXdwb3J0LnNjYWxlICogKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHg6IGdldEN0eCgwLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZClcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgdGhpcy5fdHJhbnNmb3JtID0gWzEsIDAsIDAsIC0xLCAtcGFnZVgsIHBhZ2VZICsgcGFnZUhlaWdodF07XG4gICAgdGhpcy5fcGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuICAgIHRoaXMuX3BhZ2VIZWlnaHQgPSBwYWdlSGVpZ2h0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMgPSBudWxsO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpKTtcbiAgfVxuICBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS5zdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFByb3BzXCIgfHwgaXRlbS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFya2VkQ29udGVudFwiKTtcbiAgICAgICAgICBpZiAoaXRlbS5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2l0ZW0uaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5hcHBlbmQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLl90ZXh0Q29udGVudEl0ZW1zU3RyLnB1c2goaXRlbS5zdHIpO1xuICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtLCBzdHlsZUNhY2hlKTtcbiAgICB9XG4gIH1cbiAgX2xheW91dFRleHQodGV4dERpdikge1xuICAgIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMuZGl2ID0gdGV4dERpdjtcbiAgICBsYXlvdXQodGhpcy5fbGF5b3V0VGV4dFBhcmFtcyk7XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQodGV4dERpdik7XG4gICAgfVxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQoYnIpO1xuICAgIH1cbiAgfVxuICBfcmVuZGVyKCkge1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICBsZXQgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKHRoaXMuX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcywgc3R5bGVDYWNoZSk7XG4gICAgICAgICAgcHVtcCgpO1xuICAgICAgICB9LCBjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcmVhZGVyID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2UuZ2V0UmVhZGVyKCk7XG4gICAgICBwdW1wKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90ZXh0Q29udGVudFNvdXJjZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpdGVtcyxcbiAgICAgICAgc3R5bGVzXG4gICAgICB9ID0gdGhpcy5fdGV4dENvbnRlbnRTb3VyY2U7XG4gICAgICB0aGlzLl9wcm9jZXNzSXRlbXMoaXRlbXMsIHN0eWxlcyk7XG4gICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInRleHRDb250ZW50U291cmNlXCIgcGFyYW1ldGVyIHNwZWNpZmllZC4nKTtcbiAgICB9XG4gICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgc3R5bGVDYWNoZSA9IG51bGw7XG4gICAgICByZW5kZXIodGhpcyk7XG4gICAgfSwgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICB9XG59XG5leHBvcnRzLlRleHRMYXllclJlbmRlclRhc2sgPSBUZXh0TGF5ZXJSZW5kZXJUYXNrO1xuZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyKHBhcmFtcykge1xuICBpZiAoIXBhcmFtcy50ZXh0Q29udGVudFNvdXJjZSAmJiAocGFyYW1zLnRleHRDb250ZW50IHx8IHBhcmFtcy50ZXh0Q29udGVudFN0cmVhbSkpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgVGV4dExheWVyUmVuZGVyIGB0ZXh0Q29udGVudGAvYHRleHRDb250ZW50U3RyZWFtYCBwYXJhbWV0ZXJzIFwiICsgXCJ3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIHVzZSBgdGV4dENvbnRlbnRTb3VyY2VgIGluc3RlYWQuXCIpO1xuICAgIHBhcmFtcy50ZXh0Q29udGVudFNvdXJjZSA9IHBhcmFtcy50ZXh0Q29udGVudCB8fCBwYXJhbXMudGV4dENvbnRlbnRTdHJlYW07XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbnRhaW5lcixcbiAgICB2aWV3cG9ydFxuICB9ID0gcGFyYW1zO1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgY29uc3QgdmlzaWJpbGl0eSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpO1xuICBjb25zdCBzY2FsZUZhY3RvciA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tc2NhbGUtZmFjdG9yXCIpKTtcbiAgaWYgKHZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiICYmICghc2NhbGVGYWN0b3IgfHwgTWF0aC5hYnMoc2NhbGVGYWN0b3IgLSB2aWV3cG9ydC5zY2FsZSkgPiAxZS01KSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgYC0tc2NhbGUtZmFjdG9yYCBDU1MtdmFyaWFibGUgbXVzdCBiZSBzZXQsIFwiICsgXCJ0byB0aGUgc2FtZSB2YWx1ZSBhcyBgdmlld3BvcnQuc2NhbGVgLCBcIiArIFwiZWl0aGVyIG9uIHRoZSBgY29udGFpbmVyYC1lbGVtZW50IGl0c2VsZiBvciBoaWdoZXIgdXAgaW4gdGhlIERPTS5cIik7XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBUZXh0TGF5ZXJSZW5kZXJUYXNrKHBhcmFtcyk7XG4gIHRhc2suX3JlbmRlcigpO1xuICByZXR1cm4gdGFzaztcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih7XG4gIGNvbnRhaW5lcixcbiAgdmlld3BvcnQsXG4gIHRleHREaXZzLFxuICB0ZXh0RGl2UHJvcGVydGllcyxcbiAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gIG11c3RSb3RhdGUgPSB0cnVlLFxuICBtdXN0UmVzY2FsZSA9IHRydWVcbn0pIHtcbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShjb250YWluZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICB9XG4gIGlmIChtdXN0UmVzY2FsZSkge1xuICAgIGNvbnN0IGN0eCA9IGdldEN0eCgwLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgcHJldkZvbnRTaXplOiBudWxsLFxuICAgICAgcHJldkZvbnRGYW1pbHk6IG51bGwsXG4gICAgICBkaXY6IG51bGwsXG4gICAgICBzY2FsZSxcbiAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICBjdHhcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGl2IG9mIHRleHREaXZzKSB7XG4gICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgcGFyYW1zLmRpdiA9IGRpdjtcbiAgICAgIGxheW91dChwYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JMYXllciA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgX2ZyZWV0ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgX2luayA9IF9fd19wZGZqc19yZXF1aXJlX18oMzMpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfc3RhbXAgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNib3VuZFBvaW50ZXJ1cCA9IHRoaXMucG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICNib3VuZFBvaW50ZXJkb3duID0gdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICN1aU1hbmFnZXI7XG4gIHN0YXRpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVpTWFuYWdlcixcbiAgICBwYWdlSW5kZXgsXG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25MYXllcixcbiAgICB2aWV3cG9ydCxcbiAgICBsMTBuXG4gIH0pIHtcbiAgICBjb25zdCBlZGl0b3JUeXBlcyA9IFtfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IsIF9pbmsuSW5rRWRpdG9yLCBfc3RhbXAuU3RhbXBFZGl0b3JdO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgZWRpdG9yVHlwZS5pbml0aWFsaXplKGwxMG4pO1xuICAgICAgfVxuICAgIH1cbiAgICB1aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhlZGl0b3JUeXBlcyk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkxheWVyID0gYW5ub3RhdGlvbkxheWVyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkTGF5ZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnMuc2l6ZSA9PT0gMDtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmIChtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICBpZiAobW9kZSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWVUZXh0RWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaW5rRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcInN0YW1wRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCk7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYWRkSW5rRWRpdG9ySWZOZWVkZWQoaXNDb21taXR0aW5nKSB7XG4gICAgaWYgKCFpc0NvbW1pdHRpbmcgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNDb21taXR0aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDBcbiAgICB9LCBmYWxzZSk7XG4gICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZHMuaGFzKGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5kZXNlcmlhbGl6ZShlZGl0YWJsZSk7XG4gICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgY29uc3QgaGlkZGVuQW5ub3RhdGlvbklkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGhpZGRlbkFubm90YXRpb25JZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKGhpZGRlbkFubm90YXRpb25JZHMuaGFzKGlkKSB8fCB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRQb2ludGVydXApO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRQb2ludGVyZG93bik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZFBvaW50ZXJ1cCk7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNpc0NsZWFuaW5nVXApIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yKHBhcmFtcyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBfaW5rLklua0VkaXRvcihwYXJhbXMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBfc3RhbXAuU3RhbXBFZGl0b3IocGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFzdGVFZGl0b3IobW9kZSwgcGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gX2luay5JbmtFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBfc3RhbXAuU3RhbXBFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZFxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKCkge1xuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuaXNTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICgwLCBfZGlzcGxheV91dGlscy5zZXRMYXllckRpbWVuc2lvbnMpKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykodGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvckxheWVyID0gQW5ub3RhdGlvbkVkaXRvckxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZyZWVUZXh0RWRpdG9yID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG5jbGFzcyBGcmVlVGV4dEVkaXRvciBleHRlbmRzIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNib3VuZEVkaXRvckRpdkJsdXIgPSB0aGlzLmVkaXRvckRpdkJsdXIuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2Rm9jdXMgPSB0aGlzLmVkaXRvckRpdkZvY3VzLmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdklucHV0ID0gdGhpcy5lZGl0b3JEaXZJbnB1dC5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZLZXlkb3duID0gdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyk7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjZWRpdG9yRGl2SWQgPSBgJHt0aGlzLmlkfS1lZGl0b3JgO1xuICAjZm9udFNpemU7XG4gICNpbml0aWFsRGF0YSA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZVRleHREZWZhdWx0Q29udGVudCA9IFwiXCI7XG4gIHN0YXRpYyBfaW50ZXJuYWxQYWRkaW5nID0gMDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRGb250U2l6ZSA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBGcmVlVGV4dEVkaXRvci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLmlzRW1wdHkoKTtcbiAgICBjb25zdCBzbWFsbCA9IF90b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfQklHO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IF90b29scy5LZXlib2FyZE1hbmFnZXIoW1tbXCJjdHJsK3NcIiwgXCJtYWMrbWV0YStzXCIsIFwiY3RybCtwXCIsIFwibWFjK21ldGErcFwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9XSwgW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlXSwgW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV1dKSk7XG4gIH1cbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNjb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICB0aGlzLiNmb250U2l6ZSA9IHBhcmFtcy5mb250U2l6ZSB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB7XG4gICAgICBzdHJpbmdzOiBbXCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudFwiLCBcImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWxcIl1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIHRoaXMuI2NvbG9yXV07XG4gIH1cbiAgI3VwZGF0ZUZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgY29uc3Qgc2V0Rm9udHNpemUgPSBzaXplID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgICB0aGlzLiNmb250U2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0Rm9udHNpemUoZm9udFNpemUpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0Rm9udHNpemUoc2F2ZWRGb250c2l6ZSk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2NvbG9yID0gdGhpcy5lZGl0b3JEaXYuc3R5bGUuY29sb3IgPSBzYXZlZENvbG9yO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcihfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEVkaXRvckRpdktleWRvd24pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLiNib3VuZEVkaXRvckRpdkZvY3VzKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEVkaXRvckRpdkJsdXIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLiNib3VuZEVkaXRvckRpdklucHV0KTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZLZXlkb3duKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZGb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZCbHVyKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZJbnB1dCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEVkaXRpbmdcIik7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHRoaXMuI2NoZWF0SW5pdGlhbFJlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWRpdG9yRGl2IHx8IHRoaXMuZWRpdG9yRGl2LmlubmVyVGV4dC50cmltKCkgPT09IFwiXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgICB0aGlzLnBhcmVudC5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0RWRpdGluZ1wiKTtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgI2V4dHJhY3RUZXh0KCkge1xuICAgIGNvbnN0IGRpdnMgPSB0aGlzLmVkaXRvckRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKTtcbiAgICBpZiAoZGl2cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGZvciAoY29uc3QgZGl2IG9mIGRpdnMpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGRpdi5pbm5lclRleHQucmVwbGFjZSgvXFxyXFxuP3xcXG4vLCBcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlxcblwiKTtcbiAgfVxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZWN0ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExheWVyLFxuICAgICAgICBkaXZcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F2ZWREaXNwbGF5ID0gZGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG4gICAgICBjdXJyZW50TGF5ZXIuZGl2LmFwcGVuZCh0aGlzLmRpdik7XG4gICAgICByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzYXZlZERpc3BsYXk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRpdiAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVkaXRvckRpdktleWRvd24oZXZlbnQpIHtcbiAgICBGcmVlVGV4dEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIGVkaXRvckRpdkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICB9XG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG4gIGVkaXRvckRpdklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVlVGV4dEVkaXRpbmdcIiwgdGhpcy5pc0VtcHR5KCkpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIiwgdHJ1ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5lZGl0b3JEaXY/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudFwiKS50aGVuKG1zZyA9PiB0aGlzLmVkaXRvckRpdj8uc2V0QXR0cmlidXRlKFwiZGVmYXVsdC1jb250ZW50XCIsIG1zZykpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy5lZGl0b3JEaXY7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy4jY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgKDAsIF90b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLmRpdiwgW1wiZGJsY2xpY2tcIiwgXCJrZXlkb3duXCJdKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSA9IHRoaXMuI2luaXRpYWxEYXRhO1xuICAgICAgICBsZXQgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgICAgICBbdHgsIHR5XSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uVG9TY3JlZW4odHgsIHR5KTtcbiAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgICAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYICsgKHBvc2l0aW9uWzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRoO1xuICAgICAgICAgICAgcG9zWSA9IGJhc2VZICsgdGhpcy5oZWlnaHQgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFt0eSwgLXR4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgcG9zWCA9IGJhc2VYIC0gdGhpcy53aWR0aCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSAtIChwb3NpdGlvblsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgICBbdHgsIHR5XSA9IFstdHgsIC10eV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYIC0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0KSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIChwb3NpdGlvblsxXSAtIHBhZ2VZIC0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR5LCB0eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KHBvc1ggKiBwYXJlbnRXaWR0aCwgcG9zWSAqIHBhcmVudEhlaWdodCwgdHgsIHR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI3NldENvbnRlbnQoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgaWYgKCF0aGlzLiNjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuYXBwZW5kKGRpdik7XG4gICAgfVxuICB9XG4gIGdldCBjb250ZW50RGl2KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvckRpdjtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX2Fubm90YXRpb25fbGF5ZXIuRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZFxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdCxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci4jZm9udFNpemUgPSBkYXRhLmZvbnRTaXplO1xuICAgIGVkaXRvci4jY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3IuI2NvbnRlbnQgPSBkYXRhLnZhbHVlO1xuICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZGF0YS5pZCB8fCBudWxsO1xuICAgIGVkaXRvci4jaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICAgIGlkOiB0aGlzLmFubm90YXRpb25FbGVtZW50SWQsXG4gICAgICAgIGRlbGV0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSBGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogdGhpcy5wYXJlbnRTY2FsZTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvbG9yID0gX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmlzQXR0YWNoZWRUb0RPTSA/IGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yIDogdGhpcy4jY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNjb250ZW50LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGNvbG9yLFxuICAgICAgcmVjdCxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLiNpbml0aWFsRGF0YTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5yZWN0LnNvbWUoKHgsIGkpID0+IE1hdGguYWJzKHggLSByZWN0W2ldKSA+PSAxKSB8fCBzZXJpYWxpemVkLmNvbG9yLnNvbWUoKGMsIGkpID0+IGMgIT09IGNvbG9yW2ldKSB8fCBzZXJpYWxpemVkLnBhZ2VJbmRleCAhPT0gcGFnZUluZGV4O1xuICB9XG4gICNjaGVhdEluaXRpYWxSZWN0KGRlbGF5ZWQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICBpZiAoIWRlbGF5ZWQgJiYgKHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDApKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuI2NoZWF0SW5pdGlhbFJlY3QodHJ1ZSksIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgdGhpcy4jaW5pdGlhbERhdGEucmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgfVxufVxuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IEZyZWVUZXh0RWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgPSBleHBvcnRzLklua0Fubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5GcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5Bbm5vdGF0aW9uTGF5ZXIgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBfc2NyaXB0aW5nX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzMCk7XG52YXIgX2Rpc3BsYXlMMTBuX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzMSk7XG52YXIgX3hmYV9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xuY29uc3QgREVGQVVMVF9UQUJfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gZ2V0UmVjdERpbXMocmVjdCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gIH07XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICB0aXRsZU9iaixcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKHRpdGxlT2JqPy5zdHIgfHwgY29udGVudHNPYmo/LnN0ciB8fCByaWNoVGV4dD8uc3RyKTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSk7XG4gIH1cbiAgX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHBhZ2UsXG4gICAgICAgIHZpZXdwb3J0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtYW5ub3RhdGlvbi1pZFwiLCBkYXRhLmlkKTtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpKSB7XG4gICAgICBjb250YWluZXIudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleCsrO1xuICAgIGlmICh0aGlzLmRhdGEucG9wdXBSZWYpIHtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwiZGlhbG9nXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBpZiAoIWRhdGEucmVjdCB8fCB0aGlzIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3RhdGlvblxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIWRhdGEuaGFzT3duQ2FudmFzICYmIHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHJlY3QgPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChkYXRhLmJvcmRlclN0eWxlLnN0eWxlKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5TT0xJRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHsxMDAgKiAocmVjdFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGF0YS5oYXNPd25DYW52YXMgfHwgcm90YXRpb24gPT09IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXModGhpcy5kYXRhLnJlY3QpO1xuICAgIGxldCBlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKGFuZ2xlICUgMTgwID09PSAwKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiBoZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogd2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IF9zY3JpcHRpbmdfdXRpbHMuQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fSFRNTGBdKGNvbG9yQXJyYXkpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgW3N0eWxlTmFtZV06IF9zY3JpcHRpbmdfdXRpbHMuQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yVHlwZX1fcmdiYF0oY29sb3JBcnJheSlcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0O1xuICAgIGlmIChxdWFkUG9pbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgWywge1xuICAgICAgICB4OiB0clgsXG4gICAgICAgIHk6IHRyWVxuICAgICAgfSwge1xuICAgICAgICB4OiBibFgsXG4gICAgICAgIHk6IGJsWVxuICAgICAgfV0gPSBxdWFkUG9pbnRzWzBdO1xuICAgICAgaWYgKHJlY3RUclggPT09IHRyWCAmJiByZWN0VHJZID09PSB0clkgJiYgcmVjdEJsWCA9PT0gYmxYICYmIHJlY3RCbFkgPT09IGJsWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuY29udGFpbmVyO1xuICAgIGxldCBzdmdCdWZmZXI7XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBib3JkZXJDb2xvcixcbiAgICAgICAgYm9yZGVyV2lkdGhcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIHN2Z0J1ZmZlciA9IFtcInVybCgnZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsXCIsIGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcImAsIGAgcHJlc2VydmVBc3BlY3RSYXRpbz1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDEgMVwiPmAsIGA8ZyBmaWxsPVwidHJhbnNwYXJlbnRcIiBzdHJva2U9XCIke2JvcmRlckNvbG9yfVwiIHN0cm9rZS13aWR0aD1cIiR7Ym9yZGVyV2lkdGh9XCI+YF07XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzQm9yZGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IHJlY3RUclggLSByZWN0QmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHJlY3RUclkgLSByZWN0QmxZO1xuICAgIGNvbnN0IHtcbiAgICAgIHN2Z0ZhY3RvcnlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIik7XG4gICAgc3ZnLmNsYXNzTGlzdC5hZGQoXCJxdWFkcmlsYXRlcmFsc0NvbnRhaW5lclwiKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwKTtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGNvbnN0IFssIHtcbiAgICAgIHg6IHRyWCxcbiAgICAgIHk6IHRyWVxuICAgIH0sIHtcbiAgICAgIHg6IGJsWCxcbiAgICAgIHk6IGJsWVxuICAgIH1dIG9mIHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBzdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgY29uc3QgeCA9IChibFggLSByZWN0QmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgeSA9IChyZWN0VHJZIC0gdHJZKSAvIGhlaWdodDtcbiAgICAgIGNvbnN0IHJlY3RXaWR0aCA9ICh0clggLSBibFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCByZWN0SGVpZ2h0ID0gKHRyWSAtIGJsWSkgLyBoZWlnaHQ7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJlY3RXaWR0aCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCByZWN0SGVpZ2h0KTtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChyZWN0KTtcbiAgICAgIHN2Z0J1ZmZlcj8ucHVzaChgPHJlY3QgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiIHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIiR7cmVjdFdpZHRofVwiIGhlaWdodD1cIiR7cmVjdEhlaWdodH1cIi8+YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIHN2Z0J1ZmZlci5wdXNoKGA8L2c+PC9zdmc+JylgKTtcbiAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHN2Z0J1ZmZlci5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5jbGlwUGF0aCA9IGB1cmwoIyR7aWR9KWA7XG4gIH1cbiAgX2NyZWF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcImRpYWxvZ1wiKTtcbiAgICBjb25zdCBwb3B1cCA9IG5ldyBQb3B1cEFubm90YXRpb25FbGVtZW50KHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlT2JqOiBkYXRhLnRpdGxlT2JqLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb25cbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICAgIHRoaXMucGFyZW50LmRpdi5hcHBlbmQocG9wdXAucmVuZGVyKCkpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgX2dldEVsZW1lbnRzQnlOYW1lIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgIH0gPSBkb21FbGVtZW50O1xuICAgICAgY29uc3QgaWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiKTtcbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgZG9tRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5tYXliZVNob3coKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8uZm9yY2VIaWRlKCk7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJzLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgIH1cbiAgfVxuICBfZWRpdE9uRG91YmxlQ2xpY2soKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCBvcHRpb25zID0gbnVsbCkge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogISFvcHRpb25zPy5pZ25vcmVCb3JkZXIsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNUb29sdGlwT25seSA9IHBhcmFtZXRlcnMuZGF0YS5pc1Rvb2x0aXBPbmx5O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgbGlua1NlcnZpY2VcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgZGF0YS5pZCk7XG4gICAgbGV0IGlzQm91bmQgPSBmYWxzZTtcbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuX2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuc2V0T0NHU3RhdGUpIHtcbiAgICAgIHRoaXMuI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBkYXRhLnNldE9DR1N0YXRlKTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5kZXN0KSB7XG4gICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBkYXRhLmRlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgI3NldEludGVybmFsTGluaygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWludGVybmFsLWxpbmtcIiwgXCJcIik7XG4gIH1cbiAgX2JpbmRMaW5rKGxpbmssIGRlc3RpbmF0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXREZXN0aW5hdGlvbkhhc2goZGVzdGluYXRpb24pO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBpZiAoZGVzdGluYXRpb24gfHwgZGVzdGluYXRpb24gPT09IFwiXCIpIHtcbiAgICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIH1cbiAgfVxuICBfYmluZE5hbWVkQWN0aW9uKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZEF0dGFjaG1lbnQobGluaywgYXR0YWNobWVudCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250YWluZXIsIGF0dGFjaG1lbnQuY29udGVudCwgYXR0YWNobWVudC5maWxlbmFtZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICAjYmluZFNldE9DR1N0YXRlKGxpbmssIGFjdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZVNldE9DR1N0YXRlKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKFtbXCJBY3Rpb25cIiwgXCJvbmNsaWNrXCJdLCBbXCJNb3VzZSBVcFwiLCBcIm9ubW91c2V1cFwiXSwgW1wiTW91c2UgRG93blwiLCBcIm9ubW91c2Vkb3duXCJdXSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRhdGEuYWN0aW9ucykpIHtcbiAgICAgIGNvbnN0IGpzTmFtZSA9IG1hcC5nZXQobmFtZSk7XG4gICAgICBpZiAoIWpzTmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxpbmtbanNOYW1lXSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIWxpbmsub25jbGljaykge1xuICAgICAgbGluay5vbmNsaWNrID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIHJlc2V0Rm9ybSkge1xuICAgIGNvbnN0IG90aGVyQ2xpY2tBY3Rpb24gPSBsaW5rLm9uY2xpY2s7XG4gICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgaWYgKCF0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2UuYWx0ID0gXCJbe3t0eXBlfX0gQW5ub3RhdGlvbl1cIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5JZCA9IFwidGV4dF9hbm5vdGF0aW9uX3R5cGVcIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5BcmdzID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZz8ubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c1NpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRLZXlNb2RpZmllcihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luLFxuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgcmV0dXJuIGlzV2luICYmIGV2ZW50LmN0cmxLZXkgfHwgaXNNYWMgJiYgZXZlbnQubWV0YUtleTtcbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgdmFsdWVHZXR0ZXIpIHtcbiAgICBpZiAoYmFzZU5hbWUuaW5jbHVkZXMoXCJtb3VzZVwiKSkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudCksXG4gICAgICAgICAgICBzaGlmdDogZXZlbnQuc2hpZnRLZXksXG4gICAgICAgICAgICBtb2RpZmllcjogdGhpcy5fZ2V0S2V5TW9kaWZpZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGJhc2VOYW1lID09PSBcImJsdXJcIikge1xuICAgICAgICAgIGlmICghZWxlbWVudERhdGEuZm9jdXNlZCB8fCAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVHZXR0ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiB8fCBldmVudE5hbWUgPT09IFwiQmx1clwiKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEgfHw9IHtcbiAgICAgICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCBnZXR0ZXIpO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5CbHVyKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJibHVyXCIsIFwiQmx1clwiLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiQmx1clwiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImZvY3VzXCIsIFwiRm9jdXNcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvciA9PT0gbnVsbCA/IFwidHJhbnNwYXJlbnRcIiA6IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuICB9XG4gIF9zZXRUZXh0U3R5bGUoZWxlbWVudCkge1xuICAgIGNvbnN0IFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZvbnRDb2xvclxuICAgIH0gPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhO1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZSB8fCBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGNvbXB1dGVkRm9udFNpemU7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IHJvdW5kVG9PbmVEZWNpbWFsID0geCA9PiBNYXRoLnJvdW5kKDEwICogeCkgLyAxMDtcbiAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbnN0IG51bWJlck9mTGluZXMgPSBNYXRoLnJvdW5kKGhlaWdodCAvIChfdXRpbC5MSU5FX0ZBQ1RPUiAqIGZvbnRTaXplKSkgfHwgMTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBoZWlnaHQgLyBudW1iZXJPZkxpbmVzO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChsaW5lSGVpZ2h0IC8gX3V0aWwuTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gX3V0aWwuTElORV9GQUNUT1IpKTtcbiAgICB9XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9IFRFWFRfQUxJR05NRU5UW3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50XTtcbiAgICB9XG4gIH1cbiAgX3NldFJlcXVpcmVkKGVsZW1lbnQsIGlzUmVxdWlyZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG59XG5jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgdGhpcy5zaG93RWxlbWVudEFuZEhpZGVDYW52YXMoanNFdmVudC50YXJnZXQpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWUgPz8gXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsUmFuZ2UoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFNlbGVjdGlvblJhbmdlKC4uLmV2ZW50LmRldGFpbC5zZWxSYW5nZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgIGlmIChjaGFyTGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwibWF4TGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwibWF4TGVuZ3RoXCIsIGNoYXJMaW1pdCk7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICAgICAgICBzZWxTdGFydDogdGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgc2VsRW5kOiB0YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgbGV0IGNvbW1pdEtleSA9IC0xO1xuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhdGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJUYWJcIikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBsZXQgYWRkQW5FbXB0eUVudHJ5ID0gdGhpcy5kYXRhLmNvbWJvICYmIHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBvcHRpb24gb2YgdGhpcy5kYXRhLm9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbi5kaXNwbGF5VmFsdWU7XG4gICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUuaW5jbHVkZXMob3B0aW9uLmV4cG9ydFZhbHVlKSkge1xuICAgICAgICBvcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgICBhZGRBbkVtcHR5RW50cnkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgICBsZXQgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgaWYgKGFkZEFuRW1wdHlFbnRyeSkge1xuICAgICAgY29uc3Qgbm9uZU9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQudmFsdWUgPSBcIiBcIjtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCB0cnVlKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIHRydWUpO1xuICAgICAgc2VsZWN0RWxlbWVudC5wcmVwZW5kKG5vbmVPcHRpb25FbGVtZW50KTtcbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgcmVtb3ZlRW1wdHlFbnRyeSk7XG4gICAgfVxuICAgIGNvbnN0IGdldFZhbHVlID0gaXNFeHBvcnQgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGlzRXhwb3J0ID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBtdWx0aXBsZVxuICAgICAgfSA9IHNlbGVjdEVsZW1lbnQ7XG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gbnVsbCA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubWFwKG9wdGlvbiA9PiBvcHRpb25bbmFtZV0pO1xuICAgIH07XG4gICAgbGV0IHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgIGNvbnN0IGdldEl0ZW1zID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChvcHRpb25zLCBvcHRpb24gPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc3BsYXlWYWx1ZTogb3B0aW9uLnRleHRDb250ZW50LFxuICAgICAgICAgIGV4cG9ydFZhbHVlOiBvcHRpb24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV4cG9ydFZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBzZWxlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgY29tbWl0S2V5OiAxLFxuICAgICAgICAgICAga2V5RG93bjogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhzZWxlY3RFbGVtZW50LCBudWxsLCBbW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXSwgW1wiaW5wdXRcIiwgXCJBY3Rpb25cIl0sIFtcImlucHV0XCIsIFwiVmFsaWRhdGVcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKHNlbGVjdEVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgZWxlbWVudHNcbiAgICB9ID0gcGFyYW1ldGVycztcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJwb3B1cEFubm90YXRpb25cIik7XG4gICAgY29uc3QgcG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudElkcy5wdXNoKGVsZW1lbnQuZGF0YS5pZCk7XG4gICAgICBlbGVtZW50LmFkZEhpZ2hsaWdodEFyZWEoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLm1hcChpZCA9PiBgJHtfdXRpbC5Bbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkuam9pbihcIixcIikpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgI2RhdGVUaW1lUHJvbWlzZSA9IG51bGw7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2VsZW1lbnRzID0gbnVsbDtcbiAgI3BhcmVudCA9IG51bGw7XG4gICNwYXJlbnRSZWN0ID0gbnVsbDtcbiAgI3Bpbm5lZCA9IGZhbHNlO1xuICAjcG9wdXAgPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN3YXNWaXNpYmxlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW5cbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN0aXRsZU9iaiA9IHRpdGxlT2JqO1xuICAgIHRoaXMuI2NvbnRlbnRzT2JqID0gY29udGVudHNPYmo7XG4gICAgdGhpcy4jcmljaFRleHQgPSByaWNoVGV4dDtcbiAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy4jY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLiNyZWN0ID0gcmVjdDtcbiAgICB0aGlzLiNwYXJlbnRSZWN0ID0gcGFyZW50UmVjdDtcbiAgICB0aGlzLiNlbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIGNvbnN0IGRhdGVPYmplY3QgPSBfZGlzcGxheV91dGlscy5QREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChtb2RpZmljYXRpb25EYXRlKTtcbiAgICBpZiAoZGF0ZU9iamVjdCkge1xuICAgICAgdGhpcy4jZGF0ZVRpbWVQcm9taXNlID0gcGFyZW50LmwxMG4uZ2V0KFwiYW5ub3RhdGlvbl9kYXRlX3N0cmluZ1wiLCB7XG4gICAgICAgIGRhdGU6IGRhdGVPYmplY3QudG9Mb2NhbGVEYXRlU3RyaW5nKCksXG4gICAgICAgIHRpbWU6IGRhdGVPYmplY3QudG9Mb2NhbGVUaW1lU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIgPSBlbGVtZW50cy5mbGF0TWFwKGUgPT4gZS5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLnRyaWdnZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy4jYm91bmRTaG93KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy4jYm91bmRIaWRlKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgZWxlbWVudC5jb250YWluZXI/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLiNwb3B1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgaWYgKENTUy5zdXBwb3J0cyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJjb2xvci1taXgoaW4gc3JnYiwgcmVkIDMwJSwgd2hpdGUpXCIpKSB7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGBjb2xvci1taXgoaW4gc3JnYiwgJHtiYXNlQ29sb3J9IDMwJSwgd2hpdGUpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IubWFwKGMgPT4gTWF0aC5mbG9vcihCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gYykgKyBjKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZVRpbWVQcm9taXNlKSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTGlzdC5hZGQoXCJwb3B1cERhdGVcIik7XG4gICAgICB0aGlzLiNkYXRlVGltZVByb21pc2UudGhlbihsb2NhbGl6ZWQgPT4ge1xuICAgICAgICBtb2RpZmljYXRpb25EYXRlLnRleHRDb250ZW50ID0gbG9jYWxpemVkO1xuICAgICAgfSk7XG4gICAgICBoZWFkZXIuYXBwZW5kKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50c09iaiA9IHRoaXMuI2NvbnRlbnRzT2JqO1xuICAgIGNvbnN0IHJpY2hUZXh0ID0gdGhpcy4jcmljaFRleHQ7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgX3hmYV9sYXllci5YZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiByaWNoVGV4dC5odG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKGNvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IF91dGlsLlV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBfdXRpbC5VdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocG9wdXBUb3AgLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gICN0b2dnbGUoKSB7XG4gICAgdGhpcy4jcGlubmVkID0gIXRoaXMuI3Bpbm5lZDtcbiAgICBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoaWRlKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuI2JvdW5kVG9nZ2xlKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgfVxuICAjc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZvY3VzZWRcIik7XG4gICAgfVxuICB9XG4gICNoaWRlKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZm9jdXNlZFwiKTtcbiAgICBpZiAodGhpcy4jcGlubmVkIHx8ICF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy4jY29udGFpbmVyLnN0eWxlLnpJbmRleCkgLSAxMDAwO1xuICB9XG4gIGZvcmNlSGlkZSgpIHtcbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgaWYgKCF0aGlzLiN3YXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICB9XG4gIG1heWJlU2hvdygpIHtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jd2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNjb250YWluZXIuaGlkZGVuID09PSBmYWxzZTtcbiAgfVxufVxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBwYXJhbWV0ZXJzLmRhdGEudGV4dENvbnRlbnQ7XG4gICAgdGhpcy50ZXh0UG9zaXRpb24gPSBwYXJhbWV0ZXJzLmRhdGEudGV4dFBvc2l0aW9uO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyZWVUZXh0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAodGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuZXhwb3J0cy5GcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudDtcbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1syXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQobGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvb3JkaW5hdGUgb2YgZGF0YS52ZXJ0aWNlcykge1xuICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICBwb2ludHMucHVzaCh4ICsgXCIsXCIgKyB5KTtcbiAgICB9XG4gICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy4jcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWdvbkFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzKTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWdvbkFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWdvblwiO1xuICB9XG59XG5jbGFzcyBDYXJldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjYXJldEFubm90YXRpb25cIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgSW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGRhdGEuaW5rTGlzdHMpIHtcbiAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBpbmtMaXN0KSB7XG4gICAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICAgIH1cbiAgICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICAgIGNvbnN0IHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICB0aGlzLiNwb2x5bGluZXMucHVzaChwb2x5bGluZSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJwb2ludHNcIiwgcG9pbnRzKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICAgIH1cbiAgICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmV4cG9ydHMuSW5rQW5ub3RhdGlvbkVsZW1lbnQgPSBJbmtBbm5vdGF0aW9uRWxlbWVudDtcbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInN0YW1wQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5leHBvcnRzLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgPSBTdGFtcEFubm90YXRpb25FbGVtZW50O1xuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBjb250ZW50XG4gICAgfSA9IHRoaXMuZGF0YS5maWxlO1xuICAgIHRoaXMuZmlsZW5hbWUgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsKShmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250YWluZXIsIHRoaXMuY29udGVudCwgdGhpcy5maWxlbmFtZSk7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25MYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uQ2FudmFzTWFwID0gbnVsbDtcbiAgI2VkaXRhYmxlQW5ub3RhdGlvbnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBsMTBuLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5sMTBuID0gbDEwbjtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5sMTBuIHx8PSBfZGlzcGxheUwxMG5fdXRpbHMuTnVsbEwxMG47XG4gIH1cbiAgI2FwcGVuZEVsZW1lbnQoZWxlbWVudCwgaWQpIHtcbiAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZCB8fCBlbGVtZW50O1xuICAgIGNvbnRlbnRFbGVtZW50LmlkID0gYCR7X3V0aWwuQW5ub3RhdGlvblByZWZpeH0ke2lkfWA7XG4gICAgdGhpcy5kaXYuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlbGVtZW50LCBjb250ZW50RWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIHJlbmRlcihwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uc1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGFyYW1zLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCksXG4gICAgICBlbmFibGVTY3JpcHRpbmc6IHBhcmFtcy5lbmFibGVTY3JpcHRpbmcgPT09IHRydWUsXG4gICAgICBoYXNKU0FjdGlvbnM6IHBhcmFtcy5oYXNKU0FjdGlvbnMsXG4gICAgICBmaWVsZE9iamVjdHM6IHBhcmFtcy5maWVsZE9iamVjdHMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbGVtZW50czogbnVsbFxuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBpZiAoZGF0YS5ub0hUTUwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1BvcHVwQW5ub3RhdGlvbiA9IGRhdGEuYW5ub3RhdGlvblR5cGUgPT09IF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQO1xuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50UGFyYW1zLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICB9XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1BvcHVwQW5ub3RhdGlvbiAmJiBkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcG9wdXBUb0VsZW1lbnRzLmdldChkYXRhLnBvcHVwUmVmKTtcbiAgICAgICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hbm5vdGF0aW9uRWRpdG9yVHlwZSA+IDApIHtcbiAgICAgICAgdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5zZXQoZWxlbWVudC5kYXRhLmlkLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgYXdhaXQgdGhpcy5sMTBuLnRyYW5zbGF0ZShsYXllcik7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykobGF5ZXIsIHtcbiAgICAgIHJvdGF0aW9uOiB2aWV3cG9ydC5yb3RhdGlvblxuICAgIH0pO1xuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoKTtcbiAgICBsYXllci5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICAjc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpIHtcbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IFtpZCwgY2FudmFzXSBvZiB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gbGF5ZXIucXVlcnlTZWxlY3RvcihgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKCFmaXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlV2l0aChjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RDaGlsZC5iZWZvcmUoY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcC5jbGVhcigpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy52YWx1ZXMoKSk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uTGF5ZXIgPSBBbm5vdGF0aW9uTGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gdm9pZCAwO1xuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDEgLSBNYXRoLm1pbigxLCAwLjMgKiBjICsgMC41OSAqIG0gKyAwLjExICogeSArIGspXTtcbiAgfVxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuICBzdGF0aWMgR19SR0IoW2ddKSB7XG4gICAgcmV0dXJuIFtcIlJHQlwiLCBnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19yZ2IoW2ddKSB7XG4gICAgZyA9IHNjYWxlQW5kQ2xhbXAoZyk7XG4gICAgcmV0dXJuIFtnLCBnLCBnXTtcbiAgfVxuICBzdGF0aWMgR19IVE1MKFtnXSkge1xuICAgIGNvbnN0IEcgPSBtYWtlQ29sb3JDb21wKGcpO1xuICAgIHJldHVybiBgIyR7R30ke0d9JHtHfWA7XG4gIH1cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuICBzdGF0aWMgUkdCX3JnYihjb2xvcikge1xuICAgIHJldHVybiBjb2xvci5tYXAoc2NhbGVBbmRDbGFtcCk7XG4gIH1cbiAgc3RhdGljIFJHQl9IVE1MKGNvbG9yKSB7XG4gICAgcmV0dXJuIGAjJHtjb2xvci5tYXAobWFrZUNvbG9yQ29tcCkuam9pbihcIlwiKX1gO1xuICB9XG4gIHN0YXRpYyBUX0hUTUwoKSB7XG4gICAgcmV0dXJuIFwiIzAwMDAwMDAwXCI7XG4gIH1cbiAgc3RhdGljIFRfcmdiKCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH1cbiAgc3RhdGljIENNWUtfUkdCKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgMSAtIE1hdGgubWluKDEsIGMgKyBrKSwgMSAtIE1hdGgubWluKDEsIG0gKyBrKSwgMSAtIE1hdGgubWluKDEsIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIENNWUtfcmdiKFtjLCB5LCBtLCBrXSkge1xuICAgIHJldHVybiBbc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgYyArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgbSArIGspKSwgc2NhbGVBbmRDbGFtcCgxIC0gTWF0aC5taW4oMSwgeSArIGspKV07XG4gIH1cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG4gIHN0YXRpYyBSR0JfQ01ZSyhbciwgZywgYl0pIHtcbiAgICBjb25zdCBjID0gMSAtIHI7XG4gICAgY29uc3QgbSA9IDEgLSBnO1xuICAgIGNvbnN0IHkgPSAxIC0gYjtcbiAgICBjb25zdCBrID0gTWF0aC5taW4oYywgbSwgeSk7XG4gICAgcmV0dXJuIFtcIkNNWUtcIiwgYywgbSwgeSwga107XG4gIH1cbn1cbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gQ29sb3JDb252ZXJ0ZXJzO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk51bGxMMTBuID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRMMTBuRmFsbGJhY2sgPSBnZXRMMTBuRmFsbGJhY2s7XG5jb25zdCBERUZBVUxUX0wxME5fU1RSSU5HUyA9IHtcbiAgb2ZfcGFnZXM6IFwib2Yge3twYWdlc0NvdW50fX1cIixcbiAgcGFnZV9vZl9wYWdlczogXCIoe3twYWdlTnVtYmVyfX0gb2Yge3twYWdlc0NvdW50fX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfa2I6IFwie3tzaXplX2tifX0gS0IgKHt7c2l6ZV9ifX0gYnl0ZXMpXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbWI6IFwie3tzaXplX21ifX0gTUIgKHt7c2l6ZV9ifX0gYnl0ZXMpXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfZGF0ZV9zdHJpbmc6IFwie3tkYXRlfX0sIHt7dGltZX19XCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfaW5jaGVzOiBcImluXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfbWlsbGltZXRlcnM6IFwibW1cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fcG9ydHJhaXQ6IFwicG9ydHJhaXRcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fbGFuZHNjYXBlOiBcImxhbmRzY2FwZVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2EzOiBcIkEzXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTQ6IFwiQTRcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9sZXR0ZXI6IFwiTGV0dGVyXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfbGVnYWw6IFwiTGVnYWxcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX3N0cmluZzogXCJ7e3dpZHRofX0gw5cge3toZWlnaHR9fSB7e3VuaXR9fSAoe3tvcmllbnRhdGlvbn19KVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fbmFtZV9zdHJpbmc6IFwie3t3aWR0aH19IMOXIHt7aGVpZ2h0fX0ge3t1bml0fX0gKHt7bmFtZX19LCB7e29yaWVudGF0aW9ufX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF95ZXM6IFwiWWVzXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF9ubzogXCJOb1wiLFxuICBhZGRpdGlvbmFsX2xheWVyczogXCJBZGRpdGlvbmFsIExheWVyc1wiLFxuICBwYWdlX2xhbmRtYXJrOiBcIlBhZ2Uge3twYWdlfX1cIixcbiAgdGh1bWJfcGFnZV90aXRsZTogXCJQYWdlIHt7cGFnZX19XCIsXG4gIHRodW1iX3BhZ2VfY2FudmFzOiBcIlRodW1ibmFpbCBvZiBQYWdlIHt7cGFnZX19XCIsXG4gIGZpbmRfcmVhY2hlZF90b3A6IFwiUmVhY2hlZCB0b3Agb2YgZG9jdW1lbnQsIGNvbnRpbnVlZCBmcm9tIGJvdHRvbVwiLFxuICBmaW5kX3JlYWNoZWRfYm90dG9tOiBcIlJlYWNoZWQgZW5kIG9mIGRvY3VtZW50LCBjb250aW51ZWQgZnJvbSB0b3BcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50W29uZV1cIjogXCJ7e2N1cnJlbnR9fSBvZiB7e3RvdGFsfX0gbWF0Y2hcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50W290aGVyXVwiOiBcInt7Y3VycmVudH19IG9mIHt7dG90YWx9fSBtYXRjaGVzXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFtvbmVdXCI6IFwiTW9yZSB0aGFuIHt7bGltaXR9fSBtYXRjaFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRfbGltaXRbb3RoZXJdXCI6IFwiTW9yZSB0aGFuIHt7bGltaXR9fSBtYXRjaGVzXCIsXG4gIGZpbmRfbm90X2ZvdW5kOiBcIlBocmFzZSBub3QgZm91bmRcIixcbiAgcGFnZV9zY2FsZV93aWR0aDogXCJQYWdlIFdpZHRoXCIsXG4gIHBhZ2Vfc2NhbGVfZml0OiBcIlBhZ2UgRml0XCIsXG4gIHBhZ2Vfc2NhbGVfYXV0bzogXCJBdXRvbWF0aWMgWm9vbVwiLFxuICBwYWdlX3NjYWxlX2FjdHVhbDogXCJBY3R1YWwgU2l6ZVwiLFxuICBwYWdlX3NjYWxlX3BlcmNlbnQ6IFwie3tzY2FsZX19JVwiLFxuICBsb2FkaW5nX2Vycm9yOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgdGhlIFBERi5cIixcbiAgaW52YWxpZF9maWxlX2Vycm9yOiBcIkludmFsaWQgb3IgY29ycnVwdGVkIFBERiBmaWxlLlwiLFxuICBtaXNzaW5nX2ZpbGVfZXJyb3I6IFwiTWlzc2luZyBQREYgZmlsZS5cIixcbiAgdW5leHBlY3RlZF9yZXNwb25zZV9lcnJvcjogXCJVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZS5cIixcbiAgcmVuZGVyaW5nX2Vycm9yOiBcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlbmRlcmluZyB0aGUgcGFnZS5cIixcbiAgYW5ub3RhdGlvbl9kYXRlX3N0cmluZzogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgcHJpbnRpbmdfbm90X3N1cHBvcnRlZDogXCJXYXJuaW5nOiBQcmludGluZyBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cIixcbiAgcHJpbnRpbmdfbm90X3JlYWR5OiBcIldhcm5pbmc6IFRoZSBQREYgaXMgbm90IGZ1bGx5IGxvYWRlZCBmb3IgcHJpbnRpbmcuXCIsXG4gIHdlYl9mb250c19kaXNhYmxlZDogXCJXZWIgZm9udHMgYXJlIGRpc2FibGVkOiB1bmFibGUgdG8gdXNlIGVtYmVkZGVkIFBERiBmb250cy5cIixcbiAgZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnQ6IFwiU3RhcnQgdHlwaW5n4oCmXCIsXG4gIGVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWw6IFwiVGV4dCBFZGl0b3JcIixcbiAgZWRpdG9yX2luazJfYXJpYV9sYWJlbDogXCJEcmF3IEVkaXRvclwiLFxuICBlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsOiBcIlVzZXItY3JlYXRlZCBpbWFnZVwiLFxuICBlZGl0b3JfYWx0X3RleHRfYnV0dG9uX2xhYmVsOiBcIkFsdCB0ZXh0XCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9lZGl0X2J1dHRvbl9sYWJlbDogXCJFZGl0IGFsdCB0ZXh0XCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9kZWNvcmF0aXZlX3Rvb2x0aXA6IFwiTWFya2VkIGFzIGRlY29yYXRpdmVcIlxufTtcbntcbiAgREVGQVVMVF9MMTBOX1NUUklOR1MucHJpbnRfcHJvZ3Jlc3NfcGVyY2VudCA9IFwie3twcm9ncmVzc319JVwiO1xufVxuZnVuY3Rpb24gZ2V0TDEwbkZhbGxiYWNrKGtleSwgYXJncykge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgXCJmaW5kX21hdGNoX2NvdW50XCI6XG4gICAgICBrZXkgPSBgZmluZF9tYXRjaF9jb3VudFske2FyZ3MudG90YWwgPT09IDEgPyBcIm9uZVwiIDogXCJvdGhlclwifV1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbmRfbWF0Y2hfY291bnRfbGltaXRcIjpcbiAgICAgIGtleSA9IGBmaW5kX21hdGNoX2NvdW50X2xpbWl0WyR7YXJncy5saW1pdCA9PT0gMSA/IFwib25lXCIgOiBcIm90aGVyXCJ9XWA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gREVGQVVMVF9MMTBOX1NUUklOR1Nba2V5XSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gZm9ybWF0TDEwblZhbHVlKHRleHQsIGFyZ3MpIHtcbiAgaWYgKCFhcmdzKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgcmV0dXJuIHRleHQucmVwbGFjZUFsbCgvXFx7XFx7XFxzKihcXHcrKVxccypcXH1cXH0vZywgKGFsbCwgbmFtZSkgPT4ge1xuICAgIHJldHVybiBuYW1lIGluIGFyZ3MgPyBhcmdzW25hbWVdIDogXCJ7e1wiICsgbmFtZSArIFwifX1cIjtcbiAgfSk7XG59XG5jb25zdCBOdWxsTDEwbiA9IHtcbiAgYXN5bmMgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIFwiZW4tdXNcIjtcbiAgfSxcbiAgYXN5bmMgZ2V0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBcImx0clwiO1xuICB9LFxuICBhc3luYyBnZXQoa2V5LCBhcmdzID0gbnVsbCwgZmFsbGJhY2sgPSBnZXRMMTBuRmFsbGJhY2soa2V5LCBhcmdzKSkge1xuICAgIHJldHVybiBmb3JtYXRMMTBuVmFsdWUoZmFsbGJhY2ssIGFyZ3MpO1xuICB9LFxuICBhc3luYyB0cmFuc2xhdGUoZWxlbWVudCkge31cbn07XG5leHBvcnRzLk51bGxMMTBuID0gTnVsbEwxMG47XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuWGZhTGF5ZXIgPSB2b2lkIDA7XG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbW3Jvb3QsIC0xLCByb290SHRtbF1dO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaW50ZW50ICE9PSBcInJpY2hUZXh0XCIpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0RGl2cyA9IFtdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBbcGFyZW50LCBpLCBodG1sXSA9IHN0YWNrLmF0KC0xKTtcbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlblsrK3N0YWNrLmF0KC0xKVsxXV07XG4gICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgaHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRIdG1sID0gY2hpbGQ/LmF0dHJpYnV0ZXM/LnhtbG5zID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIGh0bWwuYXBwZW5kKGNoaWxkSHRtbCk7XG4gICAgICBpZiAoY2hpbGQuYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGh0bWw6IGNoaWxkSHRtbCxcbiAgICAgICAgICBlbGVtZW50OiBjaGlsZCxcbiAgICAgICAgICBzdG9yYWdlLFxuICAgICAgICAgIGludGVudCxcbiAgICAgICAgICBsaW5rU2VydmljZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChfeGZhX3RleHQuWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkSHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWwgb2Ygcm9vdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLnhmYU5vbkludGVyYWN0aXZlIGlucHV0LCAueGZhTm9uSW50ZXJhY3RpdmUgdGV4dGFyZWFcIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRPbmx5XCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERpdnNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyB1cGRhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICBwYXJhbWV0ZXJzLmRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcGFyYW1ldGVycy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbn1cbmV4cG9ydHMuWGZhTGF5ZXIgPSBYZmFMYXllcjtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5JbmtFZGl0b3IgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5jbGFzcyBJbmtFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYmFzZUhlaWdodCA9IDA7XG4gICNiYXNlV2lkdGggPSAwO1xuICAjYm91bmRDYW52YXNQb2ludGVybW92ZSA9IHRoaXMuY2FudmFzUG9pbnRlcm1vdmUuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlID0gdGhpcy5jYW52YXNQb2ludGVybGVhdmUuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcnVwID0gdGhpcy5jYW52YXNQb2ludGVydXAuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24gPSB0aGlzLmNhbnZhc1BvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICNjdXJyZW50UGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAjZGlzYWJsZUVkaXRpbmcgPSBmYWxzZTtcbiAgI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAjaXNDYW52YXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVhbFdpZHRoID0gMDtcbiAgI3JlYWxIZWlnaHQgPSAwO1xuICAjcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdE9wYWNpdHkgPSAxO1xuICBzdGF0aWMgX2RlZmF1bHRUaGlja25lc3MgPSAxO1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBudWxsO1xuICAgIHRoaXMudGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBudWxsO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IG51bGw7XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMuYmV6aWVyUGF0aDJEID0gW107XG4gICAgdGhpcy5hbGxSYXdQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gMTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHtcbiAgICAgIHN0cmluZ3M6IFtcImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWxcIiwgXCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsXCJdXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSA9IHZhbHVlIC8gMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZOlxuICAgICAgICB0aGlzLiN1cGRhdGVPcGFjaXR5KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSAqIDEwMCldXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsIHRoaXMudGhpY2tuZXNzIHx8IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzc10sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIHRoaXMuY29sb3IgfHwgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKDEwMCAqICh0aGlzLm9wYWNpdHkgPz8gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSkpXV07XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBzYXZlZFRoaWNrbmVzcyA9IHRoaXMudGhpY2tuZXNzO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMudGhpY2tuZXNzID0gc2F2ZWRUaGlja25lc3M7XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgb3BhY2l0eSAvPSAxMDA7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gc2F2ZWRPcGFjaXR5O1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgfVxuICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZSgpO1xuICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICB0aGlzLiNvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50ICYmIHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZVNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiBwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcgfHwgdGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlZGl0aW5nXCIpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSAhdGhpcy5pc0VtcHR5KCk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRocy5sZW5ndGggPT09IDAgfHwgdGhpcy5wYXRocy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXRoc1swXS5sZW5ndGggPT09IDA7XG4gIH1cbiAgI2dldEluaXRpYWxCQm94KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFJvdGF0aW9uLFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3dpZHRoLCBoZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChwYXJlbnRSb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFswLCBoZWlnaHQsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgMCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzAsIDAsIHdpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgfVxuICAjc2V0U3Ryb2tlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgc2NhbGVGYWN0b3JcbiAgICB9ID0gdGhpcztcbiAgICBjdHgubGluZVdpZHRoID0gdGhpY2tuZXNzICogcGFyZW50U2NhbGUgLyBzY2FsZUZhY3RvcjtcbiAgICBjdHgubGluZUNhcCA9IFwicm91bmRcIjtcbiAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSAxMDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBgJHtjb2xvcn0keygwLCBfdG9vbHMub3BhY2l0eVRvSGV4KShvcGFjaXR5KX1gO1xuICB9XG4gICNzdGFydERyYXdpbmcoeCwgeSkge1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmxlYXZlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybW92ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy50aGlja25lc3MgfHw9IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICAgIHRoaXMuY29sb3IgfHw9IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICAgIHRoaXMub3BhY2l0eSA/Pz0gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNkcmF3UG9pbnRzKCk7XG4gICAgICBpZiAodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKTtcbiAgfVxuICAjZHJhdyh4LCB5KSB7XG4gICAgY29uc3QgW2xhc3RYLCBsYXN0WV0gPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPiAxICYmIHggPT09IGxhc3RYICYmIHkgPT09IGxhc3RZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICBsZXQgcGF0aDJEID0gdGhpcy4jY3VycmVudFBhdGgyRDtcbiAgICBjdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gdHJ1ZTtcbiAgICBpZiAoY3VycmVudFBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgICAgcGF0aDJELmxpbmVUbyh4LCB5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IHBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uY3VycmVudFBhdGhbMF0pO1xuICAgIH1cbiAgICB0aGlzLiNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCAuLi5jdXJyZW50UGF0aC5hdCgtMyksIC4uLmN1cnJlbnRQYXRoLmF0KC0yKSwgeCwgeSk7XG4gIH1cbiAgI2VuZFBhdGgoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RQb2ludCA9IHRoaXMuY3VycmVudFBhdGguYXQoLTEpO1xuICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQubGluZVRvKC4uLmxhc3RQb2ludCk7XG4gIH1cbiAgI3N0b3BEcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayA9IG51bGw7XG4gICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIDApLCB0aGlzLmNhbnZhcy53aWR0aCk7XG4gICAgeSA9IE1hdGgubWluKE1hdGgubWF4KHksIDApLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuI2RyYXcoeCwgeSk7XG4gICAgdGhpcy4jZW5kUGF0aCgpO1xuICAgIGxldCBiZXppZXI7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoICE9PSAxKSB7XG4gICAgICBiZXppZXIgPSB0aGlzLiNnZW5lcmF0ZUJlemllclBvaW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB4eSA9IFt4LCB5XTtcbiAgICAgIGJlemllciA9IFtbeHksIHh5LnNsaWNlKCksIHh5LnNsaWNlKCksIHh5XV07XG4gICAgfVxuICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY29uc3QgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucHVzaChjdXJyZW50UGF0aCk7XG4gICAgICB0aGlzLnBhdGhzLnB1c2goYmV6aWVyKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnB1c2gocGF0aDJEKTtcbiAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWxsUmF3UGF0aHMucG9wKCk7XG4gICAgICB0aGlzLnBhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5iZXppZXJQYXRoMkQucG9wKCk7XG4gICAgICBpZiAodGhpcy5wYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICAjZHJhd1BvaW50cygpIHtcbiAgICBpZiAoIXRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgICBjb25zdCB0aGlja25lc3MgPSBNYXRoLmNlaWwodGhpcy50aGlja25lc3MgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICBjb25zdCBsYXN0UG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5zbGljZSgtMyk7XG4gICAgY29uc3QgeCA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzBdKTtcbiAgICBjb25zdCB5ID0gbGFzdFBvaW50cy5tYXAoeHkgPT4geHlbMV0pO1xuICAgIGNvbnN0IHhNaW4gPSBNYXRoLm1pbiguLi54KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoLi4ueCkgKyB0aGlja25lc3M7XG4gICAgY29uc3QgeU1pbiA9IE1hdGgubWluKC4uLnkpIC0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNYXggPSBNYXRoLm1heCguLi55KSArIHRoaWNrbmVzcztcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKHRoaXMuI2N1cnJlbnRQYXRoMkQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgI21ha2VCZXppZXJDdXJ2ZShwYXRoMkQsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjb25zdCBwcmV2WCA9ICh4MCArIHgxKSAvIDI7XG4gICAgY29uc3QgcHJldlkgPSAoeTAgKyB5MSkgLyAyO1xuICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgcGF0aDJELmJlemllckN1cnZlVG8ocHJldlggKyAyICogKHgxIC0gcHJldlgpIC8gMywgcHJldlkgKyAyICogKHkxIC0gcHJldlkpIC8gMywgeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gMywgeDMsIHkzKTtcbiAgfVxuICAjZ2VuZXJhdGVCZXppZXJQb2ludHMoKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgaWYgKHBhdGgubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBbW3BhdGhbMF0sIHBhdGhbMF0sIHBhdGguYXQoLTEpLCBwYXRoLmF0KC0xKV1dO1xuICAgIH1cbiAgICBjb25zdCBiZXppZXJQb2ludHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgW3gwLCB5MF0gPSBwYXRoWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBwYXRoLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgY29uc3QgW3gxLCB5MV0gPSBwYXRoW2ldO1xuICAgICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICAgIGNvbnN0IHgzID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGNvbnN0IHkzID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgICAgY29uc3QgY29udHJvbDIgPSBbeDMgKyAyICogKHgxIC0geDMpIC8gMywgeTMgKyAyICogKHkxIC0geTMpIC8gM107XG4gICAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gzLCB5M11dKTtcbiAgICAgIFt4MCwgeTBdID0gW3gzLCB5M107XG4gICAgfVxuICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICBjb25zdCBbeDIsIHkyXSA9IHBhdGhbaSArIDFdO1xuICAgIGNvbnN0IGNvbnRyb2wxID0gW3gwICsgMiAqICh4MSAtIHgwKSAvIDMsIHkwICsgMiAqICh5MSAtIHkwKSAvIDNdO1xuICAgIGNvbnN0IGNvbnRyb2wyID0gW3gyICsgMiAqICh4MSAtIHgyKSAvIDMsIHkyICsgMiAqICh5MSAtIHkyKSAvIDNdO1xuICAgIGJlemllclBvaW50cy5wdXNoKFtbeDAsIHkwXSwgY29udHJvbDEsIGNvbnRyb2wyLCBbeDIsIHkyXV0pO1xuICAgIHJldHVybiBiZXppZXJQb2ludHM7XG4gIH1cbiAgI3JlZHJhdygpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXMsXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5iZXppZXJQYXRoMkQpIHtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQodHJ1ZSk7XG4gICAgdGhpcy5tYWtlUmVzaXphYmxlKCk7XG4gICAgdGhpcy5wYXJlbnQuYWRkSW5rRWRpdG9ySWZOZWVkZWQodHJ1ZSk7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgfVxuICBjYW52YXNQb2ludGVyZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXRoaXMuaXNJbkVkaXRNb2RlKCkgfHwgdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChldmVudC50eXBlICE9PSBcIm1vdXNlXCIpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICAgIHRoaXMuI3N0YXJ0RHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVybW92ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jZHJhdyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVydXAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJsZWF2ZShldmVudCkge1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gICNlbmREcmF3aW5nKGV2ZW50KSB7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVydXApO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfZGlzcGxheV91dGlscy5ub0NvbnRleHRNZW51KTtcbiAgICB9LCAxMCk7XG4gICAgdGhpcy4jc3RvcERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gICAgdGhpcy5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gXCJpbmtFZGl0b3JDYW52YXNcIjtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5jYW52YXM/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcbiAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0VtcHR5KCkgJiYgdGhpcy4jZGlzYWJsZUVkaXRpbmc7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9pbmsyX2FyaWFfbGFiZWxcIikudGhlbihtc2cgPT4gdGhpcy5kaXY/LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKSk7XG4gICAgY29uc3QgW3gsIHksIHcsIGhdID0gdGhpcy4jZ2V0SW5pdGlhbEJCb3goKTtcbiAgICB0aGlzLnNldEF0KHgsIHksIDAsIDApO1xuICAgIHRoaXMuc2V0RGltcyh3LCBoKTtcbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImVkaXRpbmdcIik7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDYW52YXNEaW1zKCkge1xuICAgIGlmICghdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLmNlaWwodGhpcy53aWR0aCAqIHBhcmVudFdpZHRoKTtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuI3VwZGF0ZVRyYW5zZm9ybSgpO1xuICB9XG4gIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHRoaXMuI3JlYWxXaWR0aCA9PT0gcm91bmRlZFdpZHRoICYmIHRoaXMuI3JlYWxIZWlnaHQgPT09IHJvdW5kZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gcm91bmRlZFdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSByb3VuZGVkSGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICB0aGlzLmZpeERpbXMoKTtcbiAgfVxuICAjc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JXID0gKHdpZHRoIC0gcGFkZGluZykgLyB0aGlzLiNiYXNlV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JIID0gKGhlaWdodCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZUhlaWdodDtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gTWF0aC5taW4oc2NhbGVGYWN0b3JXLCBzY2FsZUZhY3RvckgpO1xuICB9XG4gICN1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKSAvIDI7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHRoaXMuc2NhbGVGYWN0b3IsIDAsIDAsIHRoaXMuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcsIHRoaXMudHJhbnNsYXRpb25ZICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyAjYnVpbGRQYXRoMkQoYmV6aWVyKSB7XG4gICAgY29uc3QgcGF0aDJEID0gbmV3IFBhdGgyRCgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltpXTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uZmlyc3QpO1xuICAgICAgfVxuICAgICAgcGF0aDJELmJlemllckN1cnZlVG8oY29udHJvbDFbMF0sIGNvbnRyb2wxWzFdLCBjb250cm9sMlswXSwgY29udHJvbDJbMV0sIHNlY29uZFswXSwgc2Vjb25kWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgyRDtcbiAgfVxuICBzdGF0aWMgI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldICs9IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdICsgYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4ICsgYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gKz0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBzdGF0aWMgI2Zyb21QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gLT0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gLSBibFk7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggLSBibFg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSAtPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWCAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gICNzZXJpYWxpemVQYXRocyhzLCB0eCwgdHksIHJlY3QpIHtcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLnRoaWNrbmVzcyAvIDI7XG4gICAgY29uc3Qgc2hpZnRYID0gcyAqIHR4ICsgcGFkZGluZztcbiAgICBjb25zdCBzaGlmdFkgPSBzICogdHkgKyBwYWRkaW5nO1xuICAgIGZvciAoY29uc3QgYmV6aWVyIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSBiZXppZXIubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltqXTtcbiAgICAgICAgY29uc3QgcDEwID0gcyAqIGZpcnN0WzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMTEgPSBzICogZmlyc3RbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHMgKiBjb250cm9sMVswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDIxID0gcyAqIGNvbnRyb2wxWzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMzAgPSBzICogY29udHJvbDJbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAzMSA9IHMgKiBjb250cm9sMlsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDQwID0gcyAqIHNlY29uZFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDQxID0gcyAqIHNlY29uZFsxXSArIHNoaWZ0WTtcbiAgICAgICAgaWYgKGogPT09IDApIHtcbiAgICAgICAgICBidWZmZXIucHVzaChwMTAsIHAxMSk7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEpO1xuICAgICAgICBwb2ludHMucHVzaChwMjAsIHAyMSk7XG4gICAgICAgIGlmIChqID09PSBqaiAtIDEpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChwNDAsIHA0MSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICBiZXppZXI6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhidWZmZXIsIHJlY3QsIHRoaXMucm90YXRpb24pLFxuICAgICAgICBwb2ludHM6IElua0VkaXRvci4jdG9QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHRoaXMucm90YXRpb24pXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG4gICNnZXRCYm94KCkge1xuICAgIGxldCB4TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHhNYXggPSAtSW5maW5pdHk7XG4gICAgbGV0IHlNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgdGhpcy5wYXRocykge1xuICAgICAgZm9yIChjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBfdXRpbC5VdGlsLmJlemllckJvdW5kaW5nQm94KC4uLmZpcnN0LCAuLi5jb250cm9sMSwgLi4uY29udHJvbDIsIC4uLnNlY29uZCk7XG4gICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBiYm94WzBdKTtcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIGJib3hbMV0pO1xuICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgYmJveFsyXSk7XG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBiYm94WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt4TWluLCB5TWluLCB4TWF4LCB5TWF4XTtcbiAgfVxuICAjZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlzYWJsZUVkaXRpbmcgPyBNYXRoLmNlaWwodGhpcy50aGlja25lc3MgKiB0aGlzLnBhcmVudFNjYWxlKSA6IDA7XG4gIH1cbiAgI2ZpdFRvQ29udGVudChmaXJzdFRpbWUgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2dldEJib3goKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpO1xuICAgIHRoaXMuI2Jhc2VXaWR0aCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIHRoaXMuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChwYWRkaW5nICsgdGhpcy4jYmFzZVdpZHRoICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlSGVpZ2h0ICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IC1iYm94WzBdO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gLWJib3hbMV07XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHVuc2NhbGVkUGFkZGluZyA9IGZpcnN0VGltZSA/IHBhZGRpbmcgLyB0aGlzLnNjYWxlRmFjdG9yIC8gMiA6IDA7XG4gICAgdGhpcy50cmFuc2xhdGUocHJldlRyYW5zbGF0aW9uWCAtIHRoaXMudHJhbnNsYXRpb25YIC0gdW5zY2FsZWRQYWRkaW5nLCBwcmV2VHJhbnNsYXRpb25ZIC0gdGhpcy50cmFuc2xhdGlvblkgLSB1bnNjYWxlZFBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX2Fubm90YXRpb25fbGF5ZXIuSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLnRoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIGVkaXRvci5jb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gZWRpdG9yLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVkaXRvci5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZWRpdG9yLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkYXRhLnRoaWNrbmVzcyAvIDI7XG4gICAgZWRpdG9yLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgZWRpdG9yLiNyZWFsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBlZGl0b3IuI3JlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aHMsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBmb3IgKGxldCB7XG4gICAgICBiZXppZXJcbiAgICB9IG9mIHBhdGhzKSB7XG4gICAgICBiZXppZXIgPSBJbmtFZGl0b3IuI2Zyb21QREZDb29yZGluYXRlcyhiZXppZXIsIHJlY3QsIHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgIGVkaXRvci5wYXRocy5wdXNoKHBhdGgpO1xuICAgICAgbGV0IHAwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzBdIC0gcGFkZGluZyk7XG4gICAgICBsZXQgcDEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMV0gLSBwYWRkaW5nKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IHAxMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMTEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDFdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMl0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAzXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDRdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNV0gLSBwYWRkaW5nKTtcbiAgICAgICAgcGF0aC5wdXNoKFtbcDAsIHAxXSwgW3AxMCwgcDExXSwgW3AyMCwgcDIxXSwgW3AzMCwgcDMxXV0pO1xuICAgICAgICBwMCA9IHAzMDtcbiAgICAgICAgcDEgPSBwMzE7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNidWlsZFBhdGgyRChwYXRoKTtcbiAgICAgIGVkaXRvci5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gZWRpdG9yLiNnZXRCYm94KCk7XG4gICAgZWRpdG9yLiNiYXNlV2lkdGggPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICBlZGl0b3IuI2Jhc2VIZWlnaHQgPSBNYXRoLm1heChfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBlZGl0b3IuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QoMCwgMCk7XG4gICAgY29uc3QgY29sb3IgPSBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY3R4LnN0cm9rZVN0eWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSyxcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLnRoaWNrbmVzcyxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIHBhdGhzOiB0aGlzLiNzZXJpYWxpemVQYXRocyh0aGlzLnNjYWxlRmFjdG9yIC8gdGhpcy5wYXJlbnRTY2FsZSwgdGhpcy50cmFuc2xhdGlvblgsIHRoaXMudHJhbnNsYXRpb25ZLCByZWN0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuSW5rRWRpdG9yID0gSW5rRWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YW1wRWRpdG9yID0gdm9pZCAwO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbmNsYXNzIFN0YW1wRWRpdG9yIGV4dGVuZHMgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JpdG1hcCA9IG51bGw7XG4gICNiaXRtYXBJZCA9IG51bGw7XG4gICNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgI2JpdG1hcFVybCA9IG51bGw7XG4gICNiaXRtYXBGaWxlID0gbnVsbDtcbiAgI2NhbnZhcyA9IG51bGw7XG4gICNvYnNlcnZlciA9IG51bGw7XG4gICNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAjaXNTdmcgPSBmYWxzZTtcbiAgI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gIHN0YXRpYyBfdHlwZSA9IFwic3RhbXBcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJzdGFtcEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jYml0bWFwVXJsID0gcGFyYW1zLmJpdG1hcFVybDtcbiAgICB0aGlzLiNiaXRtYXBGaWxlID0gcGFyYW1zLmJpdG1hcEZpbGU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbikge1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4pO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXMoKSB7XG4gICAgY29uc3QgdHlwZXMgPSBbXCJhcG5nXCIsIFwiYXZpZlwiLCBcImJtcFwiLCBcImdpZlwiLCBcImpwZWdcIiwgXCJwbmdcIiwgXCJzdmcreG1sXCIsIFwid2VicFwiLCBcIngtaWNvblwiXTtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJzdXBwb3J0ZWRUeXBlc1wiLCB0eXBlcy5tYXAodHlwZSA9PiBgaW1hZ2UvJHt0eXBlfWApKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzU3RyKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInN1cHBvcnRlZFR5cGVzU3RyXCIsIHRoaXMuc3VwcG9ydGVkVHlwZXMuam9pbihcIixcIikpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiB0aGlzLnN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3IoX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICAjZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCBmcm9tSWQgPSBmYWxzZSkge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYml0bWFwID0gZGF0YS5iaXRtYXA7XG4gICAgaWYgKCFmcm9tSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gZGF0YS5pZDtcbiAgICAgIHRoaXMuI2lzU3ZnID0gZGF0YS5pc1N2ZztcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgI2dldEJpdG1hcERvbmUoKSB7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGlmICh0aGlzLiNjYW52YXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdGFtcEVkaXRvci5zdXBwb3J0ZWRUeXBlc1N0cjtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuI2JpdG1hcCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmRlbGV0ZUlkKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIHRoaXMuI2NhbnZhcz8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNjYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gISh0aGlzLiNiaXRtYXBQcm9taXNlIHx8IHRoaXMuI2JpdG1hcCB8fCB0aGlzLiNiaXRtYXBVcmwgfHwgdGhpcy4jYml0bWFwRmlsZSk7XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNjcmVhdGVDYW52YXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgTUFYX1JBVElPID0gMC43NTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAod2lkdGggPiBNQVhfUkFUSU8gKiBwYWdlV2lkdGggfHwgaGVpZ2h0ID4gTUFYX1JBVElPICogcGFnZUhlaWdodCkge1xuICAgICAgY29uc3QgZmFjdG9yID0gTWF0aC5taW4oTUFYX1JBVElPICogcGFnZVdpZHRoIC8gd2lkdGgsIE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgd2lkdGggKj0gZmFjdG9yO1xuICAgICAgaGVpZ2h0ICo9IGZhY3RvcjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCAqIHBhcmVudFdpZHRoIC8gcGFnZVdpZHRoLCBoZWlnaHQgKiBwYXJlbnRIZWlnaHQgLyBwYWdlSGVpZ2h0KTtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBkaXYuYXBwZW5kKGNhbnZhcyk7XG4gICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICAgIHRoaXMuI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcInJlcG9ydHRlbGVtZXRyeVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBkZXRhaWxzOiB7XG4gICAgICAgIHR5cGU6IFwiZWRpdGluZ1wiLFxuICAgICAgICBzdWJ0eXBlOiB0aGlzLmVkaXRvclR5cGUsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRBbHRUZXh0QnV0dG9uKCk7XG4gIH1cbiAgI3NldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldERpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxPcHRpb25zPy5pc0NlbnRlcmVkKSB7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jcmVzaXplVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICB9XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMjAwO1xuICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoOiBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodDogYml0bWFwSGVpZ2h0XG4gICAgfSA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgbmV3V2lkdGggPSBiaXRtYXBXaWR0aDtcbiAgICBsZXQgbmV3SGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgd2hpbGUgKG5ld1dpZHRoID4gMiAqIHdpZHRoIHx8IG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXZXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY29uc3QgcHJldkhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIGlmIChuZXdXaWR0aCA+IDIgKiB3aWR0aCkge1xuICAgICAgICBuZXdXaWR0aCA9IG5ld1dpZHRoID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdXaWR0aCAvIDIpO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0hlaWdodCA+IDIgKiBoZWlnaHQpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDE2Mzg0ID8gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3SGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYml0bWFwO1xuICB9XG4gICNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gd2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLiNzZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX2xheWVyLlN0YW1wQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIGJpdG1hcFVybCxcbiAgICAgIGJpdG1hcElkLFxuICAgICAgaXNTdmcsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YVxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChiaXRtYXBJZCAmJiB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIGVkaXRvci4jYml0bWFwSWQgPSBiaXRtYXBJZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICBiaXRtYXBJZDogdGhpcy4jYml0bWFwSWQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRSZWN0KDAsIDApLFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBpc1N2ZzogdGhpcy4jaXNTdmcsXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXBVcmwgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0gdGhpcy5hbHRUZXh0RGF0YTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNvcmF0aXZlLFxuICAgICAgYWx0VGV4dFxuICAgIH0gPSB0aGlzLmFsdFRleHREYXRhO1xuICAgIGlmICghZGVjb3JhdGl2ZSAmJiBhbHRUZXh0KSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IGFsdFRleHRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29udGV4dC5zdGFtcHMgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhcmVhID0gdGhpcy4jaXNTdmcgPyAoc2VyaWFsaXplZC5yZWN0WzJdIC0gc2VyaWFsaXplZC5yZWN0WzBdKSAqIChzZXJpYWxpemVkLnJlY3RbM10gLSBzZXJpYWxpemVkLnJlY3RbMV0pIDogbnVsbDtcbiAgICBpZiAoIWNvbnRleHQuc3RhbXBzLmhhcyh0aGlzLiNiaXRtYXBJZCkpIHtcbiAgICAgIGNvbnRleHQuc3RhbXBzLnNldCh0aGlzLiNiaXRtYXBJZCwge1xuICAgICAgICBhcmVhLFxuICAgICAgICBzZXJpYWxpemVkXG4gICAgICB9KTtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBwcmV2RGF0YSA9IGNvbnRleHQuc3RhbXBzLmdldCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICBpZiAoYXJlYSA+IHByZXZEYXRhLmFyZWEpIHtcbiAgICAgICAgcHJldkRhdGEuYXJlYSA9IGFyZWE7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHByZXZEYXRhLnNlcmlhbGl6ZWQuYml0bWFwID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbn1cbmV4cG9ydHMuU3RhbXBFZGl0b3IgPSBTdGFtcEVkaXRvcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd19wZGZqc19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkIHRvIGJlIHdyYXBwZWQgaW4gYW4gSUlGRSBiZWNhdXNlIGl0IG5lZWQgdG8gYmUgaXNvbGF0ZWQgYWdhaW5zdCBvdGhlciBtb2R1bGVzIGluIHRoZSBjaHVuay5cbigoKSA9PiB7XG52YXIgZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJvcnRFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFib3J0RXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclR5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9sYXllci5Bbm5vdGF0aW9uTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25Nb2RlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uTW9kZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ01hcENvbXByZXNzaW9uVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRE9NU1ZHRmFjdG9yeVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmVhdHVyZVRlc3RcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkZlYXR1cmVUZXN0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxXb3JrZXJPcHRpb25zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VLaW5kXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5JbWFnZUtpbmQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFsaWRQREZFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkludmFsaWRQREZFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1pc3NpbmdQREZFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9QU1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuT1BTO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRhUmFuZ2VUcmFuc3BvcnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuUERGRGF0YVJhbmdlVHJhbnNwb3J0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRlU3RyaW5nXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5QREZEYXRlU3RyaW5nO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZXb3JrZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuUERGV29ya2VyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXNzd29yZFJlc3BvbnNlc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGFzc3dvcmRSZXNwb25zZXM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBlcm1pc3Npb25GbGFnXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5QZXJtaXNzaW9uRmxhZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGl4ZWxzUGVySW5jaFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvbWlzZUNhcGFiaWxpdHlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlByb21pc2VDYXBhYmlsaXR5O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHR3JhcGhpY3NcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVdGlsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWZXJib3NpdHlMZXZlbFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVmVyYm9zaXR5TGV2ZWw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlhmYUxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfeGZhX2xheWVyLlhmYUxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5idWlsZDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0RG9jdW1lbnRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuZ2V0RG9jdW1lbnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpbGVuYW1lRnJvbVVybFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0RmlsZW5hbWVGcm9tVXJsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQZGZGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldFBkZkZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0WGZhUGFnZVZpZXdwb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRYZmFQYWdlVmlld3BvcnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRGF0YVNjaGVtZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuaXNEYXRhU2NoZW1lO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BkZkZpbGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFNjcmlwdFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9Db250ZXh0TWVudVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9ybWFsaXplVW5pY29kZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwubm9ybWFsaXplVW5pY29kZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVuZGVyVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci5yZW5kZXJUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldExheWVyRGltZW5zaW9uc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGFkb3dcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLnNoYWRvdztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXBkYXRlVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci51cGRhdGVUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkudmVyc2lvbjtcbiAgfVxufSkpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfYXBpID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgX3RleHRfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciBfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgX3dvcmtlcl9vcHRpb25zID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgX3hmYV9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xuY29uc3QgcGRmanNWZXJzaW9uID0gJzMuMTEuMTc0JztcbmNvbnN0IHBkZmpzQnVpbGQgPSAnY2U4NzE2NzQzJztcbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5qcy5tYXAiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJwZGZqc0xpYiIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiVmVyYm9zaXR5TGV2ZWwiLCJVdGlsIiwiVW5rbm93bkVycm9yRXhjZXB0aW9uIiwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIiwiVGV4dFJlbmRlcmluZ01vZGUiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiUHJvbWlzZUNhcGFiaWxpdHkiLCJQZXJtaXNzaW9uRmxhZyIsIlBhc3N3b3JkUmVzcG9uc2VzIiwiUGFzc3dvcmRFeGNlcHRpb24iLCJQYWdlQWN0aW9uRXZlbnRUeXBlIiwiT1BTIiwiTWlzc2luZ1BERkV4Y2VwdGlvbiIsIk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFIiwiTElORV9GQUNUT1IiLCJMSU5FX0RFU0NFTlRfRkFDVE9SIiwiSW52YWxpZFBERkV4Y2VwdGlvbiIsIkltYWdlS2luZCIsIklERU5USVRZX01BVFJJWCIsIkZvcm1hdEVycm9yIiwiRmVhdHVyZVRlc3QiLCJGT05UX0lERU5USVRZX01BVFJJWCIsIkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlIiwiQ01hcENvbXByZXNzaW9uVHlwZSIsIkJhc2VFeGNlcHRpb24iLCJCQVNFTElORV9GQUNUT1IiLCJBbm5vdGF0aW9uVHlwZSIsIkFubm90YXRpb25SZXBseVR5cGUiLCJBbm5vdGF0aW9uUHJlZml4IiwiQW5ub3RhdGlvbk1vZGUiLCJBbm5vdGF0aW9uRmxhZyIsIkFubm90YXRpb25GaWVsZEZsYWciLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsIkFubm90YXRpb25FZGl0b3JQcmVmaXgiLCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSIsIkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiQWJvcnRFeGNlcHRpb24iLCJhc3NlcnQiLCJieXRlc1RvU3RyaW5nIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImdldE1vZGlmaWNhdGlvbkRhdGUiLCJnZXRVdWlkIiwiZ2V0VmVyYm9zaXR5TGV2ZWwiLCJpbmZvIiwiaXNBcnJheUJ1ZmZlciIsImlzQXJyYXlFcXVhbCIsImlzTm9kZUpTIiwibm9ybWFsaXplVW5pY29kZSIsIm9iamVjdEZyb21NYXAiLCJvYmplY3RTaXplIiwic2V0VmVyYm9zaXR5TGV2ZWwiLCJzaGFkb3ciLCJzdHJpbmczMiIsInN0cmluZ1RvQnl0ZXMiLCJzdHJpbmdUb1BERlN0cmluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsInVucmVhY2hhYmxlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwid2FybiIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm53IiwiZWxlY3Ryb24iLCJ0eXBlIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJPUExJU1QiLCJESVNBQkxFIiwiRU5BQkxFIiwiRU5BQkxFX0ZPUk1TIiwiRU5BQkxFX1NUT1JBR0UiLCJOT05FIiwiRlJFRVRFWFQiLCJTVEFNUCIsIklOSyIsIlJFU0laRSIsIkNSRUFURSIsIkZSRUVURVhUX1NJWkUiLCJGUkVFVEVYVF9DT0xPUiIsIkZSRUVURVhUX09QQUNJVFkiLCJJTktfQ09MT1IiLCJJTktfVEhJQ0tORVNTIiwiSU5LX09QQUNJVFkiLCJNT0RJRllfQ09OVEVOVFMiLCJDT1BZIiwiTU9ESUZZX0FOTk9UQVRJT05TIiwiRklMTF9JTlRFUkFDVElWRV9GT1JNUyIsIkNPUFlfRk9SX0FDQ0VTU0lCSUxJVFkiLCJBU1NFTUJMRSIsIlBSSU5UX0hJR0hfUVVBTElUWSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfTUFTSyIsIkFERF9UT19QQVRIX0ZMQUciLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJURVhUIiwiTElOSyIsIkxJTkUiLCJTUVVBUkUiLCJDSVJDTEUiLCJQT0xZR09OIiwiUE9MWUxJTkUiLCJISUdITElHSFQiLCJVTkRFUkxJTkUiLCJTUVVJR0dMWSIsIlNUUklLRU9VVCIsIkNBUkVUIiwiUE9QVVAiLCJGSUxFQVRUQUNITUVOVCIsIlNPVU5EIiwiTU9WSUUiLCJXSURHRVQiLCJTQ1JFRU4iLCJQUklOVEVSTUFSSyIsIlRSQVBORVQiLCJXQVRFUk1BUksiLCJUSFJFRUQiLCJSRURBQ1QiLCJHUk9VUCIsIlJFUExZIiwiSElEREVOIiwiTk9aT09NIiwiTk9ST1RBVEUiLCJOT1ZJRVciLCJSRUFET05MWSIsIkxPQ0tFRCIsIlRPR0dMRU5PVklFVyIsIkxPQ0tFRENPTlRFTlRTIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJTT0xJRCIsIkRBU0hFRCIsIkJFVkVMRUQiLCJJTlNFVCIsIkUiLCJYIiwiRCIsIlUiLCJGbyIsIkJsIiwiUE8iLCJQQyIsIlBWIiwiUEkiLCJLIiwiRiIsIlYiLCJDIiwiV0MiLCJXUyIsIkRTIiwiV1AiLCJEUCIsIk8iLCJFUlJPUlMiLCJXQVJOSU5HUyIsIklORk9TIiwiQklOQVJZIiwiZGVwZW5kZW5jeSIsInNldExpbmVXaWR0aCIsInNldExpbmVDYXAiLCJzZXRMaW5lSm9pbiIsInNldE1pdGVyTGltaXQiLCJzZXREYXNoIiwic2V0UmVuZGVyaW5nSW50ZW50Iiwic2V0RmxhdG5lc3MiLCJzZXRHU3RhdGUiLCJzYXZlIiwicmVzdG9yZSIsInRyYW5zZm9ybSIsIm1vdmVUbyIsImxpbmVUbyIsImN1cnZlVG8iLCJjdXJ2ZVRvMiIsImN1cnZlVG8zIiwiY2xvc2VQYXRoIiwicmVjdGFuZ2xlIiwic3Ryb2tlIiwiY2xvc2VTdHJva2UiLCJmaWxsIiwiZW9GaWxsIiwiZmlsbFN0cm9rZSIsImVvRmlsbFN0cm9rZSIsImNsb3NlRmlsbFN0cm9rZSIsImNsb3NlRU9GaWxsU3Ryb2tlIiwiZW5kUGF0aCIsImNsaXAiLCJlb0NsaXAiLCJiZWdpblRleHQiLCJlbmRUZXh0Iiwic2V0Q2hhclNwYWNpbmciLCJzZXRXb3JkU3BhY2luZyIsInNldEhTY2FsZSIsInNldExlYWRpbmciLCJzZXRGb250Iiwic2V0VGV4dFJlbmRlcmluZ01vZGUiLCJzZXRUZXh0UmlzZSIsIm1vdmVUZXh0Iiwic2V0TGVhZGluZ01vdmVUZXh0Iiwic2V0VGV4dE1hdHJpeCIsIm5leHRMaW5lIiwic2hvd1RleHQiLCJzaG93U3BhY2VkVGV4dCIsIm5leHRMaW5lU2hvd1RleHQiLCJuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dCIsInNldENoYXJXaWR0aCIsInNldENoYXJXaWR0aEFuZEJvdW5kcyIsInNldFN0cm9rZUNvbG9yU3BhY2UiLCJzZXRGaWxsQ29sb3JTcGFjZSIsInNldFN0cm9rZUNvbG9yIiwic2V0U3Ryb2tlQ29sb3JOIiwic2V0RmlsbENvbG9yIiwic2V0RmlsbENvbG9yTiIsInNldFN0cm9rZUdyYXkiLCJzZXRGaWxsR3JheSIsInNldFN0cm9rZVJHQkNvbG9yIiwic2V0RmlsbFJHQkNvbG9yIiwic2V0U3Ryb2tlQ01ZS0NvbG9yIiwic2V0RmlsbENNWUtDb2xvciIsInNoYWRpbmdGaWxsIiwiYmVnaW5JbmxpbmVJbWFnZSIsImJlZ2luSW1hZ2VEYXRhIiwiZW5kSW5saW5lSW1hZ2UiLCJwYWludFhPYmplY3QiLCJtYXJrUG9pbnQiLCJtYXJrUG9pbnRQcm9wcyIsImJlZ2luTWFya2VkQ29udGVudCIsImJlZ2luTWFya2VkQ29udGVudFByb3BzIiwiZW5kTWFya2VkQ29udGVudCIsImJlZ2luQ29tcGF0IiwiZW5kQ29tcGF0IiwicGFpbnRGb3JtWE9iamVjdEJlZ2luIiwicGFpbnRGb3JtWE9iamVjdEVuZCIsImJlZ2luR3JvdXAiLCJlbmRHcm91cCIsImJlZ2luQW5ub3RhdGlvbiIsImVuZEFubm90YXRpb24iLCJwYWludEltYWdlTWFza1hPYmplY3QiLCJwYWludEltYWdlTWFza1hPYmplY3RHcm91cCIsInBhaW50SW1hZ2VYT2JqZWN0IiwicGFpbnRJbmxpbmVJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3RSZXBlYXQiLCJwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQiLCJwYWludFNvbGlkQ29sb3JJbWFnZU1hc2siLCJjb25zdHJ1Y3RQYXRoIiwiTkVFRF9QQVNTV09SRCIsIklOQ09SUkVDVF9QQVNTV09SRCIsInZlcmJvc2l0eSIsImxldmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibXNnIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJ1cmwiLCJwcm90b2NvbCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsImFic29sdXRlVXJsIiwiVVJMIiwib2JqIiwicHJvcCIsIm5vblNlcmlhbGl6YWJsZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VFeGNlcHRpb25DbG9zdXJlIiwibWVzc2FnZSIsIm5hbWUiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNvZGUiLCJkZXRhaWxzIiwic3RhdHVzIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN0ckJ1ZiIsImkiLCJjaHVua0VuZCIsIk1hdGgiLCJtaW4iLCJjaHVuayIsInN1YmFycmF5IiwicHVzaCIsImpvaW4iLCJzdHIiLCJVaW50OEFycmF5IiwiY2hhckNvZGVBdCIsImtleXMiLCJtYXAiLCJjcmVhdGUiLCJrZXkiLCJpc0xpdHRsZUVuZGlhbiIsImJ1ZmZlcjgiLCJ2aWV3MzIiLCJVaW50MzJBcnJheSIsImJ1ZmZlciIsImlzRXZhbFN1cHBvcnRlZCIsIkZ1bmN0aW9uIiwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJPZmZzY3JlZW5DYW52YXMiLCJwbGF0Zm9ybSIsIm5hdmlnYXRvciIsImlzV2luIiwiaXNNYWMiLCJpbmNsdWRlcyIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJDU1MiLCJzdXBwb3J0cyIsImhleE51bWJlcnMiLCJBcnJheSIsIm4iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwibWFrZUhleENvbG9yIiwiciIsImciLCJiIiwic2NhbGVNaW5NYXgiLCJtaW5NYXgiLCJ0ZW1wIiwibTEiLCJtMiIsImFwcGx5VHJhbnNmb3JtIiwicCIsIm0iLCJ4dCIsInl0IiwiYXBwbHlJbnZlcnNlVHJhbnNmb3JtIiwiZCIsImdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicDEiLCJwMiIsInNsaWNlIiwicDMiLCJwNCIsIm1heCIsImludmVyc2VUcmFuc2Zvcm0iLCJzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSIsInRyYW5zcG9zZSIsImEiLCJjIiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0Iiwic3giLCJzeSIsIm5vcm1hbGl6ZVJlY3QiLCJyZWN0IiwiaW50ZXJzZWN0IiwicmVjdDEiLCJyZWN0MiIsInhMb3ciLCJ4SGlnaCIsInlMb3ciLCJ5SGlnaCIsImJlemllckJvdW5kaW5nQm94IiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsInR2YWx1ZXMiLCJib3VuZHMiLCJ0IiwidDEiLCJ0MiIsImIyYWMiLCJzcXJ0YjJhYyIsImFicyIsImoiLCJtdCIsImpsZW4iLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsImVuY29kaW5nIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZmF0YWwiLCJkZWNvZGUiLCJleCIsImlpIiwiY2hhckF0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ2IiwiYnl0ZUxlbmd0aCIsImFycjEiLCJhcnIyIiwiZGF0ZSIsIkRhdGUiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ1NlY29uZHMiLCJzZXR0bGVkIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGF0YSIsInJlYXNvbiIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIk1hcCIsInJlcGxhY2VBbGwiLCJfIiwibm9ybWFsaXplIiwiZ2V0IiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImJ1ZiIsImdldFJhbmRvbVZhbHVlcyIsImZsb29yIiwicmFuZG9tIiwiX193X3BkZmpzX3JlcXVpcmVfXyIsIlJlbmRlclRhc2siLCJQREZXb3JrZXJVdGlsIiwiUERGV29ya2VyIiwiUERGUGFnZVByb3h5IiwiUERGRG9jdW1lbnRQcm94eSIsIlBERkRvY3VtZW50TG9hZGluZ1Rhc2siLCJQREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJMb29wYmFja1BvcnQiLCJEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJEZWZhdWx0RmlsdGVyRmFjdG9yeSIsIkRlZmF1bHRDYW52YXNGYWN0b3J5IiwiRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5IiwiX2Rpc3BsYXlTdmciLCJTVkdHcmFwaGljcyIsImJ1aWxkIiwiZ2V0RG9jdW1lbnQiLCJ2ZXJzaW9uIiwiX3V0aWwiLCJfYW5ub3RhdGlvbl9zdG9yYWdlIiwiX2Rpc3BsYXlfdXRpbHMiLCJfZm9udF9sb2FkZXIiLCJfZGlzcGxheU5vZGVfdXRpbHMiLCJfY2FudmFzIiwiX3dvcmtlcl9vcHRpb25zIiwiX21lc3NhZ2VfaGFuZGxlciIsIl9tZXRhZGF0YSIsIl9vcHRpb25hbF9jb250ZW50X2NvbmZpZyIsIl90cmFuc3BvcnRfc3RyZWFtIiwiX2Rpc3BsYXlGZXRjaF9zdHJlYW0iLCJfZGlzcGxheU5ldHdvcmsiLCJfZGlzcGxheU5vZGVfc3RyZWFtIiwiX3hmYV90ZXh0IiwiREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFIiwiUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUIiwiREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQiLCJOb2RlQ2FudmFzRmFjdG9yeSIsIkRPTUNhbnZhc0ZhY3RvcnkiLCJOb2RlQ01hcFJlYWRlckZhY3RvcnkiLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsIk5vZGVGaWx0ZXJGYWN0b3J5IiwiRE9NRmlsdGVyRmFjdG9yeSIsIk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsIkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwic3JjIiwicmFuZ2UiLCJ0YXNrIiwiZG9jSWQiLCJnZXRVcmxQcm9wIiwiZ2V0RGF0YVByb3AiLCJodHRwSGVhZGVycyIsIndpdGhDcmVkZW50aWFscyIsInBhc3N3b3JkIiwicmFuZ2VUcmFuc3BvcnQiLCJyYW5nZUNodW5rU2l6ZSIsIndvcmtlciIsImRvY0Jhc2VVcmwiLCJpc0RhdGFTY2hlbWUiLCJjTWFwVXJsIiwiY01hcFBhY2tlZCIsIkNNYXBSZWFkZXJGYWN0b3J5Iiwic3RhbmRhcmRGb250RGF0YVVybCIsIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiaWdub3JlRXJyb3JzIiwic3RvcEF0RXJyb3JzIiwibWF4SW1hZ2VTaXplIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJkaXNhYmxlRm9udEZhY2UiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiZW5hYmxlWGZhIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiZGlzYWJsZVJhbmdlIiwiZGlzYWJsZVN0cmVhbSIsImRpc2FibGVBdXRvRmV0Y2giLCJwZGZCdWciLCJOYU4iLCJ1c2VTeXN0ZW1Gb250cyIsInVzZVdvcmtlckZldGNoIiwiaXNWYWxpZEZldGNoVXJsIiwiYmFzZVVSSSIsImNhbnZhc0ZhY3RvcnkiLCJmaWx0ZXJGYWN0b3J5Iiwic3R5bGVFbGVtZW50IiwidHJhbnNwb3J0RmFjdG9yeSIsImNNYXBSZWFkZXJGYWN0b3J5IiwiaXNDb21wcmVzc2VkIiwic3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ3b3JrZXJQYXJhbXMiLCJwb3J0IiwiR2xvYmFsV29ya2VyT3B0aW9ucyIsIndvcmtlclBvcnQiLCJmcm9tUG9ydCIsIl93b3JrZXIiLCJmZXRjaERvY1BhcmFtcyIsImFwaVZlcnNpb24iLCJldmFsdWF0b3JPcHRpb25zIiwidHJhbnNwb3J0UGFyYW1zIiwidGhlbiIsImRlc3Ryb3llZCIsIndvcmtlcklkUHJvbWlzZSIsIl9mZXRjaERvY3VtZW50IiwibmV0d29ya1N0cmVhbVByb21pc2UiLCJuZXR3b3JrU3RyZWFtIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbSIsImluaXRpYWxEYXRhIiwicHJvZ3Jlc3NpdmVEb25lIiwiY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJjcmVhdGVQREZOZXR3b3JrU3RyZWFtIiwicGFyYW1zIiwiUERGTm9kZVN0cmVhbSIsIlBERkZldGNoU3RyZWFtIiwiUERGTmV0d29ya1N0cmVhbSIsImFsbCIsIndvcmtlcklkIiwibWVzc2FnZUhhbmRsZXIiLCJNZXNzYWdlSGFuZGxlciIsInRyYW5zcG9ydCIsIldvcmtlclRyYW5zcG9ydCIsIl90cmFuc3BvcnQiLCJzZW5kIiwiY2F0Y2giLCJfY2FwYWJpbGl0eSIsInNvdXJjZSIsInNlbmRXaXRoUHJvbWlzZSIsInZhbCIsImhyZWYiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIkJ1ZmZlciIsImlzTmFOIiwib25QYXNzd29yZCIsIm9uUHJvZ3Jlc3MiLCJkZXN0cm95IiwiX3BlbmRpbmdEZXN0cm95IiwiX3JhbmdlTGlzdGVuZXJzIiwiX3Byb2dyZXNzTGlzdGVuZXJzIiwiX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyIsIl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMiLCJfcmVhZHlDYXBhYmlsaXR5IiwiYWRkUmFuZ2VMaXN0ZW5lciIsImxpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NMaXN0ZW5lciIsImFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIiLCJvbkRhdGFSYW5nZSIsImJlZ2luIiwib25EYXRhUHJvZ3Jlc3MiLCJsb2FkZWQiLCJ0b3RhbCIsIm9uRGF0YVByb2dyZXNzaXZlUmVhZCIsIm9uRGF0YVByb2dyZXNzaXZlRG9uZSIsInRyYW5zcG9ydFJlYWR5IiwicmVxdWVzdERhdGFSYW5nZSIsImVuZCIsImFib3J0IiwicGRmSW5mbyIsIl9wZGZJbmZvIiwiZGVwcmVjYXRlZCIsImdldEpTQWN0aW9ucyIsImpzIiwianNBcnIiLCJhbm5vdGF0aW9uU3RvcmFnZSIsIm51bVBhZ2VzIiwiZmluZ2VycHJpbnRzIiwiaXNQdXJlWGZhIiwiX2h0bWxGb3JYZmEiLCJhbGxYZmFIdG1sIiwiZ2V0UGFnZSIsInBhZ2VOdW1iZXIiLCJnZXRQYWdlSW5kZXgiLCJyZWYiLCJnZXREZXN0aW5hdGlvbnMiLCJnZXREZXN0aW5hdGlvbiIsImlkIiwiZ2V0UGFnZUxhYmVscyIsImdldFBhZ2VMYXlvdXQiLCJnZXRQYWdlTW9kZSIsImdldFZpZXdlclByZWZlcmVuY2VzIiwiZ2V0T3BlbkFjdGlvbiIsImdldEF0dGFjaG1lbnRzIiwiZ2V0RG9jSlNBY3Rpb25zIiwiZ2V0T3V0bGluZSIsImdldE9wdGlvbmFsQ29udGVudENvbmZpZyIsImdldFBlcm1pc3Npb25zIiwiZ2V0TWV0YWRhdGEiLCJnZXRNYXJrSW5mbyIsImdldERhdGEiLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5IiwiY2xlYW51cCIsImtlZXBMb2FkZWRGb250cyIsInN0YXJ0Q2xlYW51cCIsImxvYWRpbmdUYXNrIiwibG9hZGluZ1BhcmFtcyIsImdldEZpZWxkT2JqZWN0cyIsImhhc0pTQWN0aW9ucyIsImdldENhbGN1bGF0aW9uT3JkZXJJZHMiLCJkZWxheWVkQ2xlYW51cFRpbWVvdXQiLCJwZW5kaW5nQ2xlYW51cCIsInBhZ2VJbmRleCIsInBhZ2VJbmZvIiwiX3BhZ2VJbmRleCIsIl9wYWdlSW5mbyIsIl9zdGF0cyIsIlN0YXRUaW1lciIsIl9wZGZCdWciLCJjb21tb25PYmpzIiwib2JqcyIsIlBERk9iamVjdHMiLCJfbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIiLCJfaW50ZW50U3RhdGVzIiwicm90YXRlIiwidXNlclVuaXQiLCJ2aWV3IiwiZ2V0Vmlld3BvcnQiLCJzY2FsZSIsInJvdGF0aW9uIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJkb250RmxpcCIsIlBhZ2VWaWV3cG9ydCIsInZpZXdCb3giLCJnZXRBbm5vdGF0aW9ucyIsImludGVudCIsImludGVudEFyZ3MiLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJyZW5kZXJpbmdJbnRlbnQiLCJnZXRQYWdlSlNBY3Rpb25zIiwiZ2V0WGZhIiwiY2hpbGRyZW4iLCJyZW5kZXIiLCJjYW52YXNDb250ZXh0Iiwidmlld3BvcnQiLCJhbm5vdGF0aW9uTW9kZSIsImJhY2tncm91bmQiLCJvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIiwiYW5ub3RhdGlvbkNhbnZhc01hcCIsInBhZ2VDb2xvcnMiLCJwcmludEFubm90YXRpb25TdG9yYWdlIiwidGltZSIsImFib3J0RGVsYXllZENsZWFudXAiLCJpbnRlbnRTdGF0ZSIsImNhY2hlS2V5Iiwic2V0Iiwic3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImludGVudFByaW50IiwiZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSIsIm9wZXJhdG9yTGlzdCIsImZuQXJyYXkiLCJhcmdzQXJyYXkiLCJsYXN0Q2h1bmsiLCJzZXBhcmF0ZUFubm90cyIsIl9wdW1wT3BlcmF0b3JMaXN0IiwiY29tcGxldGUiLCJlcnJvciIsInJlbmRlclRhc2tzIiwiZGVsZXRlIiwiaW50ZXJuYWxSZW5kZXJUYXNrIiwidHJ5Q2xlYW51cCIsImNhcGFiaWxpdHkiLCJfYWJvcnRPcGVyYXRvckxpc3QiLCJ0aW1lRW5kIiwiSW50ZXJuYWxSZW5kZXJUYXNrIiwiY2FsbGJhY2siLCJ1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJTZXQiLCJhZGQiLCJyZW5kZXJUYXNrIiwidHJhbnNwYXJlbmN5Iiwib3B0aW9uYWxDb250ZW50Q29uZmlnIiwiaW5pdGlhbGl6ZUdyYXBoaWNzIiwib3BlcmF0b3JMaXN0Q2hhbmdlZCIsImdldE9wZXJhdG9yTGlzdCIsIm9wTGlzdFJlYWRDYXBhYmlsaXR5Iiwib3BMaXN0VGFzayIsInN0cmVhbVRleHRDb250ZW50IiwiaW5jbHVkZU1hcmtlZENvbnRlbnQiLCJkaXNhYmxlTm9ybWFsaXphdGlvbiIsIlRFWFRfQ09OVEVOVF9DSFVOS19TSVpFIiwic2VuZFdpdGhTdHJlYW0iLCJoaWdoV2F0ZXJNYXJrIiwic2l6ZSIsInRleHRDb250ZW50IiwiaXRlbXMiLCJnZXRUZXh0Q29udGVudCIsInhmYSIsIlhmYVRleHQiLCJyZWFkYWJsZVN0cmVhbSIsInB1bXAiLCJyZWFkZXIiLCJyZWFkIiwiZG9uZSIsImFzc2lnbiIsInN0eWxlcyIsImdldFJlYWRlciIsImdldFN0cnVjdFRyZWUiLCJfZGVzdHJveSIsIndhaXRPbiIsInZhbHVlcyIsImZvcmNlIiwiY29tcGxldGVkIiwiY2FuY2VsIiwiY2xlYXIiLCJyZXNldFN0YXRzIiwic3VjY2VzcyIsImRlbGF5ZWQiLCJzZXRUaW1lb3V0IiwiX3N0YXJ0UmVuZGVyUGFnZSIsIl9yZW5kZXJQYWdlQ2h1bmsiLCJvcGVyYXRvckxpc3RDaHVuayIsImFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlIiwidHJhbnNmZXJzIiwic3RyZWFtUmVhZGVyIiwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIiwiZGVsYXkiLCJleHRyYURlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsInN0YXRzIiwibGlzdGVuZXJzIiwiZGVmZXJyZWQiLCJwb3N0TWVzc2FnZSIsInRyYW5zZmVyIiwiZXZlbnQiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJjYWxsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0ZXJtaW5hdGUiLCJpc1dvcmtlckRpc2FibGVkIiwiZmFsbGJhY2tXb3JrZXJTcmMiLCJmYWtlV29ya2VySWQiLCJyZXF1aXJlIiwicGRmanNGaWxlUGF0aCIsImN1cnJlbnRTY3JpcHQiLCJyZXBsYWNlIiwiaXNTYW1lT3JpZ2luIiwib3RoZXJVcmwiLCJiYXNlIiwib3JpZ2luIiwib3RoZXIiLCJjcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ3b3JrZXJQb3J0cyIsIl9wb3J0IiwiX3dlYldvcmtlciIsIl9tZXNzYWdlSGFuZGxlciIsImhhcyIsIldlYWtNYXAiLCJfaW5pdGlhbGl6ZUZyb21Qb3J0IiwiX2luaXRpYWxpemUiLCJvbiIsIl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIiLCJ3b3JrZXJTcmMiLCJXb3JrZXIiLCJ0ZXJtaW5hdGVFYXJseSIsIm9uV29ya2VyRXJyb3IiLCJfc2V0dXBGYWtlV29ya2VyIiwic2VuZFRlc3QiLCJ0ZXN0T2JqIiwiX3NldHVwRmFrZVdvcmtlckdsb2JhbCIsIldvcmtlck1lc3NhZ2VIYW5kbGVyIiwid29ya2VySGFuZGxlciIsInNldHVwIiwiY2FjaGVkUG9ydCIsInBkZmpzV29ya2VyIiwibG9hZGVyIiwibWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyIiwiZXZhbCIsImxvYWRTY3JpcHQiLCJtZXRob2RQcm9taXNlcyIsInBhZ2VDYWNoZSIsInBhZ2VQcm9taXNlcyIsInBhc3N3b3JkQ2FwYWJpbGl0eSIsImZvbnRMb2FkZXIiLCJGb250TG9hZGVyIiwiX3BhcmFtcyIsImRlc3Ryb3lDYXBhYmlsaXR5IiwiX25ldHdvcmtTdHJlYW0iLCJfZnVsbFJlYWRlciIsIl9sYXN0UHJvZ3Jlc3MiLCJzZXR1cE1lc3NhZ2VIYW5kbGVyIiwiY2FjaGVTaW1wbGVNZXRob2QiLCJjYWNoZWRQcm9taXNlIiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJpc09wTGlzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSIsInNlcmlhbGl6YWJsZSIsImhhc2giLCJwYWdlIiwiaGFzT3duUHJvcGVydHkiLCJyZXNldE1vZGlmaWVkIiwidGVybWluYXRlZCIsImNhbmNlbEFsbFJlcXVlc3RzIiwic2luayIsImdldEZ1bGxSZWFkZXIiLCJldnQiLCJvblB1bGwiLCJjbG9zZSIsIkFycmF5QnVmZmVyIiwiZW5xdWV1ZSIsIm9uQ2FuY2VsIiwicmVhZHkiLCJyZWFkeVJlYXNvbiIsImhlYWRlcnNDYXBhYmlsaXR5IiwiZnVsbFJlYWRlciIsImhlYWRlcnNSZWFkeSIsImlzU3RyZWFtaW5nU3VwcG9ydGVkIiwiaXNSYW5nZVN1cHBvcnRlZCIsImNvbnRlbnRMZW5ndGgiLCJyYW5nZVJlYWRlciIsImdldFJhbmdlUmVhZGVyIiwiX251bVBhZ2VzIiwiaHRtbEZvclhmYSIsImV4Y2VwdGlvbiIsInVwZGF0ZVBhc3N3b3JkIiwiZXhwb3J0ZWREYXRhIiwiZXhwb3J0ZWRFcnJvciIsImluc3BlY3RGb250IiwiRm9udEluc3BlY3RvciIsImVuYWJsZWQiLCJmb250IiwiZm9udEFkZGVkIiwiRm9udEZhY2VPYmplY3QiLCJiaW5kIiwiZmluYWxseSIsImltYWdlRGF0YSIsInBhZ2VQcm94eSIsImJpdG1hcCIsIndpZHRoIiwiaGVpZ2h0IiwiZmV0Y2giLCJmaWxlbmFtZSIsIm51bSIsImdlbiIsInJlc3VsdHMiLCJPcHRpb25hbENvbnRlbnRDb25maWciLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwiY2xlYW51cFN1Y2Nlc3NmdWwiLCJlbnN1cmVPYmoiLCJvYmpJZCIsIm9uQ29udGludWUiLCJmb3JtIiwiY2FudmFzIiwiY2FudmFzSW5Vc2UiLCJXZWFrU2V0Iiwib3BlcmF0b3JMaXN0SWR4IiwicnVubmluZyIsImdyYXBoaWNzUmVhZHlDYWxsYmFjayIsImdyYXBoaWNzUmVhZHkiLCJfdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsbGVkIiwiX2NhbmNlbEJvdW5kIiwiX2NvbnRpbnVlQm91bmQiLCJfY29udGludWUiLCJfc2NoZWR1bGVOZXh0Qm91bmQiLCJfc2NoZWR1bGVOZXh0IiwiX25leHRCb3VuZCIsIl9uZXh0IiwiU3RlcHBlck1hbmFnZXIiLCJzdGVwcGVyIiwiaW5pdCIsIm5leHRCcmVha1BvaW50IiwiZ2V0TmV4dEJyZWFrUG9pbnQiLCJnZngiLCJDYW52YXNHcmFwaGljcyIsImJlZ2luRHJhd2luZyIsImVuZERyYXdpbmciLCJ1cGRhdGVPcGVyYXRvckxpc3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJleGVjdXRlT3BlcmF0b3JMaXN0IiwiX2VkaXRvciIsIl9tdXJtdXJoYXNoIiwiZnJlZXplIiwibW9kaWZpZWQiLCJzdG9yYWdlIiwib25TZXRNb2RpZmllZCIsIm9uUmVzZXRNb2RpZmllZCIsIm9uQW5ub3RhdGlvbkVkaXRvciIsImdldFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0UmF3VmFsdWUiLCJyZW1vdmUiLCJBbm5vdGF0aW9uRWRpdG9yIiwic2V0VmFsdWUiLCJlbnRyeSIsImVudHJpZXMiLCJzZXRNb2RpZmllZCIsIl90eXBlIiwiZ2V0QWxsIiwic2V0QWxsIiwicHJpbnQiLCJNdXJtdXJIYXNoM182NCIsImNvbnRleHQiLCJoYXNCaXRtYXAiLCJzZXJpYWxpemVkIiwic2VyaWFsaXplIiwidXBkYXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhleGRpZ2VzdCIsInBhcmVudCIsImNsb25lIiwiX3Rvb2xzIiwiYWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0Iiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJib3VuZEZvY3VzaW4iLCJib3VuZEZvY3Vzb3V0IiwiaGFzQmVlbkNsaWNrZWQiLCJpc0VkaXRpbmciLCJpc0luRWRpdE1vZGUiLCJpc0RyYWdnYWJsZSIsInpJbmRleCIsIl9ib3JkZXJMaW5lV2lkdGgiLCJfY29sb3JNYW5hZ2VyIiwiQ29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIlNNQUxMX0VESVRPUl9TSVpFIiwicGFyYW1ldGVycyIsImZvY3VzaW4iLCJmb2N1c291dCIsIl9pbml0aWFsT3B0aW9ucyIsIl91aU1hbmFnZXIiLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiX2wxMG5Qcm9taXNlIiwiZGl2IiwidWlNYW5hZ2VyIiwiYW5ub3RhdGlvbkVsZW1lbnRJZCIsIl93aWxsS2VlcEFzcGVjdFJhdGlvIiwiaXNDZW50ZXJlZCIsIl9zdHJ1Y3RUcmVlUGFyZW50SWQiLCJyYXdEaW1zIiwicGFnZVdpZHRoIiwicGFnZUhlaWdodCIsInBhZ2VYIiwicGFnZVkiLCJwYWdlUm90YXRpb24iLCJ2aWV3UGFyYW1ldGVycyIsInBhZ2VEaW1lbnNpb25zIiwicGFnZVRyYW5zbGF0aW9uIiwicGFyZW50RGltZW5zaW9ucyIsIngiLCJ5IiwiaXNBdHRhY2hlZFRvRE9NIiwiZGVsZXRlZCIsImVkaXRvclR5cGUiLCJnZXRQcm90b3R5cGVPZiIsIl9kZWZhdWx0TGluZUNvbG9yIiwiZ2V0SGV4Q29kZSIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiZWRpdG9yIiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJnZXROZXh0SWQiLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwiaW5pdGlhbGl6ZSIsImwxMG4iLCJzdHJpbmdzIiwic3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnRFbGVtZW50IiwicGFyc2VGbG9hdCIsImdldFByb3BlcnR5VmFsdWUiLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwiX3ZhbHVlIiwiZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSIsImlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyIsIm1pbWUiLCJwYXN0ZSIsIml0ZW0iLCJwcm9wZXJ0aWVzVG9VcGRhdGUiLCJfaXNEcmFnZ2FibGUiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJjZW50ZXIiLCJwYXJlbnRSb3RhdGlvbiIsImZpeEFuZFNldFBvc2l0aW9uIiwiYWRkQ29tbWFuZHMiLCJjdXJyZW50TGF5ZXIiLCJzZXRJbkJhY2tncm91bmQiLCJzZXRJbkZvcmVncm91bmQiLCJzZXRQYXJlbnQiLCJzZXRTZWxlY3RlZCIsInRhcmdldCIsInJlbGF0ZWRUYXJnZXQiLCJjbG9zZXN0IiwicHJldmVudERlZmF1bHQiLCJpc011bHRpcGxlU2VsZWN0aW9uIiwiY29tbWl0T3JSZW1vdmUiLCJpc0VtcHR5IiwiY29tbWl0Iiwic2V0QXQiLCJ0eCIsInR5Iiwic2NyZWVuVG9QYWdlVHJhbnNsYXRpb24iLCJ0cmFuc2xhdGUiLCJ0cmFuc2xhdGVJblBhZ2UiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiZHJhZyIsInBhcmVudFdpZHRoIiwicGFyZW50SGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZmluZE5ld1BhcmVudCIsImJ4IiwiYnkiLCJnZXRCYXNlVHJhbnNsYXRpb24iLCJsZWZ0IiwidG9GaXhlZCIsInRvcCIsIm1vdmVJbkRPTSIsInJvdGF0ZVBvaW50IiwiYW5nbGUiLCJwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbiIsImdldFJvdGF0aW9uTWF0cml4IiwicGFyZW50U2NhbGUiLCJyZWFsU2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInJvdW5kIiwic2V0RGltcyIsImZpeERpbXMiLCJ3aWR0aFBlcmNlbnQiLCJlbmRzV2l0aCIsImhlaWdodFBlcmNlbnQiLCJnZXRJbml0aWFsVHJhbnNsYXRpb24iLCJjcmVhdGVSZXNpemVycyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc2VzIiwiYXBwZW5kIiwicmVzaXplclBvaW50ZXJkb3duIiwibm9Db250ZXh0TWVudSIsInByZXBlbmQiLCJidXR0b24iLCJjdHJsS2V5IiwiYm91bmRSZXNpemVyUG9pbnRlcm1vdmUiLCJyZXNpemVyUG9pbnRlcm1vdmUiLCJzYXZlZERyYWdnYWJsZSIsInBvaW50ZXJNb3ZlT3B0aW9ucyIsInBhc3NpdmUiLCJjYXB0dXJlIiwic2F2ZWRYIiwic2F2ZWRZIiwic2F2ZWRXaWR0aCIsInNhdmVkSGVpZ2h0Iiwic2F2ZWRQYXJlbnRDdXJzb3IiLCJjdXJzb3IiLCJzYXZlZEN1cnNvciIsInBvaW50ZXJVcENhbGxiYWNrIiwibmV3WCIsIm5ld1kiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImNtZCIsInVuZG8iLCJtdXN0RXhlYyIsIm1pbldpZHRoIiwiTUlOX1NJWkUiLCJtaW5IZWlnaHQiLCJyb3RhdGlvbk1hdHJpeCIsInRyYW5zZiIsImludlJvdGF0aW9uTWF0cml4IiwiaW52VHJhbnNmIiwiZ2V0UG9pbnQiLCJnZXRPcHBvc2l0ZSIsImlzRGlhZ29uYWwiLCJpc0hvcml6b250YWwiLCJ3IiwiaCIsInBvaW50Iiwib3Bwb3NpdGVQb2ludCIsInRyYW5zZk9wcG9zaXRlUG9pbnQiLCJvcHBvc2l0ZVgiLCJvcHBvc2l0ZVkiLCJyYXRpb1giLCJyYXRpb1kiLCJkZWx0YVgiLCJkZWx0YVkiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJvbGREaWFnIiwiaHlwb3QiLCJhZGRBbHRUZXh0QnV0dG9uIiwiY2xhc3NOYW1lIiwic2V0QXR0cmlidXRlIiwidGFiSW5kZXgiLCJzdG9wUHJvcGFnYXRpb24iLCJlZGl0QWx0VGV4dCIsInNldEFsdFRleHRCdXR0b25TdGF0ZSIsIlBFUkNFTlQiLCJ0b29sdGlwIiwiREVMQVlfVE9fU0hPV19UT09MVElQIiwiX2V2ZW50QnVzIiwiZGlzcGF0Y2giLCJzdWJ0eXBlIiwiYWN0aW9uIiwiaW5uZXJUZXh0IiwicGFyZW50Tm9kZSIsImdldENsaWVudERpbWVuc2lvbnMiLCJhbHRUZXh0RGF0YSIsImRlY29yYXRpdmUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsImJpbmRFdmVudHMiLCJwb2ludGVyZG93biIsInNldFVwRHJhZ1Nlc3Npb24iLCJpc1NlbGVjdGVkIiwicG9pbnRlck1vdmVDYWxsYmFjayIsImUiLCJkcmFnU2VsZWN0ZWRFZGl0b3JzIiwiZW5kRHJhZ1Nlc3Npb24iLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJ0b2dnbGVTZWxlY3RlZCIsIm1vdmVFZGl0b3JJbkRPTSIsIl9zZXRQYXJlbnRBbmRQb3NpdGlvbiIsImNoYW5nZVBhcmVudCIsImdldFJlY3QiLCJzaGlmdFgiLCJzaGlmdFkiLCJnZXRSZWN0SW5DdXJyZW50Q29vcmRzIiwib25jZUFkZGVkIiwiZW5hYmxlRWRpdE1vZGUiLCJkaXNhYmxlRWRpdE1vZGUiLCJzaG91bGRHZXRLZXlib2FyZEV2ZW50cyIsIm5lZWRzVG9CZVJlYnVpbHQiLCJyZWJ1aWxkIiwiaXNGb3JDb3B5aW5nIiwiZGVzZXJpYWxpemUiLCJyZW1vdmVFZGl0b3IiLCJpc1Jlc2l6YWJsZSIsIm1ha2VSZXNpemFibGUiLCJzZWxlY3QiLCJ1bnNlbGVjdCIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImZvY3VzIiwidXBkYXRlUGFyYW1zIiwiZGlzYWJsZUVkaXRpbmciLCJoaWRkZW4iLCJlbmFibGVFZGl0aW5nIiwiZW50ZXJJbkVkaXRNb2RlIiwiY29udGVudERpdiIsInNldEFjdGl2ZUVkaXRvciIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJLZXlib2FyZE1hbmFnZXIiLCJDb21tYW5kTWFuYWdlciIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJvcGFjaXR5VG9IZXgiLCJlbGVtZW50IiwibmFtZXMiLCJvcGFjaXR5IiwiSWRNYW5hZ2VyIiwiZ2V0SWQiLCJJbWFnZU1hbmFnZXIiLCJiYXNlSWQiLCJjYWNoZSIsIl9pc1NWR0ZpdHRpbmdDYW52YXMiLCJzdmciLCJjdHgiLCJnZXRDb250ZXh0IiwiaW1hZ2UiLCJJbWFnZSIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsInJhd0RhdGEiLCJyZWZDb3VudGVyIiwiaXNTdmciLCJyZXNwb25zZSIsIm9rIiwic3RhdHVzVGV4dCIsImJsb2IiLCJmaWxlIiwibXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwiaW1hZ2VFbGVtZW50IiwiaW1hZ2VQcm9taXNlIiwib25sb2FkIiwic3ZnVXJsIiwicmVzdWx0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJjcmVhdGVJbWFnZUJpdG1hcCIsImdldEZyb21GaWxlIiwibGFzdE1vZGlmaWVkIiwiZ2V0RnJvbVVybCIsImdldEZyb21JZCIsImdldFN2Z1VybCIsImRlbGV0ZUlkIiwiaXNWYWxpZElkIiwiY29tbWFuZHMiLCJsb2NrZWQiLCJtYXhTaXplIiwicG9zaXRpb24iLCJvdmVyd3JpdGVJZlNhbWVUeXBlIiwia2VlcFVuZG8iLCJuZXh0Iiwic3BsaWNlIiwicmVkbyIsImhhc1NvbWV0aGluZ1RvVW5kbyIsImhhc1NvbWV0aGluZ1RvUmVkbyIsImNhbGxiYWNrcyIsImFsbEtleXMiLCJpc01hY0tleSIsInNwbGl0IiwiYXQiLCJhbHRLZXkiLCJleGVjIiwic2VsZiIsImJ1YmJsZXMiLCJhcmdzIiwiY2hlY2tlciIsIl9jb2xvcnNNYXBwaW5nIiwiX2NvbG9ycyIsImNvbG9ycyIsImdldENvbG9yVmFsdWVzIiwiY29udmVydCIsImNvbG9yIiwicmdiIiwiZ2V0UkdCIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJSR0IiLCJldmVyeSIsImFjdGl2ZUVkaXRvciIsImFsbEVkaXRvcnMiLCJhbGxMYXllcnMiLCJhbHRUZXh0TWFuYWdlciIsImNvbW1hbmRNYW5hZ2VyIiwiY3VycmVudFBhZ2VJbmRleCIsImRlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMiLCJkcmFnZ2luZ0VkaXRvcnMiLCJlZGl0b3JUeXBlcyIsImVkaXRvcnNUb1Jlc2NhbGUiLCJpZE1hbmFnZXIiLCJpc0VuYWJsZWQiLCJpc1dhaXRpbmciLCJsYXN0QWN0aXZlRWxlbWVudCIsIm1vZGUiLCJzZWxlY3RlZEVkaXRvcnMiLCJib3VuZEJsdXIiLCJib3VuZEZvY3VzIiwiYm91bmRDb3B5IiwiYm91bmRDdXQiLCJib3VuZFBhc3RlIiwiYm91bmRLZXlkb3duIiwiYm91bmRPbkVkaXRpbmdBY3Rpb24iLCJib3VuZE9uUGFnZUNoYW5naW5nIiwiYm91bmRPblNjYWxlQ2hhbmdpbmciLCJib3VuZE9uUm90YXRpb25DaGFuZ2luZyIsInByZXZpb3VzU3RhdGVzIiwidHJhbnNsYXRpb24iLCJ0cmFuc2xhdGlvblRpbWVvdXRJZCIsImNvbnRhaW5lciIsInZpZXdlciIsIlRSQU5TTEFURV9TTUFMTCIsIlRSQU5TTEFURV9CSUciLCJfa2V5Ym9hcmRNYW5hZ2VyIiwicHJvdG8iLCJhcnJvd0NoZWNrZXIiLCJoYXNTb21ldGhpbmdUb0NvbnRyb2wiLCJzbWFsbCIsImJpZyIsInNlbGVjdEFsbCIsInVuc2VsZWN0QWxsIiwidHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzIiwiZXZlbnRCdXMiLCJwZGZEb2N1bWVudCIsImJsdXIiLCJjb3B5IiwiY3V0Iiwia2V5ZG93biIsIm9uRWRpdGluZ0FjdGlvbiIsIm9uUGFnZUNoYW5naW5nIiwib25TY2FsZUNoYW5naW5nIiwib25Sb3RhdGlvbkNoYW5naW5nIiwiaGFzU2VsZWN0ZWRFZGl0b3IiLCJfb24iLCJQaXhlbHNQZXJJbmNoIiwiUERGX1RPX0NTU19VTklUUyIsInJlbW92ZUtleWJvYXJkTWFuYWdlciIsInJlbW92ZUZvY3VzTWFuYWdlciIsIl9vZmYiLCJsYXllciIsImhjbUZpbHRlciIsImFkZEhDTUZpbHRlciIsImZvcmVncm91bmQiLCJkaXJlY3Rpb24iLCJmb2N1c01haW5Db250YWluZXIiLCJmaW5kUGFyZW50IiwibGF5ZXJYIiwibGF5ZXJZIiwiZGlzYWJsZVVzZXJTZWxlY3QiLCJhZGRTaG91bGRSZXNjYWxlIiwicmVtb3ZlU2hvdWxkUmVzY2FsZSIsInBhZ2VzUm90YXRpb24iLCJhZGRGb2N1c01hbmFnZXIiLCJoYXNTZWxlY3Rpb24iLCJsYXN0RWRpdG9yIiwib25jZSIsImFkZEtleWJvYXJkTWFuYWdlciIsImFkZENvcHlQYXN0ZUxpc3RlbmVycyIsInJlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycyIsImFkZEVkaXRMaXN0ZW5lcnMiLCJyZW1vdmVFZGl0TGlzdGVuZXJzIiwiZWRpdG9ycyIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwicGFyc2UiLCJpc0FycmF5IiwibmV3RWRpdG9ycyIsImRlc2VyaWFsaXplZEVkaXRvciIsImFkZEVkaXRvclRvTGF5ZXIiLCJzZWxlY3RFZGl0b3JzIiwiZ2V0QWN0aXZlIiwiZGlzcGF0Y2hVcGRhdGVTdGF0ZXMiLCJoYXNDaGFuZ2VkIiwic29tZSIsImRpc3BhdGNoVXBkYXRlVUkiLCJzZXRFZGl0aW5nU3RhdGUiLCJyZWdpc3RlckVkaXRvclR5cGVzIiwidHlwZXMiLCJnZXRMYXllciIsImFkZExheWVyIiwiZW5hYmxlIiwiZGlzYWJsZSIsInJlbW92ZUxheWVyIiwidXBkYXRlTW9kZSIsImVkaXRJZCIsImRpc2FibGVBbGwiLCJlbmFibGVBbGwiLCJ1cGRhdGVUb29sYmFyIiwiYWRkTmV3RWRpdG9yIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJnZXRFZGl0b3JzIiwiZ2V0RWRpdG9yIiwiYWRkRWRpdG9yIiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJyZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQiLCJhZGRPclJlYnVpbGQiLCJlZCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwic2F2ZWRQYWdlSW5kZXgiLCJuZXdQYWdlSW5kZXgiLCJtdXN0QmVBZGRlZEluVW5kb1N0YWNrIiwibW92ZSIsImlzQWN0aXZlIiwiZ2V0TW9kZSIsImltYWdlTWFuYWdlciIsIlBERkRhdGVTdHJpbmciLCJET01TVkdGYWN0b3J5IiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlIiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwiaXNQZGZGaWxlIiwic2V0TGF5ZXJEaW1lbnNpb25zIiwiX2Jhc2VfZmFjdG9yeSIsIlNWR19OUyIsIlBERiIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiX2NhY2hlIiwiX2RlZnMiLCJoY21LZXkiLCJoY21VcmwiLCJoY21IaWdobGlnaHRGaWx0ZXIiLCJoY21IaWdobGlnaHRLZXkiLCJoY21IaWdobGlnaHRVcmwiLCJkZWZzIiwidmlzaWJpbGl0eSIsImNvbnRhaW4iLCJjcmVhdGVFbGVtZW50TlMiLCJib2R5IiwiYWRkRmlsdGVyIiwibWFwcyIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsIm1hcFIiLCJtYXBHIiwibWFwQiIsImJ1ZmZlclIiLCJidWZmZXJHIiwiYnVmZmVyQiIsImZpbHRlciIsImNyZWF0ZUZpbHRlciIsImFkZFRyYW5zZmVyTWFwQ29udmVyc2lvbiIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiZmdSR0IiLCJiZ1JHQiIsInRhYmxlIiwiYWRkR3JheUNvbnZlcnNpb24iLCJnZXRTdGVwcyIsInN0YXJ0IiwiYXJyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwibmV3RmdDb2xvciIsIm5ld0JnQ29sb3IiLCJmZ0dyYXkiLCJiZ0dyYXkiLCJuZXdGZ1JHQiIsIm5ld0JnUkdCIiwiZmciLCJiZyIsInN0ZXAiLCJuZXdTdGFydCIsIm5ld1N0ZXAiLCJwcmV2IiwiayIsImtlZXBIQ00iLCJmZUNvbG9yTWF0cml4IiwiYXBwZW5kRmVGdW5jIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZ1bmMiLCJmZUZ1bmMiLCJyVGFibGUiLCJnVGFibGUiLCJiVGFibGUiLCJCYXNlQ2FudmFzRmFjdG9yeSIsIl9kb2N1bWVudCIsIl9jcmVhdGVDYW52YXMiLCJmZXRjaERhdGEiLCJhc1R5cGVkQXJyYXkiLCJhcnJheUJ1ZmZlciIsInRleHQiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJyZXNwb25zZVRleHQiLCJCYXNlQ01hcFJlYWRlckZhY3RvcnkiLCJfZmV0Y2hEYXRhIiwiY29tcHJlc3Npb25UeXBlIiwiY01hcERhdGEiLCJCYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJCYXNlU1ZHRmFjdG9yeSIsIl9jcmVhdGVTVkciLCJjZW50ZXJYIiwiY2VudGVyWSIsInJvdGF0ZUEiLCJyb3RhdGVCIiwicm90YXRlQyIsInJvdGF0ZUQiLCJvZmZzZXRDYW52YXNYIiwib2Zmc2V0Q2FudmFzWSIsImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQiLCJjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZSIsInRvcExlZnQiLCJib3R0b21SaWdodCIsImNvbnZlcnRUb1BkZlBvaW50IiwidHJpbSIsInN1YnN0cmluZyIsInRvTG93ZXJDYXNlIiwidGVzdCIsIm9ubHlTdHJpcFBhdGgiLCJsYXN0SW5kZXhPZiIsImRlZmF1bHRGaWxlbmFtZSIsInJlVVJJIiwicmVGaWxlbmFtZSIsInNwbGl0VVJJIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJzdGFydGVkIiwibm93IiwidGltZXMiLCJvdXRCdWYiLCJsb25nZXN0IiwicGFkRW5kIiwicmVtb3ZlU2NyaXB0RWxlbWVudCIsInNjcmlwdCIsImhlYWQiLCJwZGZEYXRlU3RyaW5nUmVnZXgiLCJ0b0RhdGVPYmplY3QiLCJpbnB1dCIsIlJlZ0V4cCIsInllYXIiLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInVuaXZlcnNhbFRpbWVSZWxhdGlvbiIsIm9mZnNldEhvdXIiLCJvZmZzZXRNaW51dGUiLCJVVEMiLCJ4ZmFQYWdlIiwiYXR0cmlidXRlcyIsImNvbG9yUkdCIiwic3BhbiIsImNvbXB1dGVkQ29sb3IiLCJmIiwiZ2V0VHJhbnNmb3JtIiwiaW52ZXJ0U2VsZiIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwid2lkdGhTdHIiLCJoZWlnaHRTdHIiLCJyZXNldCIsImNhbnZhc0FuZENvbnRleHQiLCJza2lwRGltZW5zaW9ucyIsIlNFRUQiLCJNQVNLX0hJR0giLCJNQVNLX0xPVyIsInNlZWQiLCJoMSIsImgyIiwiYmxvY2tDb3VudHMiLCJ0YWlsTGVuZ3RoIiwiZGF0YVVpbnQzMiIsImsxIiwiazIiLCJDMSIsIkMyIiwiQzFfTE9XIiwiQzJfTE9XIiwic3lzdGVtRm9udHMiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJsb2FkZWROYW1lIiwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCIsImZvbnRGYWNlIiwiRm9udEZhY2UiLCJsb2FkIiwiYmFzZUZvbnROYW1lIiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsInN5c3RlbUZvbnRJbmZvIiwiY3JlYXRlTmF0aXZlRm9udEZhY2UiLCJmYW1pbHkiLCJjcmVhdGVGb250RmFjZVJ1bGUiLCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCIsIl9xdWV1ZUxvYWRpbmdDYWxsYmFjayIsIl9wcmVwYXJlRm9udExvYWRFdmVudCIsImhhc0ZvbnRzIiwic3VwcG9ydGVkIiwidXNlckFnZW50IiwiY29tcGxldGVSZXF1ZXN0Iiwib3RoZXJSZXF1ZXN0Iiwic2hpZnQiLCJfbG9hZFRlc3RGb250IiwidGVzdEZvbnQiLCJhdG9iIiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJzIiwiaW5zZXJ0IiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FsbGVkIiwiaXNGb250UmVhZHkiLCJmaWxsVGV4dCIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsImJ0b2EiLCJmb250RmFtaWx5IiwidHJhbnNsYXRlZERhdGEiLCJjb21waWxlZEdseXBocyIsIl9pbnNwZWN0Rm9udCIsImNzc0ZvbnRJbmZvIiwiY3NzIiwid2VpZ2h0IiwiZm9udFdlaWdodCIsIml0YWxpY0FuZ2xlIiwibWltZXR5cGUiLCJnZXRQYXRoR2VuZXJhdG9yIiwiY2hhcmFjdGVyIiwiY21kcyIsImpzQnVmIiwiY3VycmVudCIsImZzIiwicmVhZEZpbGUiLCJDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJfcGF0dGVybl9oZWxwZXIiLCJfaW1hZ2VfdXRpbHMiLCJNSU5fRk9OVF9TSVpFIiwiTUFYX0ZPTlRfU0laRSIsIk1BWF9HUk9VUF9TSVpFIiwiRVhFQ1VUSU9OX1RJTUUiLCJFWEVDVVRJT05fU1RFUFMiLCJNQVhfU0laRV9UT19DT01QSUxFIiwiRlVMTF9DSFVOS19IRUlHSFQiLCJtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyIsImRlc3RDdHgiLCJfcmVtb3ZlTWlycm9yaW5nIiwiX19vcmlnaW5hbFNhdmUiLCJfX29yaWdpbmFsUmVzdG9yZSIsIl9fb3JpZ2luYWxSb3RhdGUiLCJfX29yaWdpbmFsU2NhbGUiLCJfX29yaWdpbmFsVHJhbnNsYXRlIiwiX19vcmlnaW5hbFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0iLCJzZXRUcmFuc2Zvcm0iLCJfX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0iLCJyZXNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxDbGlwIiwiX19vcmlnaW5hbE1vdmVUbyIsIl9fb3JpZ2luYWxMaW5lVG8iLCJfX29yaWdpbmFsQmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJfX29yaWdpbmFsUmVjdCIsIl9fb3JpZ2luYWxDbG9zZVBhdGgiLCJfX29yaWdpbmFsQmVnaW5QYXRoIiwiYmVnaW5QYXRoIiwiY3R4U2F2ZSIsImN0eFJlc3RvcmUiLCJjdHhUcmFuc2xhdGUiLCJjdHhTY2FsZSIsImN0eFRyYW5zZm9ybSIsImN0eFNldFRyYW5zZm9ybSIsImN0eFJlc2V0VHJhbnNmb3JtIiwiY3R4Um90YXRlIiwiY3AxeCIsImNwMXkiLCJjcDJ4IiwiY3AyeSIsIkNhY2hlZENhbnZhc2VzIiwiZ2V0Q2FudmFzIiwiY2FudmFzRW50cnkiLCJkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMiLCJzcmNJbWciLCJzcmNYIiwic3JjWSIsInNyY1ciLCJzcmNIIiwiZGVzdFgiLCJkZXN0WSIsImRlc3RXIiwiZGVzdEgiLCJ0bFgiLCJyVGxYIiwidGxZIiwiclRsWSIsImJyWCIsInJXaWR0aCIsImJyWSIsInJIZWlnaHQiLCJzaWduIiwic2NhbGVYIiwic2NhbGVZIiwiY29tcGlsZVR5cGUzR2x5cGgiLCJpbWdEYXRhIiwiUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCIsIlBPSU5UX1RZUEVTIiwid2lkdGgxIiwicG9pbnRzIiwiajAiLCJsaW5lU2l6ZSIsInBvcyIsImVsZW0iLCJtYXNrIiwiY291bnQiLCJzdW0iLCJzdGVwcyIsIkludDMyQXJyYXkiLCJwYXRoIiwiUGF0aDJEIiwicDAiLCJwcCIsImRyYXdPdXRsaW5lIiwiQ2FudmFzRXh0cmFTdGF0ZSIsImFscGhhSXNTaGFwZSIsImZvbnRTaXplIiwiZm9udFNpemVTY2FsZSIsInRleHRNYXRyaXgiLCJ0ZXh0TWF0cml4U2NhbGUiLCJmb250TWF0cml4IiwibGVhZGluZyIsImxpbmVYIiwibGluZVkiLCJjaGFyU3BhY2luZyIsIndvcmRTcGFjaW5nIiwidGV4dEhTY2FsZSIsInRleHRSZW5kZXJpbmdNb2RlIiwidGV4dFJpc2UiLCJmaWxsQ29sb3IiLCJzdHJva2VDb2xvciIsInBhdHRlcm5GaWxsIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsInN0YXJ0TmV3UGF0aEFuZENsaXBCb3giLCJjbGlwQm94Iiwic2V0Q3VycmVudFBvaW50IiwidXBkYXRlUGF0aE1pbk1heCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJ1cGRhdGVSZWN0TWluTWF4IiwidXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgiLCJ1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgiLCJib3giLCJnZXRQYXRoQm91bmRpbmdCb3giLCJwYXRoVHlwZSIsIlBhdGhUeXBlIiwieFN0cm9rZVBhZCIsInlTdHJva2VQYWQiLCJ1cGRhdGVDbGlwRnJvbVBhdGgiLCJpc0VtcHR5Q2xpcCIsIkluZmluaXR5IiwiZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCIsInB1dEJpbmFyeUltYWdlRGF0YSIsIkltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsInBhcnRpYWxDaHVua0hlaWdodCIsImZ1bGxDaHVua3MiLCJ0b3RhbENodW5rcyIsImNodW5rSW1nRGF0YSIsImNyZWF0ZUltYWdlRGF0YSIsInNyY1BvcyIsImRlc3RQb3MiLCJkZXN0IiwidGhpc0NodW5rSGVpZ2h0IiwiZWxlbXNJblRoaXNDaHVuayIsImtpbmQiLCJzcmNMZW5ndGgiLCJkZXN0MzIiLCJkZXN0MzJEYXRhTGVuZ3RoIiwiZnVsbFNyY0RpZmYiLCJ3aGl0ZSIsImJsYWNrIiwic3JjRGlmZiIsImtFbmQiLCJrRW5kVW5yb2xsZWQiLCJzcmNCeXRlIiwicHV0QmluYXJ5SW1hZ2VNYXNrIiwiY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEiLCJub25CbGFja0NvbG9yIiwiY29weUN0eFN0YXRlIiwic291cmNlQ3R4IiwicHJvcGVydGllcyIsInByb3BlcnR5Iiwic2V0TGluZURhc2giLCJnZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwicmVzZXRDdHhUb0RlZmF1bHQiLCJzdHJva2VTdHlsZSIsImZpbGxTdHlsZSIsImZpbGxSdWxlIiwiZ2xvYmFsQWxwaGEiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiY29tcG9zZVNNYXNrQmFja2Ryb3AiLCJyMCIsImcwIiwiYjAiLCJhbHBoYSIsImFscGhhXyIsImNvbXBvc2VTTWFza0FscGhhIiwibWFza0RhdGEiLCJsYXllckRhdGEiLCJ0cmFuc2Zlck1hcCIsImNvbXBvc2VTTWFza0x1bWlub3NpdHkiLCJnZW5lcmljQ29tcG9zZVNNYXNrIiwibWFza0N0eCIsImxheWVyQ3R4IiwiYmFja2Ryb3AiLCJsYXllck9mZnNldFgiLCJsYXllck9mZnNldFkiLCJtYXNrT2Zmc2V0WCIsIm1hc2tPZmZzZXRZIiwiaGFzQmFja2Ryb3AiLCJjb21wb3NlRm4iLCJQSVhFTFNfVE9fUFJPQ0VTUyIsImNodW5rU2l6ZSIsImNlaWwiLCJyb3ciLCJjaHVua0hlaWdodCIsImNvbXBvc2VTTWFzayIsInNtYXNrIiwibGF5ZXJCb3giLCJsYXllcldpZHRoIiwibGF5ZXJIZWlnaHQiLCJnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnRlcnBvbGF0ZSIsImZyb3VuZCIsImFjdHVhbFNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkxJTkVfQ0FQX1NUWUxFUyIsIkxJTkVfSk9JTl9TVFlMRVMiLCJOT1JNQUxfQ0xJUCIsIkVPX0NMSVAiLCJjYW52YXNDdHgiLCJtYXJrZWRDb250ZW50U3RhY2siLCJzdGF0ZVN0YWNrIiwicGVuZGluZ0NsaXAiLCJwZW5kaW5nRU9GaWxsIiwicmVzIiwieG9ianMiLCJncm91cFN0YWNrIiwicHJvY2Vzc2luZ1R5cGUzIiwiYmFzZVRyYW5zZm9ybSIsImJhc2VUcmFuc2Zvcm1TdGFjayIsImdyb3VwTGV2ZWwiLCJzbWFza1N0YWNrIiwic21hc2tDb3VudGVyIiwidGVtcFNNYXNrIiwic3VzcGVuZGVkQ3R4IiwiY29udGVudFZpc2libGUiLCJjYWNoZWRDYW52YXNlcyIsImNhY2hlZFBhdHRlcm5zIiwidmlld3BvcnRTY2FsZSIsIm91dHB1dFNjYWxlWCIsIm91dHB1dFNjYWxlWSIsIl9jYWNoZWRTY2FsZUZvclN0cm9raW5nIiwiX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgiLCJfY2FjaGVkQml0bWFwc01hcCIsImdldE9iamVjdCIsImZhbGxiYWNrIiwic2F2ZWRGaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRyYW5zcGFyZW50Q2FudmFzIiwiY29tcG9zaXRlQ3R4IiwiZXhlY3V0aW9uU3RhcnRJZHgiLCJjb250aW51ZUNhbGxiYWNrIiwiYXJnc0FycmF5TGVuIiwiY2h1bmtPcGVyYXRpb25zIiwiZW5kVGltZSIsImZuSWQiLCJicmVha0l0IiwiZGVwT2JqSWQiLCJvYmpzUG9vbCIsInJlc3RvcmVJbml0aWFsU3RhdGUiLCJpblNNYXNrTW9kZSIsIkhUTUxDYW52YXNFbGVtZW50IiwiZHJhd0ZpbHRlciIsImhjbUZpbHRlcklkIiwic2F2ZWRGaWx0ZXIiLCJfc2NhbGVJbWFnZSIsImltZyIsIndpZHRoU2NhbGUiLCJoZWlnaHRTY2FsZSIsInBhaW50V2lkdGgiLCJwYWludEhlaWdodCIsInRtcENhbnZhc0lkIiwidG1wQ2FudmFzIiwidG1wQ3R4IiwiY2xlYXJSZWN0IiwiX2NyZWF0ZU1hc2tDYW52YXMiLCJpc1BhdHRlcm5GaWxsIiwiY3VycmVudFRyYW5zZm9ybSIsInNjYWxlZCIsIm1hc2tDYW52YXMiLCJtYWluS2V5IiwiY2FjaGVkSW1hZ2UiLCJtYXNrVG9DYW52YXMiLCJjb3JkMSIsImNvcmQyIiwiZHJhd25XaWR0aCIsImRyYXduSGVpZ2h0IiwiZmlsbENhbnZhcyIsImZpbGxDdHgiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJpbnZlcnNlIiwiZ2V0UGF0dGVybiIsImxpbWl0IiwiZGFzaEFycmF5IiwiZGFzaFBoYXNlIiwiZmxhdG5lc3MiLCJzdGF0ZXMiLCJjaGVja1NNYXNrU3RhdGUiLCJiZWdpblNNYXNrTW9kZSIsImVuZFNNYXNrTW9kZSIsImNhY2hlSWQiLCJzY3JhdGNoQ2FudmFzIiwiY29tcG9zZSIsImRpcnR5Qm94Iiwib2xkIiwicG9wIiwib3BzIiwic3RhcnRYIiwic3RhcnRZIiwiaXNTY2FsaW5nTWF0cml4IiwibWluTWF4Rm9yQmV6aWVyIiwieHciLCJ5aCIsImNvbnN1bWVQYXRoIiwicmVzY2FsZUFuZFN0cm9rZSIsIm5lZWRSZXN0b3JlIiwicGF0aHMiLCJwZW5kaW5nVGV4dFBhdGhzIiwiYWRkVG9QYXRoIiwic3BhY2luZyIsImZvbnRSZWZOYW1lIiwiZm9udE9iaiIsImZvbnREaXJlY3Rpb24iLCJpc1R5cGUzRm9udCIsInR5cGVmYWNlIiwiZmFsbGJhY2tOYW1lIiwiYm9sZCIsIml0YWxpYyIsImJyb3dzZXJGb250U2l6ZSIsInJpc2UiLCJwYWludENoYXIiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiZmlsbFN0cm9rZU1vZGUiLCJpc0FkZFRvUGF0aFNldCIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwicGF0dGVybiIsImdldFNpbmdsZVBpeGVsV2lkdGgiLCJpc0ludmFsaWRQREZqc0ZvbnQiLCJjaGFycyIsImdseXBoIiwidW5pY29kZSIsInJlc3RvcmVOZWVkZWQiLCJpc1NwYWNlIiwiZm9udENoYXIiLCJhY2NlbnQiLCJzY2FsZWRYIiwic2NhbGVkWSIsInZtZXRyaWMiLCJ2eCIsInZ5IiwicmVtZWFzdXJlIiwibWVhc3VyZWRXaWR0aCIsIm1lYXN1cmVUZXh0IiwiY2hhcmFjdGVyU2NhbGVYIiwiaXNJbkZvbnQiLCJzY2FsZWRBY2NlbnRYIiwic2NhbGVkQWNjZW50WSIsImNoYXJXaWR0aCIsImlzVGV4dEludmlzaWJsZSIsInNwYWNpbmdMZW5ndGgiLCJjaGFyUHJvY09wZXJhdG9yTGlzdCIsIm9wZXJhdG9yTGlzdElkIiwidHJhbnNmb3JtZWQiLCJ4V2lkdGgiLCJ5V2lkdGgiLCJsbHgiLCJsbHkiLCJ1cngiLCJ1cnkiLCJnZXRDb2xvck5fUGF0dGVybiIsIklSIiwiY2FudmFzR3JhcGhpY3NGYWN0b3J5IiwiY3JlYXRlQ2FudmFzR3JhcGhpY3MiLCJUaWxpbmdQYXR0ZXJuIiwiX2dldFBhdHRlcm4iLCJhcmd1bWVudHMiLCJtYXRyaXgiLCJnZXRTaGFkaW5nUGF0dGVybiIsIlNIQURJTkciLCJpbnYiLCJiYm94IiwiZ3JvdXAiLCJjdXJyZW50Q3R4IiwiaXNvbGF0ZWQiLCJrbm9ja291dCIsImNhbnZhc0JvdW5kcyIsImdyb3VwQ3R4Iiwic3RhcnRUcmFuc2Zvcm1JbnZlcnNlIiwiY3VycmVudE10eCIsImhhc093bkNhbnZhcyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiYW5ub3RhdGlvbkNhbnZhcyIsInNhdmVkQ3R4IiwiY29tcGlsZWQiLCJza2V3WCIsInNrZXdZIiwicG9zaXRpb25zIiwidHJhbnMiLCJpbWFnZXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzIiwiYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcCIsImltZ1RvUGFpbnQiLCJIVE1MRWxlbWVudCIsInRhZyIsInZpc2libGUiLCJpc1Zpc2libGUiLCJpc0NvbnRlbnRWaXNpYmxlIiwiYWJzRGV0Iiwibm9ybVgiLCJub3JtWSIsImdldFNjYWxlRm9yU3Ryb2tpbmciLCJzY2FsZWRMaW5lV2lkdGgiLCJzY2FsZWRYTGluZVdpZHRoIiwic2NhbGVkWUxpbmVXaWR0aCIsImJhc2VBcmVhIiwic2F2ZVJlc3RvcmUiLCJkYXNoZXMiLCJvcCIsImFwcGx5Qm91bmRpbmdCb3giLCJyZWdpb24iLCJCYXNlU2hhZGluZ1BhdHRlcm4iLCJSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIiwiX2Jib3giLCJfY29sb3JTdG9wcyIsIl9wMCIsIl9wMSIsIl9yMCIsIl9yMSIsIl9jcmVhdGVHcmFkaWVudCIsImdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwib3duZXIiLCJvd25lckJCb3giLCJjcmVhdGVQYXR0ZXJuIiwiZG9tTWF0cml4IiwiRE9NTWF0cml4IiwiZHJhd1RyaWFuZ2xlIiwiYzEiLCJjMiIsImMzIiwiY29vcmRzIiwicm93U2l6ZSIsInRtcCIsImMxciIsImMxZyIsImMxYiIsImMyciIsImMyZyIsImMyYiIsImMzciIsImMzZyIsImMzYiIsInhhIiwiY2FyIiwiY2FnIiwiY2FiIiwieGIiLCJjYnIiLCJjYmciLCJjYmIiLCJ4MV8iLCJ4Ml8iLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9maWd1cmVzIiwiX2JvdW5kcyIsIl9iYWNrZ3JvdW5kIiwiX2NyZWF0ZU1lc2hDYW52YXMiLCJjb21iaW5lZFNjYWxlIiwiYmFja2dyb3VuZENvbG9yIiwiRVhQRUNURURfU0NBTEUiLCJNQVhfUEFUVEVSTl9TSVpFIiwiQk9SREVSX1NJWkUiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsInBhZGRlZFdpZHRoIiwicGFkZGVkSGVpZ2h0IiwibWF0cml4U2NhbGUiLCJ0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzIiwiRHVtbXlTaGFkaW5nUGF0dGVybiIsIlBhaW50VHlwZSIsIkNPTE9SRUQiLCJVTkNPTE9SRUQiLCJ4c3RlcCIsInlzdGVwIiwicGFpbnRUeXBlIiwidGlsaW5nVHlwZSIsImNyZWF0ZVBhdHRlcm5DYW52YXMiLCJjdXJNYXRyaXhTY2FsZSIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJhZGp1c3RlZFgwIiwiYWRqdXN0ZWRZMCIsImFkanVzdGVkWDEiLCJhZGp1c3RlZFkxIiwiY2xpcEJib3giLCJyZWFsT3V0cHV0U2l6ZSIsImJib3hXaWR0aCIsImJib3hIZWlnaHQiLCJjc3NDb2xvciIsImNvbnZlcnRUb1JHQkEiLCJncmF5VG9SR0JBIiwiY29udmVydFJHQlRvUkdCQSIsImludmVyc2VEZWNvZGUiLCJ6ZXJvTWFwcGluZyIsIm9uZU1hcHBpbmciLCJ3aWR0aEluU291cmNlIiwid2lkdGhSZW1haW5kZXIiLCJsZW4zMiIsInNyYzMyIiwiczEiLCJzMiIsInMzIiwiamoiLCJDYWxsYmFja0tpbmQiLCJVTktOT1dOIiwiREFUQSIsIkVSUk9SIiwiU3RyZWFtS2luZCIsIkNBTkNFTCIsIkNBTkNFTF9DT01QTEVURSIsIkNMT1NFIiwiRU5RVUVVRSIsIlBVTEwiLCJQVUxMX0NPTVBMRVRFIiwiU1RBUlRfQ09NUExFVEUiLCJ3cmFwUmVhc29uIiwic291cmNlTmFtZSIsInRhcmdldE5hbWUiLCJjb21PYmoiLCJjYWxsYmFja0lkIiwic3RyZWFtSWQiLCJzdHJlYW1TaW5rcyIsInN0cmVhbUNvbnRyb2xsZXJzIiwiY2FsbGJhY2tDYXBhYmlsaXRpZXMiLCJhY3Rpb25IYW5kbGVyIiwiX29uQ29tT2JqT25NZXNzYWdlIiwic3RyZWFtIiwicHJvY2Vzc1N0cmVhbU1lc3NhZ2UiLCJjYlNvdXJjZU5hbWUiLCJjYlRhcmdldE5hbWUiLCJjcmVhdGVTdHJlYW1TaW5rIiwiYWN0aW9uTmFtZSIsImhhbmRsZXIiLCJhaCIsInF1ZXVlaW5nU3RyYXRlZ3kiLCJSZWFkYWJsZVN0cmVhbSIsImNvbnRyb2xsZXIiLCJzdGFydENhcGFiaWxpdHkiLCJzdGFydENhbGwiLCJwdWxsQ2FsbCIsImNhbmNlbENhbGwiLCJpc0Nsb3NlZCIsImRlc2lyZWRTaXplIiwicHVsbCIsInB1bGxDYXBhYmlsaXR5IiwiY2FuY2VsQ2FwYWJpbGl0eSIsInN0cmVhbVNpbmsiLCJpc0NhbmNlbGxlZCIsImxhc3REZXNpcmVkU2l6ZSIsInNpbmtDYXBhYmlsaXR5Iiwic3RyZWFtQ29udHJvbGxlciIsImRlbGV0ZVN0cmVhbUNvbnRyb2xsZXIiLCJhbGxTZXR0bGVkIiwibWV0YWRhdGFNYXAiLCJwYXJzZWREYXRhIiwiZ2V0UmF3IiwiSU5URVJOQUwiLCJTeW1ib2wiLCJPcHRpb25hbENvbnRlbnRHcm91cCIsIl9zZXRWaXNpYmxlIiwiaW50ZXJuYWwiLCJjYWNoZWRHZXRIYXNoIiwiZ3JvdXBzIiwiaW5pdGlhbEhhc2giLCJvcmRlciIsImNyZWF0b3IiLCJiYXNlU3RhdGUiLCJvZmYiLCJnZXRIYXNoIiwiZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbiIsImFycmF5Iiwib3BlcmF0b3IiLCJzdGF0ZSIsImV4cHJlc3Npb24iLCJwb2xpY3kiLCJpZHMiLCJzZXRWaXNpYmlsaXR5IiwiaGFzSW5pdGlhbFZpc2liaWxpdHkiLCJnZXRPcmRlciIsImdldEdyb3VwcyIsImdldEdyb3VwIiwicGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX3F1ZXVlZENodW5rcyIsIl9wcm9ncmVzc2l2ZURvbmUiLCJfY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUiLCJfcGRmRGF0YVJhbmdlVHJhbnNwb3J0IiwiX2lzU3RyZWFtaW5nU3VwcG9ydGVkIiwiX2lzUmFuZ2VTdXBwb3J0ZWQiLCJfY29udGVudExlbmd0aCIsIl9mdWxsUmVxdWVzdFJlYWRlciIsIl9yYW5nZVJlYWRlcnMiLCJfb25SZWNlaXZlRGF0YSIsIl9vblByb2dyZXNzIiwiX29uUHJvZ3Jlc3NpdmVEb25lIiwiX2VucXVldWUiLCJmb3VuZCIsIl9iZWdpbiIsIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgiLCJfbG9hZGVkIiwiX3JlbW92ZVJhbmdlUmVhZGVyIiwiaW5kZXhPZiIsInF1ZXVlZENodW5rcyIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIiLCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIiLCJfc3RyZWFtIiwiX2RvbmUiLCJfZmlsZW5hbWUiLCJfcmVxdWVzdHMiLCJfaGVhZGVyc1JlYWR5IiwicmVxdWVzdENhcGFiaWxpdHkiLCJfZW5kIiwiX3F1ZXVlZENodW5rIiwicmVxdWVzdHNDYXBhYmlsaXR5IiwiX25ldHdvcmtfdXRpbHMiLCJjcmVhdGVGZXRjaE9wdGlvbnMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwibWV0aG9kIiwic2lnbmFsIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImNyZWF0ZUhlYWRlcnMiLCJIZWFkZXJzIiwiZ2V0QXJyYXlCdWZmZXIiLCJpc0h0dHAiLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJfaGVhZGVycyIsInZhbGlkYXRlUmVzcG9uc2VTdGF0dXMiLCJjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJhbGxvd1JhbmdlUmVxdWVzdHMiLCJzdWdnZXN0ZWRMZW5ndGgiLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsImV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJfY29udGVudF9kaXNwb3NpdGlvbiIsInJldHVyblZhbHVlcyIsImNvbnRlbnRFbmNvZGluZyIsImNvbnRlbnREaXNwb3NpdGlvbiIsImdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlciIsIm5lZWRzRW5jb2RpbmdGaXh1cCIsInRvUGFyYW1SZWdFeHAiLCJyZmMyNjE2dW5xdW90ZSIsInJmYzU5ODdkZWNvZGUiLCJyZmMyMDQ3ZGVjb2RlIiwiZml4dXBFbmNvZGluZyIsInJmYzIyMzFnZXRwYXJhbSIsImF0dHJpYnV0ZVBhdHRlcm4iLCJmbGFncyIsInRleHRkZWNvZGUiLCJjb250ZW50RGlzcG9zaXRpb25TdHIiLCJpdGVyIiwicXVvdCIsInBhcnQiLCJwYXJ0cyIsInF1b3RpbmRleCIsImV4dHZhbHVlIiwiZW5jb2RpbmdlbmQiLCJsYW5ndmFsdWUiLCJjaGFyc2V0IiwiaGV4IiwiT0tfUkVTUE9OU0UiLCJQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UiLCJ4aHIiLCJOZXR3b3JrTWFuYWdlciIsImN1cnJYaHJJZCIsInBlbmRpbmdSZXF1ZXN0cyIsInJlcXVlc3RSYW5nZSIsInJlcXVlc3RGdWxsIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVxdWVzdFhociIsImlzUGVuZGluZ1JlcXVlc3QiLCJhYm9ydFJlcXVlc3QiLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkiLCJfY2FjaGVkQ2h1bmtzIiwiX3N0b3JlZEVycm9yIiwiZnVsbFJlcXVlc3RYaHJJZCIsImZ1bGxSZXF1ZXN0WGhyIiwibGVuZ3RoQ29tcHV0YWJsZSIsIl9yZXF1ZXN0SWQiLCJfY2xvc2UiLCJmaWxlVXJpUmVnZXgiLCJwYXJzZVVybCIsInNvdXJjZVVybCIsInBhcnNlZFVybCIsImhvc3QiLCJpc0ZzVXJsIiwiUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciIsIlBERk5vZGVTdHJlYW1GdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIiLCJQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIiLCJCYXNlRnVsbFJlYWRlciIsIl9yZWFkYWJsZVN0cmVhbSIsIl9lcnJvciIsIl9zZXRSZWFkYWJsZVN0cmVhbSIsIkJhc2VSYW5nZVJlYWRlciIsImNyZWF0ZVJlcXVlc3RPcHRpb25zIiwiYXV0aCIsImhvc3RuYW1lIiwiaGFuZGxlUmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiX3JlcXVlc3QiLCJodHRwIiwiaHR0cHMiLCJfaHR0cEhlYWRlcnMiLCJSYW5nZSIsImxzdGF0Iiwic3RhdCIsImNyZWF0ZVJlYWRTdHJlYW0iLCJTVkdfREVGQVVMVFMiLCJmb250U3R5bGUiLCJYTUxfTlMiLCJYTElOS19OUyIsImNvbnRlbnRUeXBlIiwiZm9yY2VEYXRhU2NoZW1hIiwiZGlnaXRzIiwiYjEiLCJiMiIsImIzIiwiZDEiLCJkMiIsImQzIiwiZDQiLCJjb252ZXJ0SW1nRGF0YVRvUG5nIiwiUE5HX0hFQURFUiIsIkNIVU5LX1dSQVBQRVJfU0laRSIsImNyY1RhYmxlIiwiY3JjMzIiLCJjcmMiLCJ3cml0ZVBuZ0NodW5rIiwibGVuIiwiYWRsZXIzMiIsImRlZmxhdGVTeW5jIiwibGl0ZXJhbHMiLCJkZWZsYXRlU3luY1VuY29tcHJlc3NlZCIsIm5vZGUiLCJmcm9tIiwib3V0cHV0IiwibWF4QmxvY2tMZW5ndGgiLCJkZWZsYXRlQmxvY2tzIiwiaWRhdCIsInBpIiwiYWRsZXIiLCJlbmNvZGUiLCJpc01hc2siLCJiaXREZXB0aCIsImNvbG9yVHlwZSIsIm9mZnNldExpdGVyYWxzIiwib2Zmc2V0Qnl0ZXMiLCJpaGRyIiwicG5nTGVuZ3RoIiwiU1ZHRXh0cmFTdGF0ZSIsImRlcGVuZGVuY2llcyIsImFjdGl2ZUNsaXBVcmwiLCJjbGlwR3JvdXAiLCJtYXNrSWQiLCJvcExpc3RUb1RyZWUiLCJvcExpc3QiLCJvcFRyZWUiLCJvcExpc3RFbGVtZW50IiwiZm4iLCJwZiIsInBtIiwiYWNvcyIsImNsaXBDb3VudCIsIm1hc2tDb3VudCIsInNoYWRpbmdDb3VudCIsInN2Z0ZhY3RvcnkiLCJ0cmFuc2Zvcm1NYXRyaXgiLCJ0cmFuc2Zvcm1TdGFjayIsImV4dHJhU3RhY2siLCJlbWJlZEZvbnRzIiwiZW1iZWRkZWRGb250cyIsImNzc1N0eWxlIiwiX29wZXJhdG9ySWRNYXBwaW5nIiwidGdycCIsImV4ZWN1dGVPcFRyZWUiLCJsb2FkRGVwZW5kZW5jaWVzIiwiZ2V0U1ZHIiwic3ZnRWxlbWVudCIsImNvbnZlcnRPcExpc3QiLCJvcGVyYXRvcklkTWFwcGluZyIsIm9wVHJlZUVsZW1lbnQiLCJsaW5lTWF0cml4IiwieGNvb3JkcyIsInljb29yZHMiLCJ0c3BhbiIsInNldEF0dHJpYnV0ZU5TIiwidHh0RWxlbWVudCIsInR4dGdycCIsImxpbmVXaWR0aFNjYWxlIiwiX3NldFN0cm9rZUF0dHJpYnV0ZXMiLCJfZW5zdXJlVHJhbnNmb3JtR3JvdXAiLCJhZGRGb250U3R5bGUiLCJoYXNDaGlsZE5vZGVzIiwic2V0U3Ryb2tlQWxwaGEiLCJzZXRGaWxsQWxwaGEiLCJfbWFrZUNvbG9yTl9QYXR0ZXJuIiwiX21ha2VTaGFkaW5nUGF0dGVybiIsIl9tYWtlVGlsaW5nUGF0dGVybiIsInRpbGluZ0lkIiwidHgwIiwidHkwIiwidHgxIiwidHkxIiwieHNjYWxlIiwieXNjYWxlIiwidHhzdGVwIiwidHlzdGVwIiwidGlsaW5nIiwiY2hpbGROb2RlcyIsInNoYWRpbmdJZCIsImNvbG9yU3RvcHMiLCJncmFkaWVudCIsInBvaW50MCIsInBvaW50MSIsImZvY2FsUG9pbnQiLCJjaXJjbGVQb2ludCIsImZvY2FsUmFkaXVzIiwiY2lyY2xlUmFkaXVzIiwic3RvcCIsImdldEF0dHJpYnV0ZU5TIiwiY2xpcElkIiwiY2xpcFBhdGgiLCJjbGlwRWxlbWVudCIsImNsb25lTm9kZSIsImltZ1NyYyIsImNsaXByZWN0IiwiaW1nRWwiLCJkZWZpbml0aW9ucyIsInJvb3RHcm91cCIsIl9lbnN1cmVDbGlwR3JvdXAiLCJ3YWxrIiwic2hvdWxkQnVpbGRUZXh0IiwiY2hpbGQiLCJUZXh0TGF5ZXJSZW5kZXJUYXNrIiwicmVuZGVyVGV4dExheWVyIiwidXBkYXRlVGV4dExheWVyIiwiTUFYX1RFWFRfRElWU19UT19SRU5ERVIiLCJERUZBVUxUX0ZPTlRfU0laRSIsIkRFRkFVTFRfRk9OVF9BU0NFTlQiLCJhc2NlbnRDYWNoZSIsImdldEN0eCIsImdldEFzY2VudCIsImNhY2hlZEFzY2VudCIsIm1ldHJpY3MiLCJhc2NlbnQiLCJmb250Qm91bmRpbmdCb3hBc2NlbnQiLCJkZXNjZW50IiwiZm9udEJvdW5kaW5nQm94RGVzY2VudCIsInJhdGlvIiwicGl4ZWxzIiwiYXBwZW5kVGV4dCIsImdlb20iLCJ0ZXh0RGl2IiwidGV4dERpdlByb3BlcnRpZXMiLCJoYXNUZXh0IiwiaGFzRU9MIiwiX3RleHREaXZzIiwiX3RyYW5zZm9ybSIsImF0YW4yIiwiZm9udE5hbWUiLCJmb250SGVpZ2h0IiwiZm9udEFzY2VudCIsIl9pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsInNpbiIsImNvcyIsInNjYWxlRmFjdG9yU3RyIiwiZGl2U3R5bGUiLCJfY29udGFpbmVyIiwiX3Jvb3RDb250YWluZXIiLCJfcGFnZVdpZHRoIiwiX3BhZ2VIZWlnaHQiLCJkaXIiLCJfZm9udEluc3BlY3RvckVuYWJsZWQiLCJkYXRhc2V0Iiwic2hvdWxkU2NhbGVUZXh0IiwiYWJzU2NhbGVYIiwiYWJzU2NhbGVZIiwiX3RleHREaXZQcm9wZXJ0aWVzIiwiX2lzUmVhZGFibGVTdHJlYW0iLCJfbGF5b3V0VGV4dCIsImxheW91dCIsInByZXZGb250U2l6ZSIsInByZXZGb250RmFtaWx5IiwiX2NhbmNlbGVkIiwidGV4dERpdnMiLCJ0ZXh0RGl2c0xlbmd0aCIsInRleHRDb250ZW50U291cmNlIiwidGV4dENvbnRlbnRJdGVtc1N0ciIsIl90ZXh0Q29udGVudFNvdXJjZSIsIl90ZXh0Q29udGVudEl0ZW1zU3RyIiwiX2xheW91dFRleHRQYXJhbXMiLCJfcHJvY2Vzc0l0ZW1zIiwic3R5bGVDYWNoZSIsImJyIiwiX3JlbmRlciIsInRleHRDb250ZW50U3RyZWFtIiwic2NhbGVGYWN0b3IiLCJtdXN0UmVzY2FsZSIsIkFubm90YXRpb25FZGl0b3JMYXllciIsIl9mcmVldGV4dCIsIl9pbmsiLCJfc3RhbXAiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsImFsbG93Q2xpY2siLCJhbm5vdGF0aW9uTGF5ZXIiLCJib3VuZFBvaW50ZXJ1cCIsImJvdW5kUG9pbnRlcmRvd24iLCJoYWRQb2ludGVyRG93biIsImlzQ2xlYW5pbmdVcCIsImlzRGlzYWJsaW5nIiwiX2luaXRpYWxpemVkIiwicG9pbnRlcnVwIiwiRnJlZVRleHRFZGl0b3IiLCJJbmtFZGl0b3IiLCJTdGFtcEVkaXRvciIsImFkZElua0VkaXRvcklmTmVlZGVkIiwiaXNDb21taXR0aW5nIiwiY3JlYXRlQW5kQWRkTmV3RWRpdG9yIiwicG9pbnRlckV2ZW50cyIsImFubm90YXRpb25FbGVtZW50SWRzIiwiZWRpdGFibGVzIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9ucyIsImVkaXRhYmxlIiwiaGlkZSIsImhpZGRlbkFubm90YXRpb25JZHMiLCJnZXRFZGl0YWJsZUFubm90YXRpb24iLCJzaG93IiwiY3VycmVudEFjdGl2ZSIsImF0dGFjaCIsImRldGFjaCIsInJlbW92ZVBvaW50ZXJJblRleHRMYXllciIsIm1vdmVFbGVtZW50SW5ET00iLCJhZGRVbmRvYWJsZUVkaXRvciIsImNyZWF0ZU5ld0VkaXRvciIsInBhc3RlRWRpdG9yIiwiZ2V0Q2VudGVyUG9pbnQiLCJhbm5vdGF0aW9uVHlwZSIsImFubm90YXRpb25FZGl0b3JUeXBlIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiX2Fubm90YXRpb25fbGF5ZXIiLCJib3VuZEVkaXRvckRpdkJsdXIiLCJib3VuZEVkaXRvckRpdkZvY3VzIiwiYm91bmRFZGl0b3JEaXZJbnB1dCIsImJvdW5kRWRpdG9yRGl2S2V5ZG93biIsImNvbnRlbnQiLCJlZGl0b3JEaXZJZCIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiZWRpdG9yRGl2Qmx1ciIsImVkaXRvckRpdkZvY3VzIiwiZWRpdG9yRGl2SW5wdXQiLCJlZGl0b3JEaXZLZXlkb3duIiwidXBkYXRlRm9udFNpemUiLCJ1cGRhdGVDb2xvciIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2Iiwic2V0RWRpdG9yRGltZW5zaW9ucyIsInNhdmVkRm9udHNpemUiLCJzYXZlZENvbG9yIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsInJlbW92ZUF0dHJpYnV0ZSIsInByZXZlbnRTY3JvbGwiLCJjaGVhdEluaXRpYWxSZWN0IiwiZXh0cmFjdFRleHQiLCJkaXZzIiwic2F2ZWREaXNwbGF5IiwiZGlzcGxheSIsInNhdmVkVGV4dCIsIm5ld1RleHQiLCJ0cmltRW5kIiwic2V0VGV4dCIsInNldENvbnRlbnQiLCJkYmxjbGljayIsImJhc2VYIiwiYmFzZVkiLCJwb3NYIiwicG9zWSIsInJlcGxhY2VDaGlsZHJlbiIsImxpbmUiLCJjcmVhdGVUZXh0Tm9kZSIsIkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQiLCJkZWZhdWx0QXBwZWFyYW5jZURhdGEiLCJmb250Q29sb3IiLCJ0ZXh0UG9zaXRpb24iLCJwYWRkaW5nIiwic3RydWN0VHJlZVBhcmVudElkIiwiaGFzRWxlbWVudENoYW5nZWQiLCJTdGFtcEFubm90YXRpb25FbGVtZW50IiwiSW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uTGF5ZXIiLCJfc2NyaXB0aW5nX3V0aWxzIiwiX2Rpc3BsYXlMMTBuX3V0aWxzIiwiX3hmYV9sYXllciIsIkRFRkFVTFRfVEFCX0lOREVYIiwiR2V0RWxlbWVudHNCeU5hbWVTZXQiLCJnZXRSZWN0RGltcyIsIkFubm90YXRpb25FbGVtZW50RmFjdG9yeSIsIkxpbmtBbm5vdGF0aW9uRWxlbWVudCIsIlRleHRBbm5vdGF0aW9uRWxlbWVudCIsImZpZWxkVHlwZSIsIlRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsInJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsImNoZWNrQm94IiwiQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIkNob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlBvcHVwQW5ub3RhdGlvbkVsZW1lbnQiLCJMaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCIsIkNpcmNsZUFubm90YXRpb25FbGVtZW50IiwiUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCIsIkNhcmV0QW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCIsIlN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IiwiRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCIsIkFubm90YXRpb25FbGVtZW50IiwiaGFzQm9yZGVyIiwiaXNSZW5kZXJhYmxlIiwiaWdub3JlQm9yZGVyIiwiY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJsaW5rU2VydmljZSIsImRvd25sb2FkTWFuYWdlciIsImltYWdlUmVzb3VyY2VzUGF0aCIsInJlbmRlckZvcm1zIiwiZW5hYmxlU2NyaXB0aW5nIiwiX2ZpZWxkT2JqZWN0cyIsImZpZWxkT2JqZWN0cyIsIl9jcmVhdGVDb250YWluZXIiLCJfY3JlYXRlUXVhZHJpbGF0ZXJhbHMiLCJfaGFzUG9wdXBEYXRhIiwidGl0bGVPYmoiLCJjb250ZW50c09iaiIsInJpY2hUZXh0IiwiaGFzUG9wdXBEYXRhIiwicG9wdXBSZWYiLCJub1JvdGF0ZSIsInNldFJvdGF0aW9uIiwiYm9yZGVyU3R5bGUiLCJib3JkZXJXaWR0aCIsImhvcml6b250YWxSYWRpdXMiLCJob3Jpem9udGFsQ29ybmVyUmFkaXVzIiwidmVydGljYWxSYWRpdXMiLCJ2ZXJ0aWNhbENvcm5lclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclJhZGl1cyIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0IiwiX2NvbW1vbkFjdGlvbnMiLCJzZXRDb2xvciIsImpzTmFtZSIsInN0eWxlTmFtZSIsImRldGFpbCIsImNvbG9yQXJyYXkiLCJDb2xvckNvbnZlcnRlcnMiLCJub1ZpZXciLCJub1ByaW50IiwidXNlck5hbWUiLCJ0aXRsZSIsInJlYWRvbmx5IiwiZGlzYWJsZWQiLCJyZXF1aXJlZCIsIl9zZXRSZXF1aXJlZCIsInRleHRDb2xvciIsIl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3giLCJhY3Rpb25zIiwianNFdmVudCIsImNvbW1vbkFjdGlvbnMiLCJfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMiLCJzdG9yZWREYXRhIiwiZXZlbnRQcm94eSIsInF1YWRQb2ludHMiLCJyZWN0QmxYIiwicmVjdEJsWSIsInJlY3RUclgiLCJyZWN0VHJZIiwidHJYIiwidHJZIiwiYmxYIiwiYmxZIiwic3ZnQnVmZmVyIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsImJhY2tncm91bmRJbWFnZSIsIl9jcmVhdGVQb3B1cCIsInBvcHVwIiwibW9kaWZpY2F0aW9uRGF0ZSIsInBhcmVudFJlY3QiLCJlbGVtZW50cyIsIl9nZXRFbGVtZW50c0J5TmFtZSIsInNraXBJZCIsImZpZWxkcyIsImZpZWxkT2JqIiwiZXhwb3J0VmFsdWVzIiwiZXhwb3J0VmFsdWUiLCJkb21FbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImdldEVsZW1lbnRzQnlOYW1lIiwiZ2V0QXR0cmlidXRlIiwibWF5YmVTaG93IiwiZm9yY2VIaWRlIiwiZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCIsImFkZEhpZ2hsaWdodEFyZWEiLCJ0cmlnZ2VycyIsIl9lZGl0T25Eb3VibGVDbGljayIsImlzVG9vbHRpcE9ubHkiLCJsaW5rIiwiaXNCb3VuZCIsImFkZExpbmtBdHRyaWJ1dGVzIiwibmV3V2luZG93IiwiX2JpbmROYW1lZEFjdGlvbiIsImF0dGFjaG1lbnQiLCJfYmluZEF0dGFjaG1lbnQiLCJzZXRPQ0dTdGF0ZSIsImJpbmRTZXRPQ0dTdGF0ZSIsIl9iaW5kTGluayIsIkFjdGlvbiIsIl9iaW5kSlNBY3Rpb24iLCJyZXNldEZvcm0iLCJfYmluZFJlc2V0Rm9ybUFjdGlvbiIsInNldEludGVybmFsTGluayIsImRlc3RpbmF0aW9uIiwiZ2V0RGVzdGluYXRpb25IYXNoIiwib25jbGljayIsImdvVG9EZXN0aW5hdGlvbiIsImdldEFuY2hvclVybCIsImV4ZWN1dGVOYW1lZEFjdGlvbiIsIm9wZW5PckRvd25sb2FkRGF0YSIsImV4ZWN1dGVTZXRPQ0dTdGF0ZSIsIm90aGVyQ2xpY2tBY3Rpb24iLCJyZXNldEZvcm1GaWVsZHMiLCJyZWZzIiwicmVzZXRGb3JtUmVmcyIsImluY2x1ZGUiLCJhbGxGaWVsZHMiLCJmaWVsZElkcyIsImZpZWxkTmFtZSIsImZpZWxkIiwiYWxsSWRzIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiYWx0IiwibDEwbklkIiwibDEwbkFyZ3MiLCJhbHRlcm5hdGl2ZVRleHQiLCJzaG93RWxlbWVudEFuZEhpZGVDYW52YXMiLCJwcmV2aW91c1NpYmxpbmciLCJub2RlTmFtZSIsIl9nZXRLZXlNb2RpZmllciIsIl9zZXRFdmVudExpc3RlbmVyIiwiZWxlbWVudERhdGEiLCJiYXNlTmFtZSIsImV2ZW50TmFtZSIsInZhbHVlR2V0dGVyIiwibW9kaWZpZXIiLCJmb2N1c2VkIiwiX3NldEV2ZW50TGlzdGVuZXJzIiwiZ2V0dGVyIiwiQmx1ciIsIkZvY3VzIiwiX3NldEJhY2tncm91bmRDb2xvciIsIl9zZXRUZXh0U3R5bGUiLCJURVhUX0FMSUdOTUVOVCIsImNvbXB1dGVkRm9udFNpemUiLCJyb3VuZFRvT25lRGVjaW1hbCIsIm11bHRpTGluZSIsIm51bWJlck9mTGluZXMiLCJsaW5lSGVpZ2h0IiwidGV4dEFsaWdubWVudCIsInRleHRBbGlnbiIsImlzUmVxdWlyZWQiLCJoYXNBcHBlYXJhbmNlIiwiZmllbGRWYWx1ZSIsInNldFByb3BlcnR5T25TaWJsaW5ncyIsImtleUluU3RvcmFnZSIsIm1heExlbiIsImNoYXJMaW1pdCIsImZpZWxkRm9ybWF0dGVkVmFsdWVzIiwiZm9ybWF0dGVkVmFsdWUiLCJjb21iIiwidXNlclZhbHVlIiwibGFzdENvbW1pdHRlZFZhbHVlIiwiY29tbWl0S2V5IiwiZG9Ob3RTY3JvbGwiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWFkT25seSIsIm1heExlbmd0aCIsImRlZmF1bHRGaWVsZFZhbHVlIiwiYmx1ckxpc3RlbmVyIiwic2Nyb2xsTGVmdCIsInNlbFJhbmdlIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJ3aWxsQ29tbWl0Iiwic2VsU3RhcnQiLCJzZWxlY3Rpb25TdGFydCIsInNlbEVuZCIsInNlbGVjdGlvbkVuZCIsIl9ibHVyTGlzdGVuZXIiLCJLZXlzdHJva2UiLCJpbnB1dFR5cGUiLCJjaGFuZ2UiLCJmaWVsZFdpZHRoIiwiY29tYldpZHRoIiwibGV0dGVyU3BhY2luZyIsInZlcnRpY2FsQWxpZ24iLCJjaGVja2VkIiwiY2hlY2tib3giLCJjdXJDaGVja2VkIiwiYnV0dG9uVmFsdWUiLCJyYWRpbyIsInBkZkJ1dHRvblZhbHVlIiwibGlua0VsZW1lbnQiLCJsYXN0Q2hpbGQiLCJzZWxlY3RFbGVtZW50IiwiYWRkQW5FbXB0eUVudHJ5IiwiY29tYm8iLCJtdWx0aVNlbGVjdCIsIm11bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWQiLCJvcHRpb25FbGVtZW50IiwiZGlzcGxheVZhbHVlIiwicmVtb3ZlRW1wdHlFbnRyeSIsIm5vbmVPcHRpb25FbGVtZW50IiwiaXNFeHBvcnQiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0ZWRWYWx1ZXMiLCJnZXRJdGVtcyIsIm11bHRpcGxlU2VsZWN0aW9uIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzZWxlY3RDaGlsZCIsImJlZm9yZSIsImluZGljZXMiLCJjaGFuZ2VFeCIsImtleURvd24iLCJQb3B1cEVsZW1lbnQiLCJlbGVtZW50SWRzIiwiZGF0ZVRpbWVQcm9taXNlIiwiYm91bmRLZXlEb3duIiwiYm91bmRIaWRlIiwiYm91bmRTaG93IiwiYm91bmRUb2dnbGUiLCJwaW5uZWQiLCJ3YXNWaXNpYmxlIiwiZGF0ZU9iamVjdCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvTG9jYWxlVGltZVN0cmluZyIsInRyaWdnZXIiLCJmbGF0TWFwIiwiYmFzZUNvbG9yIiwib3V0bGluZUNvbG9yIiwiQkFDS0dST1VORF9FTkxJR0hUIiwiaGVhZGVyIiwibG9jYWxpemVkIiwiWGZhTGF5ZXIiLCJ4ZmFIdG1sIiwiaHRtbCIsImNvbnRlbnRzIiwiX2Zvcm1hdENvbnRlbnRzIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJsaW5lcyIsImxpbmVTcGFuIiwibGluZUNvb3JkaW5hdGVzIiwic3F1YXJlIiwiY2lyY2xlIiwicG9seWxpbmUiLCJjb250YWluZXJDbGFzc05hbWUiLCJzdmdFbGVtZW50TmFtZSIsImNvb3JkaW5hdGUiLCJ2ZXJ0aWNlcyIsInBvbHlsaW5lcyIsImlua0xpc3QiLCJpbmtMaXN0cyIsImRvd25sb2FkIiwiZWRpdGFibGVBbm5vdGF0aW9ucyIsIk51bGxMMTBuIiwiYXBwZW5kRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwiZmlyc3RDaGlsZCIsImFubm90YXRpb25zIiwicG9wdXBUb0VsZW1lbnRzIiwiZWxlbWVudFBhcmFtcyIsIm5vSFRNTCIsImlzUG9wdXBBbm5vdGF0aW9uIiwicmVuZGVyZWQiLCJzZXRBbm5vdGF0aW9uQ2FudmFzTWFwIiwicmVwbGFjZVdpdGgiLCJtYWtlQ29sb3JDb21wIiwic2NhbGVBbmRDbGFtcCIsIkNNWUtfRyIsIkdfQ01ZSyIsIkdfUkdCIiwiR19yZ2IiLCJHX0hUTUwiLCJHIiwiUkdCX0ciLCJSR0JfcmdiIiwiUkdCX0hUTUwiLCJUX0hUTUwiLCJUX3JnYiIsIkNNWUtfUkdCIiwiQ01ZS19yZ2IiLCJDTVlLX0hUTUwiLCJjb21wb25lbnRzIiwiUkdCX0NNWUsiLCJnZXRMMTBuRmFsbGJhY2siLCJERUZBVUxUX0wxME5fU1RSSU5HUyIsIm9mX3BhZ2VzIiwicGFnZV9vZl9wYWdlcyIsImRvY3VtZW50X3Byb3BlcnRpZXNfa2IiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX21iIiwiZG9jdW1lbnRfcHJvcGVydGllc19kYXRlX3N0cmluZyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX3VuaXRfaW5jaGVzIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9taWxsaW1ldGVycyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX29yaWVudGF0aW9uX3BvcnRyYWl0IiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfb3JpZW50YXRpb25fbGFuZHNjYXBlIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9hMyIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTQiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xldHRlciIsImRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfbGVnYWwiLCJkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fc3RyaW5nIiwiZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfZGltZW5zaW9uX25hbWVfc3RyaW5nIiwiZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX3llcyIsImRvY3VtZW50X3Byb3BlcnRpZXNfbGluZWFyaXplZF9ubyIsImFkZGl0aW9uYWxfbGF5ZXJzIiwicGFnZV9sYW5kbWFyayIsInRodW1iX3BhZ2VfdGl0bGUiLCJ0aHVtYl9wYWdlX2NhbnZhcyIsImZpbmRfcmVhY2hlZF90b3AiLCJmaW5kX3JlYWNoZWRfYm90dG9tIiwiZmluZF9ub3RfZm91bmQiLCJwYWdlX3NjYWxlX3dpZHRoIiwicGFnZV9zY2FsZV9maXQiLCJwYWdlX3NjYWxlX2F1dG8iLCJwYWdlX3NjYWxlX2FjdHVhbCIsInBhZ2Vfc2NhbGVfcGVyY2VudCIsImxvYWRpbmdfZXJyb3IiLCJpbnZhbGlkX2ZpbGVfZXJyb3IiLCJtaXNzaW5nX2ZpbGVfZXJyb3IiLCJ1bmV4cGVjdGVkX3Jlc3BvbnNlX2Vycm9yIiwicmVuZGVyaW5nX2Vycm9yIiwiYW5ub3RhdGlvbl9kYXRlX3N0cmluZyIsInByaW50aW5nX25vdF9zdXBwb3J0ZWQiLCJwcmludGluZ19ub3RfcmVhZHkiLCJ3ZWJfZm9udHNfZGlzYWJsZWQiLCJmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudCIsImVkaXRvcl9mcmVlX3RleHQyX2FyaWFfbGFiZWwiLCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsIiwiZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbCIsImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWwiLCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWwiLCJlZGl0b3JfYWx0X3RleHRfZGVjb3JhdGl2ZV90b29sdGlwIiwicHJpbnRfcHJvZ3Jlc3NfcGVyY2VudCIsImZvcm1hdEwxMG5WYWx1ZSIsImdldExhbmd1YWdlIiwiZ2V0RGlyZWN0aW9uIiwic2V0dXBTdG9yYWdlIiwieGZhT24iLCJ4ZmFPZmYiLCJzZXRBdHRyaWJ1dGVzIiwiaXNIVE1MQW5jaG9yRWxlbWVudCIsIkhUTUxBbmNob3JFbGVtZW50IiwiZGF0YUlkIiwicm9vdEh0bWwiLCJzdGFjayIsInJvb3REaXYiLCJjaGlsZEh0bWwiLCJ4bWxucyIsImVsIiwicXVlcnlTZWxlY3RvckFsbCIsImJhc2VIZWlnaHQiLCJiYXNlV2lkdGgiLCJib3VuZENhbnZhc1BvaW50ZXJtb3ZlIiwiYm91bmRDYW52YXNQb2ludGVybGVhdmUiLCJib3VuZENhbnZhc1BvaW50ZXJ1cCIsImJvdW5kQ2FudmFzUG9pbnRlcmRvd24iLCJjdXJyZW50UGF0aDJEIiwiaGFzU29tZXRoaW5nVG9EcmF3IiwiaXNDYW52YXNJbml0aWFsaXplZCIsIm9ic2VydmVyIiwicmVhbFdpZHRoIiwicmVhbEhlaWdodCIsInJlcXVlc3RGcmFtZUNhbGxiYWNrIiwiX2RlZmF1bHRPcGFjaXR5IiwiX2RlZmF1bHRUaGlja25lc3MiLCJjYW52YXNQb2ludGVybW92ZSIsImNhbnZhc1BvaW50ZXJsZWF2ZSIsImNhbnZhc1BvaW50ZXJ1cCIsImNhbnZhc1BvaW50ZXJkb3duIiwidGhpY2tuZXNzIiwiYmV6aWVyUGF0aDJEIiwiYWxsUmF3UGF0aHMiLCJjdXJyZW50UGF0aCIsInRyYW5zbGF0aW9uWCIsInRyYW5zbGF0aW9uWSIsInVwZGF0ZVRoaWNrbmVzcyIsInVwZGF0ZU9wYWNpdHkiLCJzYXZlZFRoaWNrbmVzcyIsImZpdFRvQ29udGVudCIsInJlZHJhdyIsInNhdmVkT3BhY2l0eSIsImNyZWF0ZU9ic2VydmVyIiwic2V0Q2FudmFzRGltcyIsImRpc2Nvbm5lY3QiLCJzZXREaW1lbnNpb25zIiwiZ2V0SW5pdGlhbEJCb3giLCJzZXRTdHJva2UiLCJzdGFydERyYXdpbmciLCJkcmF3UG9pbnRzIiwiZHJhdyIsImxhc3RYIiwibGFzdFkiLCJwYXRoMkQiLCJtYWtlQmV6aWVyQ3VydmUiLCJsYXN0UG9pbnQiLCJzdG9wRHJhd2luZyIsImJlemllciIsImdlbmVyYXRlQmV6aWVyUG9pbnRzIiwieHkiLCJsYXN0UG9pbnRzIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsInByZXZYIiwicHJldlkiLCJiZXppZXJQb2ludHMiLCJjb250cm9sMSIsImNvbnRyb2wyIiwidXBkYXRlVHJhbnNmb3JtIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsIm9ic2VydmUiLCJyb3VuZGVkV2lkdGgiLCJyb3VuZGVkSGVpZ2h0Iiwic2V0U2NhbGVGYWN0b3IiLCJnZXRQYWRkaW5nIiwic2NhbGVGYWN0b3JXIiwic2NhbGVGYWN0b3JIIiwiYnVpbGRQYXRoMkQiLCJ0b1BERkNvb3JkaW5hdGVzIiwiZnJvbVBERkNvb3JkaW5hdGVzIiwic2VyaWFsaXplUGF0aHMiLCJwMTAiLCJwMTEiLCJwMjAiLCJwMjEiLCJwMzAiLCJwMzEiLCJwNDAiLCJwNDEiLCJnZXRCYm94IiwiZmlyc3RUaW1lIiwicHJldlRyYW5zbGF0aW9uWCIsInByZXZUcmFuc2xhdGlvblkiLCJ1bnNjYWxlZFBhZGRpbmciLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwicmVzaXplVGltZW91dElkIiwiaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2siLCJzdXBwb3J0ZWRUeXBlcyIsInN1cHBvcnRlZFR5cGVzU3RyIiwiZ2V0QXNGaWxlIiwiZ2V0Qml0bWFwRmV0Y2hlZCIsImZyb21JZCIsImdldEJpdG1hcERvbmUiLCJnZXRCaXRtYXAiLCJhY2NlcHQiLCJmaWxlcyIsImNsaWNrIiwiTUFYX1JBVElPIiwiZmFjdG9yIiwiZHJhd0JpdG1hcCIsInNjYWxlQml0bWFwIiwiYml0bWFwV2lkdGgiLCJiaXRtYXBIZWlnaHQiLCJwcmV2V2lkdGgiLCJwcmV2SGVpZ2h0Iiwib2Zmc2NyZWVuIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwic2VyaWFsaXplQml0bWFwIiwidG9VcmwiLCJ0b0RhdGFVUkwiLCJhY2Nlc3NpYmlsaXR5RGF0YSIsInN0YW1wcyIsImFyZWEiLCJwcmV2RGF0YSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsIl9hbm5vdGF0aW9uX2VkaXRvcl9sYXllciIsIl9hcGkiLCJfdGV4dF9sYXllciIsInBkZmpzVmVyc2lvbiIsInBkZmpzQnVpbGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.js\n");

/***/ })

};
;